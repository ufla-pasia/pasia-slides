---
title: Automatizando Tarefas Tediosas
subtitle: PASIA - Aula T.6
---

##  

O conte√∫do dessa aula √© baseado no **cap√≠tulo 9** do livro abaixo.

![](imagens/livro_potter_zingaro.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

# Introdu√ß√£o {background-color="#40666e"}

##

Suponha que voc√™ seja respons√°vel por criar 100 relat√≥rios, cada um para uma pessoa diferente.

- Poderia ser um professor que precisa enviar corre√ß√µes para seus estudantes.
- Ou algu√©m em um departamento de RH que precisa enviar a avalia√ß√£o anual para cada funcion√°rio.

. . .

Suponha que voc√™ tenha decidido preparar os relat√≥rios em arquivos PDF.

- E que voc√™ precisa de uma capa para os arquivos que √© customizada para cada pessoa.
- Seu colega, designer gr√°fico, preparou essas capas para voc√™.

##

Voc√™ e seu colega trabalharam de forma independente e agora cada um terminou sua tarefa.

- Quer dizer, quase, pois agora √© necess√°rio juntar as capas com os relat√≥rios.

. . .

Algu√©m que n√£o √© programador estaria agora _"rangendo os dentes"_

- com o trabalho manual de juntar cada capa com cada relat√≥rio.
- Isso poderia levar horas!

##

Mas n√≥s somos [programadores]{.alert}!

- E programadores nunca fariam um trabalho desse manualmente!
- Ou pelo menos n√£o deveriam.

. . .

::: {.callout-tip}
Muitas vezes seguimos o ditado: _Casa de ferreiro, espeto de pau._

E perdemos tempo com tarefas que poderiam ser otimizadas.
:::

##

Nessa aula vamos ver como escrever programas que automatizam tarefas tediosas.

- Uma das tarefas ser√° essa dos PDFs.
- Mas tamb√©m veremos outras tipos de tarefas manuais com as quais podemos ganhar tempo
  automatizando-as.

# Por que programadores criam ferramentas? {background-color="#40666e"}

##

Muitas vezes os programadores se definem como _pregui√ßosos_.

- N√£o no sentido de que n√£o queremos fazer nosso trabalho.
- Mas sim, que n√£o queremos fazer tarefas que s√£o **repetitivas**, **chatas**, **tediosas** üòí.
  - Tipos de tarefas que os computadores s√£o muito melhores que n√≥s.

. . .

Bons programadores costumam ter um üï∑Ô∏è _"sentido aranha"_ üï∏Ô∏è para identificar tarefas penosas.

##

Suponha, por exemplo, que tenhamos centenas de fotos que juntamos de uma viagem. üñºÔ∏è

- E queremos remover as fotos duplicadas.
- E, claro, n√£o queremos ter o trabalho de verificar uma por uma, pois isso levaria muito tempo.

. . .

Ou suponha que um professor tenha que enviar um e-mail com notas para cada um de seus estudantes.

- Se forem poucos alunos ele pode escrever um e-mail para cada um.
- Mas se forem muitos, nenhum professor vair querer fazer isso manualmente.

##

Sempre que um **bom programador** se depara com uma tarefa com passos repetitivos

- ele pensa em como construir uma [ferramenta]{.alert} para automatiz√°-la.

. . .

O termo **ferramenta** est√° sendo usado aqui no sentido de programas 
que fazem algo que nos poupe tempo.

- Muitas vezes a ferramenta em si n√£o √© o objetivo final.
- E criar a ferramenta pode tamb√©m ser meio entendiante.
- Mas uma vez que ela est√° pronta, ela pode nos poupar muito tempo.

##

√Äs vezes criamos uma ferramenta para usar uma √∫nica vez.

- Mas, na maioria das vezes, essas ferramentas acabam se tornando √∫teis novamente no futuro.
  - Seja do jeito que ela foi constru√≠da inicialmente,
  - ou com algumas melhorias.

##

Eu, Julio, por exemplo, envio um e-mail com feedback individual para os alunos ap√≥s as corre√ß√µes das provas das disciplinas que leciono.

- Seria invi√°vel fazer isso manualmente.

. . .

Eu fa√ßo a corre√ß√£o da prova em uma panilha do Google.

- E escrevi um script (_Apps Script_) que l√™ a planilha e envia o e-mail para cada aluno.
- Deu um trabalho inicialmente, e de vez em quando preciso fazer ajustes.
- Mas no final das contas, o tempo que economizo √© enorme.

##

E agora que temos Assistentes de IA, como o Copilot,

- ficou ainda mais f√°cil criarmos ferramentas para tarefas repetitivas.

. . .

N√£o faz sentido um programador n√£o usar essas ferramentas para se ajudar.

- nem no sentido pessoal (podemos usar o tempo que economizamos para coisas mais prazerosas).
- nem no sentido profissional (podemos aumentar nossa produtividade).

# Como usar o Copilot para criar ferramentas {background-color="#40666e"}

##

Muitas vezes precisamos usar [m√≥dulos]{.alert} (**bibliotecas**) do Python para realizar alguma
tarefa que precisamos.

- Pode ser que seja uma biblioteca inclu√≠da (**_built-in_**) do Python.
  - Ex.: `csv`, `json`, `zipfile`, etc.
- Ou uma biblioteca que precisamos **instalar** antes de usar.

##

Quando estamos criando ferramentas, √© muito comum que: 

- precisemos lidar com arquivos de diferentes formato
  - (como arquivos zip, pdf, planilhas de excel ou imagens).
- e que precisemos fazer alguma tarefa espec√≠fica
  - (como enviar e-mails, intergair com um site, mover arquivos, etc).

. . .

Para muitas dessas coisas precisaremos usar algum m√≥dulo. 

- Mas qual m√≥dulo?
- E ele √© _built-in_ ou preciso instalar?

##

Assistentes de IA, como o Copilot, podem nos ajudar a come√ßar.

- A ideia √© conversarmos com o assistente de IA para descobrir qual m√≥dulo precisamos usar.
- E s√≥ depois disso entramos na etapa de criar a ferramenta propriamente dita.

. . .

Na cria√ß√£o da ferramenta, podemos seguir os passos que vimos anteriormente.

- Definir uma fun√ß√£o, e sua docstring, e depois pedir para o Copilot gerar o c√≥digo dela.

##

Ao fazer isso, devemos seguir o processo que j√° vimos antes:

- verificar a corretude do c√≥digo (testes), 
- corrigir os bugs, 
- e talvez decompor o problema.

. . .

Mas aqui na aula vamos nos concentrar na intera√ß√£o com o Copilot para automizarmos a tarefa que precisamos.

- Para manter o foco no conte√∫do que estamos trabalhando neste cap√≠tulo.

## 

N√≥s poder√≠amos pedir ao Copilot ou ao ChatGPT para fazer a ferramenta completa.

- Mas vamos manter a ideia de criar fun√ß√µes.

. . . 

Acreditamos que vale a pena trabalharmos com fun√ß√µes, documentadas.

- De forma que seja mais f√°cil, no futuro, fazer alguma melhoria ou evolu√ß√£o necess√°ria na ferramenta.

# Exemplo 1: Lista de compras {background-color="#40666e"}

##

Suponha que voc√™ precise enviar uma **lista de compras** para algu√©m por WhatsApp ou e-mail.

- E que essa lista precise ser **numerada**, com **um item por linha**, e em **ordem alfab√©tica**.

. . .

Mas voc√™ recebeu a lista de compras de algu√©m (talvez seu chefe)

- que simplesmente digitou os itens separados por espa√ßo, e em uma ordem qualquer.

. . .

Vamos usar o Copilot para automatizar essa tarefa.


## 

Como voc√™ recebeu os itens por e-mail ou WhatsApp,

- a ferramenta ser√° mais √∫til se pudermos **copiar (Ctrl+c)** os itens da mensagem.
- e **colar (Ctrl+v)** na nossa ferramenta para ela gerar a lista numerada.
- Caso contr√°rio, ter√≠amos que redigitar a lista
  - e a√≠ n√£o estar√≠amos economizando tempo.

. . .

Para isso, precisaremos usar a [√Årea de Transfer√™ncia]{.alert} (_Clipboard_) do Sistema Operacional.

##

Essa **√Årea de Transfer√™ncia** √© onde ficam os √∫ltimos dados que copiamos com o Ctrl+c.

. . .


Podemos ent√£o criar uma ferramenta que obtenha as palavras da √Årea de Transfer√™ncia;

- gere a lista numerada;
- e copie a lista numerada de volta para a √Årea de Transfer√™ncia.

. . .

Assim, depois de rodar a ferramenta, podemos simplesmente colar (Ctrl+v) a lista numerada onde quisermos.

##

Basicamente o que precisamos fazer em um programa em Python √©:

- Ler o conte√∫do da √Årea de Transfer√™ncia e guardar em uma string.
- Gerar a lista numerada e ordenada a partir dessa string.
- Guardar a lista em uma nova string.
- Colocar a nova string na √Årea de Transfer√™ncia.

. . .

Mas como podemos usar a √Årea de Transfer√™ncia em um programa Python?

## 

Vamos descobrir isso usando a janela de chat do Copilot.

- Mas vamos fazer uma explora√ß√£o mais ampla antes de implementar uma solu√ß√£o.

. . .

Vamos abrir uma pasta vazia no VS Code e usar o modo `Ask` do chat do Copilot.

##


::: {.callout-caution title="Prompt" icon="false"}
Eu gostaria de escrever um programa em Python que 
acessa a √°rea de transfer√™ncia e que permita copiar 
e colar usando a √°rea de transfer√™ncia. 
Como posso fazer isso?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
Voc√™ pode usar o m√≥dulo `pyperclip` para acessar a √°rea de transfer√™ncia no Python. 

Ele permite copiar e colar texto facilmente. Veja como fazer:

1. Instale o pacote:
```bash
pip install pyperclip
```

2. Exemplo de c√≥digo para copiar e colar:

````python
import pyperclip

# Copiar texto para a √°rea de transfer√™ncia
pyperclip.copy("Ol√°, √°rea de transfer√™ncia!")

# Colar (obter) texto da √°rea de transfer√™ncia
texto = pyperclip.paste()
print("Texto copiado:", texto)
````

Esse c√≥digo copia um texto para a √°rea de transfer√™ncia e depois l√™ o que est√° l√°.  
Funciona em Linux, Windows e macOS.
:::

##

A resposta do Copilot nos ensina que podemos usar o m√≥dulo `pyperclip` para
interagir com a √Årea de Transfer√™ncia em um programa em Python.

- E nos d√° um exemplo de como usar o m√≥dulo.
- Ele tamb√©m nos diz como instalar o m√≥dulo.
  - O que mostra que ele √© n√£o √© _built-in_.

. . .

Mas ser√° que n√£o daria para fazer nossa ferramenta sem instalar um m√≥dulo?

- Vamos perguntar ao Copilot.

##


::: {.callout-caution title="Prompt" icon="false"}
Existe alguma forma de fazer isso sem precisar instalar um m√≥dulo Python?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
Sim, √© poss√≠vel acessar a √°rea de transfer√™ncia sem instalar m√≥dulos externos, mas depende do sistema operacional. 
No Linux, voc√™ pode usar comandos do sistema como `xclip` ou `xsel` via `subprocess`. Veja um exemplo usando `xclip`:

````python
import subprocess

# Copiar texto para a √°rea de transfer√™ncia
texto = "Ol√°, √°rea de transfer√™ncia!"
process = subprocess.Popen(['xclip', '-selection', 'clipboard'], stdin=subprocess.PIPE)
process.communicate(input=texto.encode())

# Colar (obter) texto da √°rea de transfer√™ncia
process = subprocess.Popen(['xclip', '-selection', 'clipboard', '-o'], stdout=subprocess.PIPE)
saida, _ = process.communicate()
print("Texto copiado:", saida.decode())
````

**Observa√ß√µes:**

- Voc√™ precisa ter o `xclip` instalado (`sudo apt install xclip`).
- Para Windows, pode-se usar `clip` e `powershell` via subprocess.
- Para macOS, use `pbcopy` e `pbpaste`.

Se precisar de exemplos para outros sistemas, √© s√≥ pedir!
:::

##

Bom essa solu√ß√£o tem uma desvantagem: depende de um programa externo e do sistema operacional.

- Se formos tratar a tarefa apenas uma √∫nica vez poderia nos atender.
- Mas pensando em usos futuros, n√£o √© a melhor solu√ß√£o.

. . .

Vamos explorar mais solu√ß√µes.

##


::: {.callout-caution title="Prompt" icon="false"}
Existe algum outro jeito de fazer isso sem precisar instalar um m√≥dulo Python?
:::


##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
Sim, mas voc√™ ainda vai precisar de algum utilit√°rio externo j√° instalado no sistema, 
como `xclip` ou `xsel` no Linux, `pbcopy`/`pbpaste` no macOS, ou `clip` no Windows. 
 
O Python puro n√£o oferece acesso direto √† √°rea de transfer√™ncia na biblioteca padr√£o.

No Linux, por exemplo, se o `xclip` j√° estiver instalado, voc√™ pode usar o seguinte c√≥digo:

````python
import subprocess

# Copiar texto para a √°rea de transfer√™ncia
subprocess.run("echo 'Texto para copiar' | xclip -selection clipboard", shell=True)

# Colar texto da √°rea de transfer√™ncia
resultado = subprocess.run("xclip -selection clipboard -o", shell=True, capture_output=True, text=True)
print("Texto colado:", resultado.stdout)
````

**Resumo:**  
Sem instalar m√≥dulos Python, voc√™ pode usar comandos do sistema operacional via `subprocess`, 
desde que o utilit√°rio de √°rea de transfer√™ncia j√° esteja dispon√≠vel no seu sistema.
:::


##

Bom, essa resposta n√£o ajudou muito, afinal continua basicamente fazendo a mesma coisa
da resposta anterior

. . .

No livro, a primeira solu√ß√£o dada pelo Copilot usava o m√≥dulo `tkinter`.

- Que tem a limita√ß√£o de s√≥ funcionar em ambientes gr√°ficos (n√£o funciona em servidores Linux, por exemplo).

. . .

Ao pedir outra op√ß√£o, o Copilot sugeriu um c√≥digo espec√≠fico para Windows usando `win32clipboard`.

- Porque os autores estavam em ambiente Windows.
- Mas tem o mesmo tipo de limita√ß√£o da nossa solu√ß√£o com `xclip`.

##

Avaliando ent√£o as op√ß√µes que temos, a melhor √© usar o m√≥dulo `pyperclip`.

- Afinal instalar um m√≥dulo n√£o √© algo t√£o complicado.
- E o `pyperclip` funciona em Linux, Windows e macOS,
  - sem depender de programas externos.

##

:::{.callout-note}
## Mas por que devemos explorar e entender v√°rias op√ß√µes?

H√° v√°rios motivos porque n√£o dever√≠amos simplesmente usar a primeira op√ß√£o do Copilot:

- Pode n√£o funcionar em todos os sistemas operacionais. 
  - O que limita os potenciais usu√°rios da ferramenta.
- Pode n√£o funcionar para a tarefa que precisamos, ou pode ser que cheguemos em um ponto
que ficamos travados em como resolver um problema.
  - E a√≠ sabermos que temos outras op√ß√µes pode nos ajudar a sair do impasse.
- M√≥dulos s√£o atualizados com frequ√™ncia.
  - E fun√ß√µes que existiam, podem n√£o existir nas vers√µes mais atuais.
  - Ou sua forma de uso pode ter sido alterada.
  - E, assim, uma sugest√£o do Copilot pode n√£o funcionar mais.
:::

## 

Agora que sabemos como acessar a √Årea de Transfer√™ncia, podemos criar nossa ferramenta.

- como vamos precisar instalar um m√≥dulo, vamos aproveitar para aprender como fazer isso do jeito mais correto.
- Claro, com a ajuda do Copilot.

. . .


::: {.callout-caution title="Prompt" icon="false"}
Vou seguir com a sugest√£o que usa pyperclip. Mas, antes disso, me explique a melhor forma de instalar um m√≥dulo Python para um projeto?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
 A melhor forma de instalar um m√≥dulo Python para um projeto √© usar um ambiente virtual. Assim, as depend√™ncias ficam isoladas e n√£o afetam outros projetos ou o sistema.

**Passos recomendados:**

1. **Crie um ambiente virtual na pasta do projeto:**
```bash
python3 -m venv venv
```

2. **Ative o ambiente virtual:**
```bash
source venv/bin/activate
```

3. **Instale o m√≥dulo desejado (exemplo: pyperclip):**
```bash
pip install pyperclip
```

4. **(Opcional) Gere um arquivo de depend√™ncias:**
```bash
pip freeze > requirements.txt
```

Assim, voc√™ mant√©m seu projeto organizado e f√°cil de compartilhar ou replicar em outros ambientes.
:::

##

O Copilot nos ensinou a criar um ambiente virtual.

- De modo que a instala√ß√£o do m√≥dulo `pyperclip` fique dentro da pasta do pr√≥prio projeto.
- Evitando interfer√™ncias e conflitos de vers√µes com outros projetos.

. . .

Tamb√©m aprendemos a gerar um arquivo `requirements.txt`

- mas n√£o ficou muito claro para que ele serve, j√° que foi gerado somente ao final.

. . .

Vamos perguntar ao Copilot.

##


::: {.callout-caution title="Prompt" icon="false"}
Para que serve o arquivo requirements.txt?
:::

. . .

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
O arquivo requirements.txt serve para listar todas as depend√™ncias (m√≥dulos e suas vers√µes) necess√°rias para o seu projeto Python. Ele facilita a instala√ß√£o dessas depend√™ncias em outros ambientes ou por outros desenvolvedores, usando o comando:

```bash
pip install -r requirements.txt
```

Assim, todos os pacotes listados no arquivo ser√£o instalados automaticamente, garantindo que o projeto funcione corretamente.
:::

##

Agora ficou mais claro.

- Quando formos instalar o projeto em outro computador, ou quando algu√©m for usar o projeto,
- basta criar um ambiente virtual e rodar o comando `pip install -r requirements.txt`.

. . .

Vamos, enfim, criar nossa ferramenta.

- Para isso, vamos, criar um arquivo Python, importar o m√≥dulo `pyperclip`
- e definir a assinatura e docstring fun√ß√£o que gera a lista numerada.

##

**Prompt**

::: {.r-fit-text .nonincremental}
```python
import pyperclip

def gerar_lista_numerada():
    """"
    A √°rea de transfer√™cia tem linhas de texto contendo
    palavras separadas por espa√ßos e/ou v√≠rgulas.

    A fun√ß√£o extrai as palavras obtidas da √°rea de transfer√™ncia,
    ordena-as em ordem alfab√©tica e cria uma lista numerada com
    um item por linha.

    O resultado √© copiado de volta para a √°rea de transfer√™ncia.    
    """
```
:::

##

C√≥digo gerado pelo Copilot.

::: {.r-fit-text .nonincremental}
```python
def gerar_lista_numerada():
    """"
    A √°rea de transfer√™cia tem linhas de texto contendo
    palavras separadas por espa√ßos e/ou v√≠rgulas.

    A fun√ß√£o extrai as palavras obtidas da √°rea de transfer√™ncia,
    ordena-as em ordem alfab√©tica e cria uma lista numerada com
    um item por linha.

    O resultado √© copiado de volta para a √°rea de transfer√™ncia.    
    """
    # Obt√©m o texto da √°rea de transfer√™ncia
    texto = pyperclip.paste()

    # Substitui v√≠rgulas por espa√ßos e divide o texto em palavras
    palavras = texto.replace(',', ' ').split()

    # Remove duplicatas e ordena as palavras em ordem alfab√©tica
    palavras_unicas = sorted(set(palavras))

    # Cria a lista numerada
    lista_numerada = [f"{i + 1}. {palavra}" for i, palavra in enumerate(palavras_unicas)]

    # Junta a lista em uma √∫nica string com quebras de linha
    resultado = '\n'.join(lista_numerada)

    # Copia o resultado de volta para a √°rea de transfer√™ncia
    pyperclip.copy(resultado)

if __name__ == "__main__":
    gerar_lista_numerada()
```
:::

##

:::{.callout-tip}
Como n√≥s criamos o ambiente virtual pelo terminal do VS Code, precisamos conferir se o
VS Code identificou automaticamente o ambiente virtual, caso contr√°rio, se tentarmos usar 
a op√ß√£o `Run`, o programa n√£o vai funcionar (pois n√£o conseguir√° importar o m√≥dulo `pyperclip`).

Precisamos escolher a vers√£o do Python que est√° dentro do ambiente virtual.
Basta clicar no canto inferior direito do VS Code e escolher o Python correto.

Obs.: se criarmos o ambiente virtual pelo VS Code (`Ctrl+Shift+P` e escolhendo 
`Python: Create Environment`), o VS Code j√° escolhe o Python correto.
:::

##

Vamos ent√£o testar o nosso programa.

. . .

Suponha que tenhamos recebido a seguinte lista de compras:

- feij√£o, arroz, sorvete, caf√©, batata, √≥leo, cebola

. . .

Copie a lista acima (Ctrl+c) e rode o programa.

- Em seguida cole (Ctrl+v) a lista numerada em algum editor de texto.

##

Veja que deu quase tudo certo.

- Exceto que a palavra `√≥leo` apareceu fora da ordem alfab√©tica.

. . .

```{.text code-line-numbers="false"}
1. arroz
2. batata
3. caf√©
4. cebola
5. feij√£o
6. sorvete
7. √≥leo
```


## 

Provavelmente o erro aconteceu porque a palavra tem acento.

- Vamos pedir ao Copilot para corrigir isso.

. . .


::: {.callout-caution title="Prompt" icon="false"}
A ordena√ß√£o est√° errada, pois a palavra "√≥leo" deveria aparecer antes de "sorvete". Pode corrigir isso?
:::

##

::: {.callout-note title="GitHub Copilot _(in√≠cio)_" icon="false" .nonincremental}
 Claro! O problema ocorre porque a ordena√ß√£o padr√£o do Python (`sorted`) n√£o considera corretamente os acentos para a ordem alfab√©tica em portugu√™s. Para corrigir, voc√™ pode usar o m√≥dulo `locale` e configurar para `'pt_BR.UTF-8'`. Veja como ajustar:

````python
import pyperclip
import locale

def gerar_lista_numerada():
    """
    A √°rea de transfer√™cia tem linhas de texto contendo
    palavras separadas por espa√ßos e/ou v√≠rgulas.

    A fun√ß√£o extrai as palavras obtidas da √°rea de transfer√™ncia,
    ordena-as em ordem alfab√©tica e cria uma lista numerada com
    um item por linha.

    O resultado √© copiado de volta para a √°rea de transfer√™ncia.    
    """
    # Configura a ordena√ß√£o para o padr√£o do portugu√™s do Brasil
    locale.setlocale(locale.LC_COLLATE, 'pt_BR.UTF-8')

    # Obt√©m o texto da √°rea de transfer√™ncia
    texto = pyperclip.paste()

    # Substitui v√≠rgulas por espa√ßos e divide o texto em palavras
    palavras = texto.replace(',', ' ').split()

    # Remove duplicatas e ordena as palavras em ordem alfab√©tica considerando acentos
    palavras_unicas = sorted(set(palavras), key=locale.strxfrm)

    # Cria a lista numerada
    lista_numerada = [f"{i + 1}. {palavra}" for i, palavra in enumerate(palavras_unicas)]

    # Junta a lista em uma √∫nica string com quebras de linha
    resultado = '\n'.join(lista_numerada)

    # Copia o resultado de volta para a √°rea de transfer√™ncia
    pyperclip.copy(resultado)

if __name__ == "__main__":
    gerar_lista_numerada()
````
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

Agora, palavras acentuadas ser√£o ordenadas corretamente conforme o portugu√™s.  

**Obs:** Certifique-se de que o locale `pt_BR.UTF-8` est√° instalado no seu sistema Linux. Se n√£o estiver, instale com:

```bash
sudo locale-gen pt_BR.UTF-8
sudo update-locale
```
:::

##

Agora sim!

- Temos uma ferramenta que nos economiza tempo pegar gerar a lista no formato correto.
- Claro que esse √© um exemplo simples e did√°tico.
  - Seguindo a mesma ideia voc√™ pode criar ferramentas para tarefas mais complexas.

##

Mas tem algo que ainda √© complicado em nossa ferramenta.

- Precisamos usar o VS Code para rodar o programa.
- Ou ent√£o abrir o terminal, navegar at√© a pasta do projeto, ativar o ambiente virtual e rodar o programa.
- Isso n√£o √© muito pr√°tico.

. . .

Seria melhor se pud√©ssemos simplesmente clicar duas vezes em um √≠cone na √°rea de trabalho.

- E a√≠ a ferramenta rodaria sem precisar abrir o VS Code ou o terminal.

##

Vamos conversar com o Copilot para descobrir como fazer isso.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Eu gostaria que esse programa estivesse dispon√≠vel para o usu√°rio como um comando de terminal. Sem precisar entrar na pasta do projeto, ativer o ambiente virtual e rodar o programa manualmente. Como posso fazer isso?
:::

##

::: {.callout-note title="GitHub Copilot _(in√≠cio)_" icon="false" .nonincremental}
Para tornar seu programa dispon√≠vel como um comando de terminal, voc√™ pode empacot√°-lo 
como um **script execut√°vel** e instal√°-lo no sistema. 
 
O jeito mais comum em projetos Python √© criar um **entry point** usando o `setuptools`. Veja como fazer:

**1. Crie um arquivo `setup.py` na raiz do projeto:**

````python
from setuptools import setup

setup(
    name="gerador-lista-numerada",
    version="1.0",
    py_modules=["gerador_lista_numerada"],
    install_requires=["pyperclip"],
    entry_points={
        "console_scripts": [
            "gerador-lista-numerada=gerador_lista_numerada:gerar_lista_numerada",
        ],
    },
)
````
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

**2. Instale o pacote no modo edit√°vel (para desenvolvimento):**

No terminal, dentro da pasta do projeto:

```bash
pip install --user --editable .
```

**3. Use o comando no terminal**

Agora, voc√™ pode rodar o comando de qualquer lugar:

```bash
gerador-lista-numerada
```

---

**Dicas:**

- O comando ser√° instalado em `~/.local/bin` (Linux). Certifique-se de que esse diret√≥rio est√° no seu `$PATH`.
- Para outros usu√°rios do sistema, use `sudo pip install .` (n√£o recomendado para ambientes compartilhados).
- Se quiser distribuir, pode empacotar e publicar no PyPI.

Se quiser um nome de comando diferente, basta alterar em `console_scripts`.
:::

##

Legal! Agora podemos abrir um terminal, rodar o comando `gerador-lista-numerada` e pronto!

- Teremos nossa lista de compras numerada na √Årea de Transfer√™ncia.

## No entanto...

. . .

Bom, sistemas em produ√ß√£o s√£o sempre mais complicados.

- O c√≥digo que apresentei at√© aqui funcionou no meu computador.
- Mas ao testar no notebook para preparar a aula, tive que fazer alguns ajustes.
  - Porque nele, a vers√£o do Ubuntu e do Python s√£o mais recentes.
- E, claro, o Copilot me ajudou a fazer as altera√ß√µes necess√°rias.

##

O problema √© que nas vers√µes mais recentes do Python, o comando abaixo n√£o √© permitido:

```bash
pip install --user --editable .
```

. . .

Isso para proteger a integridade do sistema, evitando instala√ß√£o de pacotes sem usar um ambiente virtual.

- Mas, para o nosso caso, queremos mesmo instalar o pacote para o usu√°rio.
- E, assim, termos o comando dispon√≠vel globalmente.

##

Perguntando ent√£o ao Copilot, precisei instalar com o comando abaixo:

```bash
pip install --user --break-system-packages .
```

. . .

E tamb√©m precisei rodar os comandos abaixo para garantir que o diret√≥rio `~/.local/bin` estivesse no meu `$PATH`.

```bash
echo 'export PATH=$PATH:~/.local/bin' >> ~/.bashrc
source ~/.bashrc
```

##

Mas ser√° que n√£o podemos fazer algo ainda mais pr√°tico?

- Para um usu√°rio leigo, √© ruim ter que abrir um terminal e saber o nome do comando.

. . . 

Bora, conversar com o Copilot novamente.

::: {.callout-caution title="Prompt" icon="false"}
E como fa√ßo para ter um √≠cone na √°rea de trabalho para executar o programa?
:::

##

::: {.callout-note title="GitHub Copilot _(in√≠cio)_" icon="false" .nonincremental}
 Para criar um atalho com √≠cone na √°rea de trabalho (no Linux), siga estes passos:

**1. Crie um arquivo `.desktop`**

Crie um arquivo chamado, por exemplo, `GeradorListaNumerada.desktop` na sua √°rea de trabalho (`~/√Årea de Trabalho` ou `~/Desktop`):

````ini
[Desktop Entry]
Version=1.0
Type=Application
Name=Gerador Lista Numerada
Comment=Gera uma lista numerada a partir da √°rea de transfer√™ncia
Exec=gerador-lista-numerada
Icon=/caminho/para/um/icone.png
Terminal=false
Categories=Utility;
````

- **Exec**: o comando instalado pelo seu script (`gerador-lista-numerada`).
- **Icon**: caminho para um arquivo de √≠cone (PNG, SVG, etc). Voc√™ pode usar um √≠cone pr√≥prio ou algum do sistema.
- **Terminal**: coloque `true` se quiser que abra um terminal, ou `false` para rodar em segundo plano.
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

**2. Torne o atalho execut√°vel**

No terminal, rode:

```bash
chmod +x ~/√Årea\ de\ Trabalho/GeradorListaNumerada.desktop
```

**3. (Opcional) Escolha um √≠cone**

Se n√£o tiver um √≠cone, pode baixar um PNG ou usar algum j√° presente no sistema, como `/usr/share/icons/hicolor/48x48/apps/accessories-text-editor.png`.

---

Agora, basta clicar duas vezes no √≠cone para executar o programa!  
Se aparecer um aviso de seguran√ßa, clique em "Confiar" ou "Permitir execu√ß√£o".
:::

##

Aqui tive que fazer outra adapta√ß√£o para rodar no notebook.

- Referente ao caminho do execut√°vel que precisa ser completo no Ubuntu mais recente.

. . . 

No final das contas utilizei esse arquivo `GeradorListaNumerada.desktop`:

```ini
[Desktop Entry]
Version=1.0
Type=Application
Name=Gerador Lista Numerada
Comment=Gera uma lista numerada a partir da √°rea de transfer√™ncia
Exec=/home/julio/.local/bin/gerador-lista-numerada
Icon=/home/julio/√Årea de trabalho/icone.png
Terminal=false
Categories=Utility;
```

##

Bacana! Temos agora um programa dispon√≠vel na √°rea de trabalho.

- Ficou muito mais r√°pido gerar a lista numerada.

. . .

Poder√≠amos melhorar nosso programa dando algum retorno de que ele foi executado com sucesso.

- E, claro, para criar o atalho na √Årea de Trabalho do Windows o processo seria diferente.

##

Poder√≠amos tamb√©m pensar em outros exemplos de programas com abordagem parecida:

- Copiar duas colunas de uma planilha contendo e-mail e nota dos alunos e gerar texto
  para um e-mail para a secretaria informando o n√∫mero de aprovados e reprovados.
- Copiar trechos do arquivo PDF da Resolu√ß√£o CEPE 473 e acertar as quebras de linha.

. . .

Mas vamos tratar outra demanda tediosa agora.

# Exemplo 2: Adicionando capas a arquivos PDF {background-color="#40666e"}

##

Vamos voltar ao cen√°rio comentado no in√≠cio da aula.

- Suponha que temos 100 arquivos PDF, cada um com um relat√≥rio diferente.
- E que precisamos adicionar uma capa personalizada a cada um desses arquivos.

. . .

Primeiramente, vale ressaltar que n√£o √© poss√≠vel ler arquivos PDF da mesma forma que lemos arquivos texto e CSV.

- Arquivos PDF, do Word, Excel, etc., possuem uma estrutura interna diferente.

##

O arquivo [AulaT6-ex2.zip](dados/AulaT6-ex2.zip) cont√©m duas pastas:

- `capas`: com as 100 capas individuais em PDF.
- `relatorios`: com os 100 relat√≥rios individuais tamb√©m em PDF.

. . .

Poder√≠amos usar algum software, como o Adobe Acrobat, para fazer isso manualmente.

- Mas imagina a trabalheira que daria.
- Em vez disso, vamos pedir ao Copilot para criar uma ferramenta que fa√ßa isso para n√≥s.

##

Antes de pedirmos o Copilot para criar a ferramenta completa, 

- vamos explorar como podemos lidar com a jun√ß√£o (_merge_) de arquivos PDF em Python.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Eu gostaria de escrever um programa em Python que junte dois arquivos PDF em um s√≥. Como posso fazer isso?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
 Voc√™ pode usar a biblioteca `PyPDF2` para juntar dois arquivos PDF em Python. Veja um exemplo simples:

1. Instale a biblioteca (caso ainda n√£o tenha):
```bash
pip install PyPDF2
```

2. C√≥digo para juntar dois PDFs:

````python
from PyPDF2 import PdfMerger

# Lista dos arquivos PDF a serem unidos
arquivos = ['arquivo1.pdf', 'arquivo2.pdf']

merger = PdfMerger()
for pdf in arquivos:
    merger.append(pdf)
merger.write('pdf_unido.pdf')
merger.close()
````

Basta substituir `'arquivo1.pdf'` e `'arquivo2.pdf'` pelos nomes dos seus arquivos. O resultado ser√° salvo como `pdf_unido.pdf`.
:::

##

J√° temos ent√£o uma op√ß√£o que parece atender o que precisamos.

- Mas vamos explorar se existe alguma op√ß√£o com m√≥dulo _built-in_.

. . .


::: {.callout-caution title="Prompt" icon="false"}
Existe alguma forma de fazer isso sem precisar instalar um m√≥dulo Python?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
 N√£o existe uma forma nativa em Python puro para manipular ou juntar arquivos PDF, pois o formato PDF √© complexo e n√£o √© suportado pela biblioteca padr√£o do Python. 

Se voc√™ n√£o quiser instalar m√≥dulos Python, pode usar ferramentas externas j√° instaladas no Linux, como o `pdftk` ou o `qpdf`. Por exemplo, usando o terminal:

**Com `pdftk`:**
```bash
pdftk arquivo1.pdf arquivo2.pdf cat output pdf_unido.pdf
```

**Com `qpdf`:**
```bash
qpdf --empty --pages arquivo1.pdf arquivo2.pdf -- pdf_unido.pdf
```

Essas ferramentas precisam estar instaladas no seu sistema, mas n√£o exigem instalar m√≥dulos Python. Se preferir uma solu√ß√£o 100% Python, ser√° necess√°rio instalar um m√≥dulo como o `PyPDF2`.
:::

##

Bom, a solu√ß√£o apresentada depende da instala√ß√£o de programas externos, o que parece mais complicado do que instalar um m√≥dulo Python.

- Obs.: no livro, o Copilot sugeriu criar um script Python que no final das contas usava esses programas.

. . .

A primeira op√ß√£o parece boa, mas vamos explorar se existem alternativas.

. . . 


::: {.callout-caution title="Prompt" icon="false"}
Existem outros m√≥dulos Python que eu deveria considerar para tratar essa tarefa?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
Sim! Al√©m do **PyPDF2**, voc√™ pode considerar outros m√≥dulos Python para manipula√ß√£o de PDFs:

- **pypdf**: √â uma continua√ß√£o moderna do PyPDF2, com mais recursos e manuten√ß√£o ativa.
- **PyMuPDF (fitz)**: Muito r√°pido e poderoso, permite manipular, mesclar, dividir e at√© extrair texto e imagens de PDFs.
- **pdfminer.six**: Focado em extra√ß√£o de texto, mas tamb√©m pode manipular PDFs em alguns casos.
- **pdfrw**: Permite ler e escrever PDFs, al√©m de mesclar e dividir arquivos.

Para tarefas simples de juntar PDFs, **pypdf** e **PyMuPDF** s√£o √≥timas op√ß√µes. Exemplo com pypdf:

````python
from pypdf import PdfMerger

merger = PdfMerger()
merger.append("arquivo1.pdf")
merger.append("arquivo2.pdf")
merger.write("pdf_unido.pdf")
merger.close()
````

Escolha o m√≥dulo conforme suas necessidades e prefer√™ncias!
:::

##

A resposta do Copilot nos mostrou que existe um m√≥dulo mais moderno que o `PyPDF2`, o `pypdf`.

- E cujo exemplo de c√≥digo parece bem simples.

. . . 

Mas antes de seguirmos com o `pypdf`, vamos entender melhor os pr√≥s e contras de cada m√≥dulo sugerido.

. . .


::: {.callout-caution title="Prompt" icon="false"}
Quais s√£o os pr√≥s e contras de cada um desses m√≥dulos?
:::

##

::: {.callout-note title="GitHub Copilot _(in√≠cio)_" icon="false" .nonincremental}
 Aqui est√° um resumo dos pr√≥s e contras dos principais m√≥dulos Python para manipula√ß√£o de PDFs:

---

**1. PyPDF2**

**Pr√≥s:**

- F√°cil de usar para tarefas b√°sicas (juntar, dividir, rotacionar).
- Bastante documentado e com muitos exemplos.
- N√£o depende de bibliotecas externas.

**Contras:**

- Desenvolvimento desacelerado (pode estar desatualizado).
- Suporte limitado para PDFs complexos ou protegidos.
- Algumas fun√ß√µes avan√ßadas podem n√£o funcionar corretamente.
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

**2. pypdf**

**Pr√≥s:**

- Continua√ß√£o moderna do PyPDF2, com manuten√ß√£o ativa.
- Interface semelhante ao PyPDF2, facilitando a migra√ß√£o.
- Corrige bugs e adiciona novos recursos.
- Boa documenta√ß√£o.

**Contras:**

- Ainda pode ter limita√ß√µes com PDFs muito complexos.
- Algumas fun√ß√µes avan√ßadas podem n√£o estar presentes.
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental} 

**3. PyMuPDF (fitz)**

**Pr√≥s:**

- Muito r√°pido e eficiente.
- Suporte avan√ßado para manipula√ß√£o de p√°ginas, extra√ß√£o de texto, imagens e metadados.
- Suporta PDFs complexos e outros formatos (XPS, EPUB).
- Documenta√ß√£o detalhada.

**Contras:**

- API um pouco mais complexa para tarefas simples.
- Pode ser mais pesado para instalar (depende de bibliotecas C).

:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

**4. pdfrw**

**Pr√≥s:**

- Leve e puro Python.
- Permite mesclar, dividir e modificar PDFs.
- √ötil para manipula√ß√£o de formul√°rios PDF.

**Contras:**

- Menos mantido e atualizado.
- Suporte limitado para PDFs complexos.
- Documenta√ß√£o menos detalhada.
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

**5. pdfminer.six**

**Pr√≥s:**

- Excelente para extra√ß√£o de texto detalhada.
- Suporta PDFs complexos e multil√≠ngues.

**Contras:**

- N√£o √© focado em manipula√ß√£o (juntar/dividir) de PDFs.
- API mais complexa para tarefas simples de manipula√ß√£o.

---

**Resumo:**  

- Para juntar/dividir PDFs: **pypdf** ou **PyMuPDF** s√£o as melhores op√ß√µes.
- Para extra√ß√£o de texto: **pdfminer.six** ou **PyMuPDF**.
- Para manipula√ß√£o leve e sem depend√™ncias: **pdfrw**.

Escolha conforme sua necessidade!
:::

## 

A resposta do Copilot nos ajudou a entender melhor as op√ß√µes.

- O `pypdf` parece ser uma boa escolha, pois √© uma vers√£o mais moderna do `PyPDF2`.
- E o exemplo de c√≥digo que ele nos deu √© bem simples.

. . .

Vamos partir para a cria√ß√£o da ferramenta. 

- Vamos definir a assinatura da fun√ß√£o e a docstring com o que queremos.

##

::: {.callout-tip}
Antes de continuarmos, vale a pena chamar a aten√ß√£o para [cuidados]{.alert} que devemos 
tomar **ao fazer automatiza√ß√µes que lidam com arquivos**.

Se a ferramenta que criarmos estiver incorreta, podemos perder arquivos em nosso computador.
Algumas dicas s√£o:

- Sempre trabalhar com c√≥pias dos arquivos, nunca com os originais.
- Verifique se os arquivos que a ferramenta vai processar est√£o corretos.
  - Ex.: podemos comentar as linhas que manipulam os arquivos e imprimir os nomes dos arquivos que seriam processados.
  - Assim conseguimos conferir se s√£o realmente os arquivos que pretendemos usar.
- Sempre fazer testes com poucos arquivos, antes de rodar a ferramenta com todos os arquivos.
:::

##

Para definirmos a assinatura da fun√ß√£o, veja que precisaremos de tr√™s par√¢metros: 

- as pastas das capas, dos relat√≥rios e de onde queremos colocar os arquivos gerados.

. . .

Tamb√©m precisaremos explicar o padr√£o de nomes dos arquivos.

- Para que o Copilot gera um c√≥digo que junte a capa correta com o relat√≥rio correto.

. . .

E podemos importar a bibliteca `pypdf` que j√° sabemos que vamos usar.

##

Lembre-se tamb√©m que precisamos seguir o mesmo procedimento do exemplo anterior
para criar o ambiente virtual e instalar o m√≥dulo `pypdf`.

. . .

```{.bash code-line-numbers="false"}
python3 -m venv venv
source venv/bin/activate
pip install pypdf
pip freeze > requirements.txt
```

. . .

Lembre-se tamb√©m de configurar o VS Code para usar o Python do ambiente virtual.

##

Vamos ent√£o criar um arquivo Python e definir a assinatura da fun√ß√£o e a docstring.

::: {.r-fit-text .nonincremental}
```python
import pypdf

def adicionar_capas_a_pdfs(pasta_capas, pasta_relatorios, pasta_saida):
    """
    Adiciona capas personalizadas a arquivos PDF de relat√≥rios.

    Par√¢metros:
    - pasta_capas: Caminho da pasta contendo os arquivos PDF das capas.
      Os arquivos t√™m nome cover1.pdf, cover2.pdf, etc.
    - pasta_relatorios: Caminho da pasta contendo os arquivos PDF dos relat√≥rios.
      Os arquivos t√™m nome 1.pdf, 2.pdf, etc.
    - pasta_saida: Caminho da pasta onde os arquivos PDF resultantes ser√£o salvos.

    A fun√ß√£o l√™ cada arquivo de capa e o respectivo relat√≥rio,
    junta os dois em um √∫nico arquivo PDF e salva na pasta de sa√≠da.
    """
```
:::

##

Esse foi o c√≥digo gerado pelo Copilot no meu caso.

::: {.r-fit-text .nonincremental}
```python
import pypdf

def adicionar_capas_a_pdfs(pasta_capas, pasta_relatorios, pasta_saida):
    """
    Adiciona capas personalizadas a arquivos PDF de relat√≥rios.

    Par√¢metros:
    - pasta_capas: Caminho da pasta contendo os arquivos PDF das capas.
      Os arquivos t√™m nome cover1.pdf, cover2.pdf, etc.
    - pasta_relatorios: Caminho da pasta contendo os arquivos PDF dos relat√≥rios.
      Os arquivos t√™m nome 1.pdf, 2.pdf, etc.
    - pasta_saida: Caminho da pasta onde os arquivos PDF resultantes ser√£o salvos.

    A fun√ß√£o l√™ cada arquivo de capa e o respectivo relat√≥rio,
    junta os dois em um √∫nico arquivo PDF e salva na pasta de sa√≠da.
    """
    import os

    # Lista os arquivos de capa e relat√≥rio
    capas = sorted([f for f in os.listdir(pasta_capas) if f.startswith('cover') and f.endswith('.pdf')])
    relatorios = sorted([f for f in os.listdir(pasta_relatorios) if f.endswith('.pdf')])

    # Verifica se o n√∫mero de capas e relat√≥rios √© o mesmo
    if len(capas) != len(relatorios):
        raise ValueError("O n√∫mero de capas e relat√≥rios deve ser o mesmo.")

    for capa, relatorio in zip(capas, relatorios):
        caminho_capa = os.path.join(pasta_capas, capa)
        caminho_relatorio = os.path.join(pasta_relatorios, relatorio)
        caminho_saida = os.path.join(pasta_saida, relatorio)

        # L√™ os arquivos PDF
        leitor_capa = pypdf.PdfReader(caminho_capa)
        leitor_relatorio = pypdf.PdfReader(caminho_relatorio)

        escritor_pdf = pypdf.PdfWriter()

        # Adiciona a capa
        for pagina in leitor_capa.pages:
            escritor_pdf.add_page(pagina)

        # Adiciona o relat√≥rio
        for pagina in leitor_relatorio.pages:
            escritor_pdf.add_page(pagina)

        # Salva o novo arquivo PDF com a capa adicionada
        with open(caminho_saida, 'wb') as arquivo_saida:
            escritor_pdf.write(arquivo_saida)

# Exemplo de uso:
# adicionar_capas_a_pdfs('pasta_capas', 'pasta_relatorios',
#                          'pasta_saida')

if __name__ == "__main__":
    # Exemplo de uso
    adicionar_capas_a_pdfs('pasta_capas', 'pasta_relatorios', 'pasta_saida')
```
:::

##

Vamos agora copiar as pastas de capas e relat√≥rios para dentro do nosso projeto.

- E criar uma pasta `saida` vazia para onde os arquivos gerados ser√£o salvos.
- Precisamos acertar os nomes das pastas no script.

. . .

Exemplo:

```python
if __name__ == "__main__":
    # Exemplo de uso
    adicionar_capas_a_pdfs('capas', 'relatorios', 'saida')
```

##

Hora de testar o programa!

- Confira, por amostragem, pelo menos 3 arquivos gerados para conferir se deu certo.

## Reutilizando a ferramenta

Vamos supor que essa opera√ß√£o fosse necess√°ria mais vezes.

- E que precisasse ser feita por algu√©m que n√£o √© programador.
- Que tal pedirmos o Copilot para gerar uma interface gr√°fica simples para a ferramenta?

. . .


::: {.callout-caution title="Prompt" icon="false"}
Eu gostaria de criar uma interface gr√°fica simples para essa ferramenta. Pode me ajudar?
:::

##

::: {.callout-note title="GitHub Copilot _(in√≠cio)_" icon="false" .nonincremental}
 Claro! Voc√™ pode criar uma interface gr√°fica simples usando o Tkinter, que j√° vem com o Python. Vou sugerir um exemplo b√°sico onde o usu√°rio pode selecionar as tr√™s pastas (capas, relat√≥rios e sa√≠da) e clicar em um bot√£o para executar a fun√ß√£o.

Adicione o seguinte c√≥digo ao final do seu arquivo junta_capas.py:

```python
# ...existing code...

import tkinter as tk
from tkinter import filedialog, messagebox

def selecionar_pasta(entry_widget):
    pasta = filedialog.askdirectory()
    if pasta:
        entry_widget.delete(0, tk.END)
        entry_widget.insert(0, pasta)

def executar():
    pasta_capas = entry_capas.get()
    pasta_relatorios = entry_relatorios.get()
    pasta_saida = entry_saida.get()
    try:
        adicionar_capas_a_pdfs(pasta_capas, pasta_relatorios, pasta_saida)
        messagebox.showinfo("Sucesso", "Arquivos gerados com sucesso!")
    except Exception as e:
        messagebox.showerror("Erro", str(e))
```
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

```python
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Juntar Capas em PDFs")

    tk.Label(root, text="Pasta das Capas:").grid(row=0, column=0, sticky="e")
    entry_capas = tk.Entry(root, width=40)
    entry_capas.grid(row=0, column=1)
    tk.Button(root, text="Selecionar", command=lambda: selecionar_pasta(entry_capas)).grid(row=0, column=2)

    tk.Label(root, text="Pasta dos Relat√≥rios:").grid(row=1, column=0, sticky="e")
    entry_relatorios = tk.Entry(root, width=40)
    entry_relatorios.grid(row=1, column=1)
    tk.Button(root, text="Selecionar", command=lambda: selecionar_pasta(entry_relatorios)).grid(row=1, column=2)

    tk.Label(root, text="Pasta de Sa√≠da:").grid(row=2, column=0, sticky="e")
    entry_saida = tk.Entry(root, width=40)
    entry_saida.grid(row=2, column=1)
    tk.Button(root, text="Selecionar", command=lambda: selecionar_pasta(entry_saida)).grid(row=2, column=2)

    tk.Button(root, text="Executar", command=executar, width=20).grid(row=3, column=0, columnspan=3, pady=10)

    root.mainloop()
# ...existing code...
```
:::

##

::: {.callout-note title="GitHub Copilot _(continua√ß√£o)_" icon="false" .nonincremental}

**Como funciona:**

- O usu√°rio seleciona as tr√™s pastas usando os bot√µes "Selecionar".
- Ao clicar em "Executar", a fun√ß√£o √© chamada e mostra uma mensagem de sucesso ou erro.

Se quiser, pode separar a interface em outro arquivo, mas assim fica tudo em um s√≥. Se precisar de melhorias, √© s√≥ pedir!
:::

##

Com esse c√≥digo, temos uma interface gr√°fica simples, mas bem pr√°tica:

::: {.columns}
::: {.column}
![](imagens/tela_programa_juntar_capas_pdfs.png){fig-align="center" fig-alt="Tela principal do programa para juntar capas em PDFs." style="max-height: 50vh; width: auto;"}
:::
::: {.column}
![](imagens/tela_programa_juntar_capas_pdfs_selecionar.png){fig-align="center" fig-alt="Tela para navegar na estrutura de pastas e selecionar uma pasta." style="max-height: 50vh; width: auto;"}
:::
:::

. . .

Se quis√©ssemos poder√≠amos novamente criar um atalho na √°rea de trabalho para abrir essa interface gr√°fica.


# Fluxo de trabalho para usar m√≥dulos do Python com o Copilot {background-color="#40666e"}

##

Ap√≥s termos feito esses dois exemplos, podemos pensar em um fluxo de trabalho para usar o Copilot
na cria√ß√£o de ferramentas que usem m√≥dulos do Python.

1. Pedir ao Copilot (ou ChatGPT) para listar m√≥dulos do Python que podem ser usados para a tarefa de interesse.
2. Perguntar ao Copilot sobre os pr√≥s e contras de cada m√≥dulo.
3. Escolher o m√≥dulo que parece mais adequado.
4. Se necess√°rio, criar um ambiente virtual e instalar o m√≥dulo.
5. Seguir o Ciclo de Projeto de Fun√ß√µes que vimos anteriormente, incluindo o m√≥dulo escolhido.
6. Se ficarmos travados, tentamos um m√≥dulo diferente.


# Exemplo 3: Interface para Oficina de Programa√ß√£o de Jogos {background-color="#40666e"}

##

N√≥s acabamos de ter o 8¬∫ UFLA de Portas Abertas.

- E, dentro do evento, tivemos a Oficina de Programa√ß√£o de Jogos.

. . .

Nessa oficina, os participantes do evento experimentam, e modificam, jogos 
implementados como trabalho da disciplina IPOO de Sistemas de Informa√ß√£o.

- E um jogo para ensino de Python, desenvolvido como TCC de Ci√™ncia da Computa√ß√£o.

##

No evento do ano anterior t√≠nhamos duas dificuldades:

- Deix√°vamos todos os jogos em todas as m√°quinas, mas abr√≠amos um jogo
  em cada m√°quina alternadamente.
  - A ideia era que os participantes percebessem que havia v√°rios jogos.
- Depois que os participantes alteravam o c√≥digo de um jogo,
  precis√°vamos restaurar o c√≥digo original para a pr√≥xima turma.
- Dava uma trabalheira fazer isso na m√£o.

##

Usei ent√£o o ChatGPT e Copilot para criar uma interface gr√°fica simples

- que funcionasse como uma tela inicial (_launcher_) que mostrasse os jogos dispon√≠veis.
  - Que permitisse iniciar os jogos ao clicar neles.
- E que tamb√©m tivesse um bot√£o para restaurar o c√≥digo original do jogo.
  - Para isso, usei um reposit√≥rio git local para cada jogo.
  - Restaurar o jogo era simplesmente rodar o comando `git restore .` na pasta do jogo.

##

Esse foi meu primeiro prompt para o ChatGPT:

::: {.callout-caution title="Prompt" icon="false"}
Tenho alguns jogos desenvolvidos em Java usando a IDE Greenfoot que gostaria de utilizar em uma demonstra√ß√£o. A ideia √© que a pessoa chegue e jogue os 7 jogos dispon√≠veis no computador. Para jogar cada jogo √© necess√°rio abrir o projeto no Greenfoot e executar. Para facilitar esse processo, gostaria de ter uma esp√©cie de "landing page" que mostrasse uma imagem de cada jogo e que, quando o usu√°rio clicasse na imagem, o Greenfoot fosse aberto com o projeto do jogo em quest√£o. Estou usando Linux Ubuntu e creio que para abrir o Greenfoot bastaria executar uma linha de comando passando o caminho do projeto como par√¢metro. Essa "landing page" pode ser com qualquer tipo de tecnologia que seja f√°cil de fazer (pode ser web rodando local, ou uma aplica√ß√£o Python, enfim, qualquer coisa). Procuro algo simples e r√°pido de fazer ou alterar.
:::

##

O ChatGPT sugeriu tr√™s op√ß√µes, j√° com exemplos de c√≥digo

1. Uma p√°gina HTML que precisaria ser aberta com Electron ou com um servidor Python para conseguir executar scripts locais.
2. Uma aplica√ß√£o Python com interface gr√°fica usando `Tkinter`.
3. Um menu no terminal para a escolha do jogo.

. . .

N√£o entendi porque ele sugeriu a op√ß√£o 3 ü§î

- Mas, enfim, escolhi a op√ß√£o 2, que me pareceu mais pr√°tica.

##

Usei o prompt:

::: {.callout-caution title="Prompt" icon="false"}
Gostei da op√ß√£o 2. Mas gostaria que a aplica√ß√£o fosse aberta maximizada e que as imagens dos jogos ficasse todas do mesmo tamanho em um grid com 2 linhas e 4 colunas
:::

. . .

N√£o vou colocar todos os prompts aqui, n√£o fiz de forma muito estruturada.

- De um certo ponto em diante passei para o Copilot.

##

Mas alguns dos passos foram:

- Foram geradas algumas vers√µes de c√≥digo que geravam erro (eu colava o erro no ChatGPT).
- Durante o processo, √†s vezes aparecia s√≥ o primeiro jogo, outra hora o primeiro e o quinto.
- Quando apareceram todos os jogos, a janela deixou de ficar maximizada.
- Depois, pedi para substituir um dos espa√ßos de jogo por uma imagem.
- Pedi que, ao abrir um jogo, a IDE fosse fechada antes (para n√£o deixar v√°rias inst√¢ncias em execu√ß√£o).

##

Mas alguns dos passos foram:

- Acrescentei um dos jogos que era via Godot Engine e n√£o via Greenfoot.
- Acrescentei o bot√£o para restaurar o c√≥digo original dos jogos.

. . .

E esse foi o resultado final...

##

![](imagens/oficina_programacao_jogos.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

##

No dia do evento, ainda tivemos uma surpresa.

- Eu tinha testado o programa em uma m√°quina do laborat√≥rio.
  - E como, em tese, todas as m√°quinas t√™m a mesma imagem, tudo funcionaria.
- Mas ao fazer a instala√ß√£o pela manh√£, vimos que o programa n√£o funcionava em algumas m√°quinas.
  - Por que o m√≥dulo `tkinter` depende de instala√ß√£o no sistema operacional.
- Consegui apoio para fazer a instala√ß√£o (dependia de senha de administrador).

##

Mas enquanto estava tentando isso, usei o ChatGPT e ele informou que uma alternativa seria usar o `pygame`.

- Pois √© um m√≥dulo Python que n√£o depende de instala√ß√£o no sistema operacional.

. . .

Pretendo fazer isso no pr√≥ximo ano üòâ

# Exemplo 4: Juntando fotos de v√°rios celulares {background-color="#40666e"}

##

Imagine que queremos juntar fotos dos nossos celulares e de nossos familiares.

- A ideia √© ter tudo acess√≠vel em um √∫nico lugar.
- Para que todos possam ter acesso a todas as fotos.
- Mas, provavelmente, existem fotos repetidas, que uma pessoa mandou para outra.
  - e n√£o queremos ter fotos repetidas no nosso acervo.

. . .

Vamos ent√£o criar uma ferramenta que fa√ßa isso para n√≥s.



##

Para testar, vamos usar o arquivo [AulaT6-ex4.zip](dados/AulaT6-ex4.zip) que cont√©m v√°rias figuras em PNG.

- Existem duas subpastas, `figuras1` e `figuras2`, cada uma com v√°rias figuras.
- N√£o s√£o fotos reais, mas servem para testar a ferramenta.

##

A pasta `figuras1` tem 98 figuras e a pasta `figuras2` tem 112.

- No total s√£o ent√£o 210 figuras, mas 10 s√£o repetidas.
  - Por ex.: a figura 1566.png da pasta `figuras1` √© id√™ntica √† figura 2471.png da pasta `figuras2`.
- Portanto, se nossa ferramenta funcionar corretamente, no final teremos 200 figuras.
- Al√©m disso, devemos tomar cuidado pois podem existir fotos diferentes nas duas pastas mas com o mesmo nome.
  - Por ex.: a figura 9595.png da pasta `figuras1` √© diferente da figura 9595.png da pasta `figuras2`.
  - Nesse caso n√≥s n√£o queremos perder nenhuma das duas, e precisaremos renomear uma delas.

##

Para esse exemplo, n√£o vou colocar aqui nos slides o passo a passo completo.

- Vou colocar os prompts usados no livro, mas sem apresentar os resutados do Copilot.
- Repita os passos no seu computador e teste com o arquivo mencionado.

. . .

[Aten√ß√£o]{.alert}: ao fazer no meu computador eu descobri que precisei fazer uma 
engenharia de Prompt e tamb√©m vi que o c√≥digo gerado perdia dois arquivos!

- Portanto, √© importante testar o c√≥digo gerado at√© que ele esteja correto.

## 

::: {.callout-caution title="Prompt" icon="false"}
Eu preciso escrever um programa em Python que copia arquivos. Como posso fazer isso?
:::

- A ideia de copiar arquivos em vez de mov√™-los √© para evitar perda de dados.

. . .

::: {.callout-caution title="Prompt" icon="false"}
O m√≥dulo `shutil` precisa ser instalado?
:::

##

::: {.callout-caution title="Prompt" icon="false"}
Como eu posso descobrir se dois arquivos PNG s√£o id√™nticos usando Python?
:::

. . .

::: {.callout-caution title="Prompt" icon="false"}
E se eu tiver centenas de arquivos PNG e quiser encontrar arquivos duplicados?
Essa abordagem ainda funciona?
:::

. . .

::: {.callout-caution title="Prompt" icon="false"}
Como eu posso descobrir se dois arquivos PNG s√£o id√™nticos usando Python?
:::

##

A partir da√≠ os autores livro usam [decomposi√ß√£o de problemas]{.alert} para criar a ferramenta.

- A ideia √© criar uma ferramenta mais gen√©rica de forma que possa ser usada em mais situa√ß√µes.
- Por exemplo, ela poderia receber v√°rias pastas de figuras e n√£o apenas duas.
- E poderia copiar as fotos para uma pasta de destino,
  - sempre verificando se a foto j√° existe l√° (para evitar duplicatas).

##

Os autores, usando **_design top-down_**, definem ent√£o as fun√ß√µes abaixo. 

1. Fazer c√≥pias de v√°rios arquivos em uma pasta de destino, apenas se ele n√£o for duplicado.
2. Fazer c√≥pia de um arquivo em uma pasta de destino, apenas se ele n√£o for duplicado.
3. Obter um bom nome para o arquivo copiado (para evitar perda de dados com conflito de nomes).

##

Essas s√£o as assinaturas e docstrings das fun√ß√µes usadas no livro.

- Como j√° vimos antes, na hora de implementar seguimos o caminho _bottom-up_.
- Portanto, ser√° apresentada primeira a 3¬™ fun√ß√£o, depois a 2¬™ e por fim a 1¬™.

##

```python
def obter_bom_nome_arquivo(nome_arquivo):
    """
    nome_arquivo √© o nome de um arquivo PNG.

    Enquanto o arquivo caminho_arquivo existir, acrescenta
    um caractere _ logo antes do .png e retorna o novo nome.
    Ex.: 9595.png se torna 9595_.png.

    Retorna o nome resultante do arquivo.
    """
```

##

```python
def fazer_copia(nome_arquivo, pasta_destino):
    """
    nome_arquivo √© um nome de arquivo, como figuras1/1262.png.
    pasta_destino √© o nome de uma pasta.

    Compara o conte√∫do do arquivo apontado por nome_arquivo com 
    todos os arquivos na pasta_destino (n√£o importa o nome do arquivo).
    Se o arquivo n√£o for id√™ntico a nenhum arquivo na pasta_destino,
    faz uma c√≥pia do arquivo na pasta_destino.
    """
```

##

```python
def fazer_varias_copias(pastas, pasta_destino):
    """
    pastas √© uma lista de nomes de pastas.
    pasta_destino √© o nome de uma pasta.

    Verifica cada arquivo nas pastas da lista pastas
    e compara com todos os arquivos em pasta_destino.
    Se um arquivo n√£o for id√™ntico a nenhum arquivo em pasta_destino,
    faz uma c√≥pia do arquivo em pasta_destino.
    """
```

##

Como eu tinha mencionado, o c√≥digo gerado inicialmente pelo Copilot n√£o estava correto.

. . .

Primeiramente tive que mudar o prompt da fun√ß√£o `fazer_copia`.

- Pois, traduzindo diretamente o prompt do livro, a fun√ß√£o estava olhando apenas os
  nomes dos arquivos e n√£o o conte√∫do.

##

Depois, ao usar o programa, vi que estavam sendo gerados 198 arquivos em vez de 200.

- Os arquivos abaixo, por exemplo, estavam sendo identificados como id√™nticos pelo programa
    e um deles estava sendo perdido.

. . .

::: {.columns}
::: {.column}
![](imagens/3531.png){fig-align="center" fig-alt="Arquivo 3531.png da pasta figuras1." style="max-height: 30vh; width: auto;"}
:::
::: {.column}
![](imagens/8512.png){fig-align="center" fig-alt="Arquivo 8512.png da pasta figuras2." style="max-height: 30vh; width: auto;"}
:::
:::

##

E o pior: ao comparar o c√≥digo gerado com o do livro, a compara√ß√£o usava a mesma fun√ß√£o `filecmp.cmp`.

- Como ent√£o funcionava no livro, mas n√£o no meu computador?

. . .

Era de hora de usar ferramentas de [debugging]{.alert}.


- A primeira coisa que fiz foi imprimir os nomes dos arquivos que estavam sendo considerados id√™nticos.
- Como eu sabia que deveriam ser 10 arquivos id√™nticos e estavam aparecendo 12, n√£o seria t√£o complicado conferir manualmente.
- E o primeiro par j√° foi esse que mostrei.

##

Perguntei ent√£o ao Copilot sobre como funciona a fun√ß√£o `filecmp.cmp`, usada no c√≥digo gerado pelo Copilot para 
comparar os arquivos.

- E, na explica√ß√£o, descobri que a fun√ß√£o tem um par√¢metro `shallow` que por padr√£o √© `True`.
  - Obs.: em Python, par√¢metros com valores padr√µes n√£o precisam ser passados na chamada da fun√ß√£o.
- Com o valor padr√£o, a fun√ß√£o n√£o compara o conte√∫do dos arquivos, mas sim seus metadadados (tipo, tamanho e data de modifica√ß√£o).
  - E as imagens que mostrei, por coincid√™ncia, tinham o mesmo tamanho, tipo e data de modifica√ß√£o.

##

Alterei ent√£o o c√≥digo passando `shallow=False` como argumento da fun√ß√£o e o problema foi resolvido.

- Foram gerados os 200 arquivos esperados.

. . .

Mas por que ent√£o o c√≥digo do livro funcionava?

- A quest√£o √© que eu estava usando Ubuntu e os autores do livro estavam usando Windows.
- E a data de modifica√ß√£o dos arquivos tem precis√£o diferente nos dois sistemas operacionais.
- Enviei entao uma _errata_ para os autores do livro.

##

Aproveito esse epis√≥dio para refor√ßar alguns pontos:

- **Cuidado** com automatiza√ß√µes que podem levar a perda de dados.
- Fa√ßa **testes**.
- Trabalhe com **c√≥pias** dos dados originais.