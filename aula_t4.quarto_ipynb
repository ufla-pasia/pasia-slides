{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Decomposi√ß√£o de Problemas\n",
        "subtitle: PASIA - Aula T.4\n",
        "---\n",
        "\n",
        "##  \n",
        "\n",
        "O conte√∫do dessa aula √© inspirado no **cap√≠tulos 7** do livro abaixo.\n",
        "\n",
        "![](imagens/livro_potter_zingaro.png){fig-align=\"center\" fig-alt=\"Capa do livro de Potter e Zingaro.\" style=\"max-height: 50vh; width: auto;\"}\n",
        "\n",
        "# Introdu√ß√£o {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "J√° comentamos em aulas anteriores que n√£o devemos pedir ao Copilot para resolver \n",
        "um problema muito grande de uma vez s√≥.\n",
        "\n",
        "- Como: _Crie um jogo de estrat√©gia multiplayer desafiador e divertido_.\n",
        "\n",
        ". . .\n",
        "\n",
        "No pior caso, o Copilot n√£o vai gerar nada √∫til.\n",
        "\n",
        "- H√° casos em que ele s√≥ fica gerando coment√°rios em sequ√™ncia.\n",
        "\n",
        "##\n",
        "\n",
        "E, na melhor das hip√≥teses, voc√™ teria um jogo _\"enlatado\"_ que n√£o √© muito divertido ou desafiador.\n",
        "\n",
        "- Parte do poder de ser um programador √© conseguir customizar o que voc√™ cria.\n",
        "\n",
        ". . .\n",
        "\n",
        "Al√©m disso, imagina a dificuldade que seria corrigir todos os erros de um jogo inteiro gerado de uma vez.\n",
        "\n",
        ". . .\n",
        "\n",
        "N√≥s precisamos pedir ao Copilot para resolver pequenos problemas pra gente.\n",
        "\n",
        "- E n√≥s mesmos vamos juntando esses peda√ßos em nossos programas.\n",
        "\n",
        "##\n",
        "\n",
        "O objetivo dessa aula √© aprender a quebrar um problema grande em subproblemas menores.\n",
        "\n",
        "- De forma que consigamos resolver grandes problemas usando programa√ß√£o.\n",
        "\n",
        "# Decomposi√ß√£o de Problemas {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "[Decomposi√ß√£o de problemas]{.alert} envolve come√ßar com um problema grande e que n√£o \n",
        "est√° bem especificado\n",
        "\n",
        "- e **quebr√°-lo em subproblemas**, os quais s√£o **bem definidos** e **√∫teis** para resolver o problema original.\n",
        "\n",
        ". . .\n",
        "\n",
        "Na aula vamos trabalhar com decomposi√ß√£o de fun√ß√µes.\n",
        "\n",
        "- O que faremos portanto √© escrever fun√ß√µes para cada um dos subproblemas que identificamos.\n",
        "\n",
        "##\n",
        "\n",
        "Ao identificarmos um subproblema, pode ser que consigamos resolv√™-lo escrevendo uma fun√ß√£o.\n",
        "\n",
        "- Ou pode se que ele ainda seja muito grande para ser implementado em uma √∫nica fun√ß√£o.\n",
        "- E ent√£o precisaremos quebr√°-lo em sub-subproblemas.\n",
        "  - Esperamos ent√£o que cada sub-suproblema seja pequeno o suficiente.\n",
        "  - Mas se n√£o for, continuamos quebrando em subproblemas sucessivamente.\n",
        "\n",
        "##\n",
        "\n",
        "A principal **raz√£o** para decompormos problemas √© a **complexidade**.\n",
        "\n",
        ". . .\n",
        "\n",
        "Cada fun√ß√£o deve ser simples o suficiente de forma que:\n",
        "\n",
        "- consigamos entender o seu prop√≥sito;\n",
        "- consigamos pedir ao Copilot para implement√°-la;\n",
        "- e, se tiver algum erro, n√£o tenhamos muitas dificuldades em resolv√™-lo.\n",
        "\n",
        "## \n",
        "\n",
        "Quando escrevemos um c√≥digo que √© muito complexo, √© muito mais prov√°vel que cometamos erros.\n",
        "\n",
        "- O mesmo vale para o Copilot.\n",
        "\n",
        ". . .\n",
        "\n",
        "E quando temos erros em c√≥digos grandes e complexos n√£o √© f√°cil encontr√°-los e corrigi-los.\n",
        "\n",
        ". . .\n",
        "\n",
        "_\"√â dif√≠cil exagerar a import√¢ncia da decomposi√ß√£o de problemas para a qualidade de c√≥digo\"_\n",
        "\n",
        "##\n",
        "\n",
        "No contexto da **Engenharia de Software** n√≥s chamamos a decomposi√ß√£o de problemas de\n",
        "[design top-down]{.alert} (abordagem de cima pra baixo).\n",
        "\n",
        "- Tem esse nome porque come√ßamos com uma tarefa grande que precisamos completar e a\n",
        "  dividimos em tarefas menores.\n",
        "- Durante o _design top-down_, n√≥s criamos a \"casca\" das fun√ß√µes que precisamos implementar.\n",
        "- Depois que terminamos o _design_, podemos implementar o c√≥digo das fun√ß√µes definidas.\n",
        "\n",
        "##\n",
        "\n",
        "N√≥s geralmente acabamos tendo:\n",
        "\n",
        "- uma fun√ß√£o para o problema completo\n",
        "- que chama as fun√ß√µes que implementam os subproblemas.\n",
        "- E cada fun√ß√£o de subproblema pode chamar fun√ß√µes de subsubproblemas.\n",
        "- E assim sucessivamente.\n",
        "\n",
        ". . .\n",
        "\n",
        "Nesse processo, procuramos definir fun√ß√µes que recebem poucos par√¢metros e que\n",
        "retornam poucas informa√ß√µes, mas √∫teis.\n",
        "\n",
        "- O que ajuda muito a melhorar a facilidade de entendimento do c√≥digo.\n",
        "\n",
        "# Pequenos exemplos de _design top-down_ {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Nas aulas anteriores j√° utilizamos alguns exemplos, ainda que simples, que poderiam ter sido tratados com _design top-down_.\n",
        "\n",
        ". . .\n",
        "\n",
        "N√≥s criamos, por exemplo, a fun√ß√£o `obter_senha_forte`\n",
        "\n",
        "- que fica pedindo um usu√°rio para digitar uma senha at√© que ele digite uma senha forte.\n",
        "\n",
        ". . .\n",
        "\n",
        "Seguindo o _design top-down_ poder√≠amos identificar uma subtarefa dessa tarefa.\n",
        "\n",
        "- Que √© verificar se uma senha √© forte.\n",
        "- O que √© justamente o que a fun√ß√£o `eh_senha_forte` faz.\n",
        "\n",
        "##\n",
        "\n",
        "Podemos representar o _design top down_ como mostrado abaixo.\n",
        "\n",
        "```{mermaid fontSize:25}\n",
        "flowchart TD\n",
        "  A(obter_senha_forte) --> B(eh_senha_forte)\n",
        "```\n",
        "\n",
        "## \n",
        "\n",
        "N√≥s tamb√©m trabalhamos com uma fun√ß√£o `melhor_palavra` que recebe uma\n",
        "lista de palavras e retorna aquela que faz mais pontos no jogo _Scrabble_.\n",
        "\n",
        "- Se tiv√©ssemos criando a fun√ß√£o usando _design top-down_, poder√≠amos \n",
        "identificar uma subtarefa que √© calcular a pontua√ß√£o de uma palavra.\n",
        "\n",
        ". . .\n",
        "\n",
        "Ter√≠amos ent√£o o seguinte _design top-down_:\n",
        "\n",
        "```{mermaid fontSize:25}\n",
        "flowchart TD\n",
        "  A(melhor_palavra) --> B(numero_de_pontos)\n",
        "```\n",
        "\n",
        "##\n",
        "\n",
        "Quando n√≥s criamos essas fun√ß√µes na aula passada, n√≥s n√£o usamos _design top-down_.\n",
        "\n",
        "- N√≥s come√ßamos da subtarefa (fun√ß√£o folha) e depois criamos a fun√ß√£o que resolve o problema maior.\n",
        "\n",
        ". . .\n",
        "\n",
        "Agora, para implementar o c√≥digo das fun√ß√µes, n√≥s continuaremos a fazer dessa forma.\n",
        "\n",
        "- Mas antes disso, vamos projetar quais s√£o as fun√ß√µes necess√°rias usando _design top-down_.\n",
        "\n",
        "##\n",
        "\n",
        "√â importante ressaltar que, para esses exemplos pequenos, pode parecer que n√£o faria\n",
        "muita diferen√ßa usar ou n√£o _design top-down_.\n",
        "\n",
        "- Ou at√© mesmo pode parecer desnecess√°rio implementar mais de uma fun√ß√£o.\n",
        "\n",
        ". . .\n",
        "\n",
        "Mas, para problemas maiores, a decomposi√ß√£o de problemas √© a √∫nica forma de manter\n",
        "a complexidade sob controle.\n",
        "\n",
        "- O nosso objetivo aqui √© adquirir a [habilidade]{.alert} de quebrar um problema em problemas menores.\n",
        "\n",
        "# Sugest√µes de Corre√ß√£o Ortogr√°fica {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Vamos agora resolver um problema usando _design top-down_ desde o in√≠cio.\n",
        "\n",
        "- Ao longo da disciplina, n√≥s vamos continuar abordando essa estrat√©gia.\n",
        "- De forma que voc√™ consiga aplic√°-la com susesso por conta pr√≥pria.\n",
        "\n",
        ". . .\n",
        "\n",
        "Ops.. tem um erro na frase anterior.\n",
        "\n",
        "- O correto √© _sucesso_ e n√£o _susesso_.\n",
        "\n",
        "##\n",
        "\n",
        "√â comum que erros de digita√ß√£o ocorram ou que tenhamos d√∫vidas sobre a ortografia de uma palavra.\n",
        "\n",
        "- Ex.: exce√ß√£o ou exces√£o ou excess√£o?\n",
        "\n",
        ". . .\n",
        "\n",
        "O que n√≥s vamos fazer √© pegar uma palavra que pode estar escrita errada\n",
        "\n",
        "- e oferecer sugest√µes de poss√≠veis corre√ß√µes para ela.\n",
        "\n",
        ". . .\n",
        "\n",
        "Ser√° um corretor ortogr√°fico b√°sico para palavras individuais.\n",
        "\n",
        "##\n",
        "\n",
        "N√≥s vamos tratar tr√™s tipos de erro de ortografia:\n",
        "\n",
        "- letra faltando: como _suceso_ ao inv√©s de _sucesso_.\n",
        "- letra sobrando: como _menssagem_ ao inv√©s de _mensagem_.\n",
        "- letra trocada: como _viajem_ ao inv√©s de _viagem_.\n",
        "\n",
        "##\n",
        "\n",
        "Existem diversos outros erros de ortografia que n√£o cobriremos:\n",
        "\n",
        "- Como o caso de _excess√£o_ ao inv√©s de _exce√ß√£o_ que tem uma letra trocada e uma letra sobrando.\n",
        "- Ou de _metereologia_ em vez de _meteorologia_ que tem uma letra trocada e em posi√ß√£o errada.\n",
        "\n",
        ". . .\n",
        "\n",
        "Mas a ideia aqui √© aprendermos o _design top-down_ e n√£o criar um corretor ortogr√°fico perfeito.\n",
        "\n",
        "- Os casos que trataremos ser√£o suficientes para o que precisamos.\n",
        "\n",
        "# _Design top-down_ das Sugest√µes de Corre√ß√£o Ortogr√°fica {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "A nossa tarefa √©:\n",
        "\n",
        "- _Escrever um programa que pega uma palavra que pode estar escrita errada_\n",
        "  _e oferece sugest√µes de poss√≠veis corre√ß√µes para ela._\n",
        "- Essa tarefa √© certamente muito grande para ser tratada de uma vez s√≥.\n",
        "\n",
        "\n",
        "##\n",
        "\n",
        "Para dividi-la em subtarefas, a primeira sugest√£o √© tratar os tr√™s passos que s√£o\n",
        "muito comuns em diversos programas:\n",
        "\n",
        "1. Ler a entrada do usu√°rio.\n",
        "2. Processar os dados.\n",
        "3. Exibir a sa√≠da.\n",
        "\n",
        ". . .\n",
        "\n",
        "Obs.: n√≥s j√° t√≠nhamos usado isso no exemplo do processamento dos dados de futebol.\n",
        "\n",
        "## \n",
        "\n",
        "<div style=\"font-size:0.8em\">\n",
        "\n",
        "| Fase | Papel  | Exemplo de uso com o Corretor |\n",
        "|------|--------|-------------------------------|\n",
        "| Entrada | Pegar, como entrada, a informa√ß√£o necess√°ria para a fun√ß√£o | Pegar a palavra errada _suceso_ e uma cole√ß√£o de palavras reais (com ortografia correta) |\n",
        "| Processamento | Realizar as opera√ß√µes especificadas sobre os dados | Considerar altera√ß√µes na palavra que possam levar a uma palavra escrita corretamente (deve ser tentadas todas as combina√ß√µes dos 3 tipos de erros que estamos tratando; ex.: _sucesso_, mas tamb√©m _ssuceso_) |\n",
        "| Sa√≠da | Exibir o resultado do processamento dos dados | Mostrar a sugest√£o _sucesso_ |\n",
        "\n",
        "</div>\n",
        "\n",
        "##\n",
        "\n",
        "Seguindo essas etapas, come√ßamos nosso _design top-down_, divindo a tarefa do corretor em tr√™s subtarefas:\n",
        "\n",
        "1. Entrada: pedimos ao usu√°rio uma palavra para a qual ele quer obter sugest√µes de corre√ß√£o.\n",
        "2. Processamento: precisaremos descobrir todas as poss√≠veis sugest√µes para a palavra do usu√°rio.\n",
        "3. Sa√≠da: exibimos para o usu√°rio todas as sugest√µes que encontramos.\n",
        "\n",
        ". . .\n",
        "\n",
        "E agora criaremos uma fun√ß√£o para cada subtarefa dessa, certo?\n",
        "\n",
        "- Ou n√£o?\n",
        "\n",
        "##\n",
        "\n",
        "Apesar de muitas vezes criarmos uma fun√ß√£o para cada subtarefa, isso nem sempre √© necess√°rio.\n",
        "\n",
        "- Veja que, para o tratamento da entrada do nosso problema, n√≥s precisamos apenas pedir uma palavra ao usu√°rio.\n",
        "  - Acontece que Python j√° tem uma fun√ß√£o _input_ que faz exatamente isso.\n",
        "  - Portanto uma fun√ß√£o para tratar a entrada teria apenas uma linha, o que parece uma divis√£o exagerada.\n",
        "- A mesma coisa pode ser dita sobre o passo de sa√≠da.\n",
        "  - J√° que Python j√° possui uma fun√ß√£o _print_ para isso.\n",
        "\n",
        "##\n",
        "\n",
        "N√£o √© que esteja errado se resolvermos criar fun√ß√µes para esses passos.\n",
        "\n",
        "- Mas devemos refletir se vale realmente a pena criar fun√ß√µes com uma √∫nica linha.\n",
        "  - Um caso onde isso √© √∫til √© se ela fizer algo que precisa ser repetido v√°rias vezes.\n",
        "\n",
        "## Dividindo o subproblema de Processamento\n",
        "\n",
        "Vamos chamar a fun√ß√£o de processamento de `_obter_sugestoes_correcao`.\n",
        "\n",
        "- Quais par√¢metros a fun√ß√£o precisa receber?\n",
        "\n",
        ". . .\n",
        "\n",
        "Com certeza precisa receber a palavra que o usu√°rio digitou.\n",
        "\n",
        "##\n",
        "\n",
        "Ela poderia receber tamb√©m as palavras reais em portugu√™s, para que consiga fazer as sugest√µes.\n",
        "\n",
        "- Isso pode ser feito de diferentes formas:\n",
        "  - Ela pode receber a lista de palavras reais como um par√¢metro.\n",
        "  - Ou o nome de um arquivo que cont√©m essas palavras.\n",
        "\n",
        "## \n",
        "\n",
        "Esse tipo de decis√£o √© muito comum quando estamos fazendo decomposi√ß√£o de subproblemas.\n",
        "\n",
        "- Para nosso exemplo, vamos usar como par√¢metro o nome de um arquivo.\n",
        "- Isso porque temos um arquivo contendo quase 150 mil palavras reais em portugu√™s.\n",
        "- Que foram obtidas atrav√©s de uma busca no Google (do reposit√≥rio [fserb/pt-br](https://github.com/fserb/pt-br)).\n",
        "\n",
        "##\n",
        "\n",
        "Esse √© o nosso _design top-down_ para o corretor at√© o momento:\n",
        "\n",
        "- Considerando que a fun√ß√£o mais geral, do problema como um todo, se chama `corretor_ortografico`.\n",
        "\n",
        "```{mermaid fontSize:40 height=500}\n",
        "flowchart TD\n",
        "  A(corretor_ortografico) --> B(obter_sugestoes_correcao)\n",
        "```\n",
        "\n",
        "```{graphviz width=1000 height=600}\n",
        "digraph {\n",
        "  corretor_ortografico -> obter_sugestoes_correcao\n",
        "}\n",
        "```\n",
        "\n",
        "##\n",
        "\n",
        "\n",
        "E o que precisamos fazer na fun√ß√£o de processamento?\n",
        "\n",
        "- Se pensarmos bem, podemos dividir a fun√ß√£o em 4 subproblemas.\n",
        "\n",
        "  1. Obter uma lista de palavras a partir do arquivo.\n",
        "  2. Gerar uma lista de todas as palavras poss√≠veis a partir da palavra digitada.\n",
        "  3. A partir das palavras poss√≠veis, gerar uma lista contendo apenas palavras reais.\n",
        "  4. Retornar uma lista contendo as palavras reais (as sugest√µes) sem repeti√ß√µes. \n",
        "\n",
        ". . .\n",
        "\n",
        "Vamos acrescentar alguns detalhes a esses passos.\n",
        "\n",
        "##\n",
        "\n",
        "1. Obter uma lista de palavras a partir do arquivo.\n",
        "\n",
        "  - Fun√ß√£o `carregar_lista_palavras` que carrega as palavras do arquivo em uma lista.\n",
        "  - O arquivo tem uma palavra real do portugu√™s em cada linha.\n",
        "\n",
        "2. Gerar uma lista de todas as palavras poss√≠veis a partir da palavra digitada.\n",
        "  - Fun√ß√£o `gerar_palavras_possiveis` que recebe a palavra digitada e gera todas as combina√ß√µes poss√≠veis com os erros que estamos tratando.\n",
        "  - Ou seja, ela gera uma lista enorme de strings: acrescentado uma letra, removendo uma letra ou trocando uma letra.\n",
        "  - Vamos fazer isso sem se preocupar aqui se essas strings formam uma palavra v√°lida ou n√£o.\n",
        "\n",
        "##\n",
        "\n",
        "3. A partir das palavras poss√≠veis, gerar uma lista contendo apenas palavras reais.\n",
        "  - Fun√ß√£o `filtrar_palavras_reais` que recebe a lista de palavras poss√≠veis e a lista de palavras reais.\n",
        "  - E retorna uma lista contendo apenas as palavras que est√£o nas duas listas.\n",
        "\n",
        "4. Retornar uma lista contendo as palavras reais (as sugest√µes) sem repeti√ß√µes.\n",
        "  - Fun√ß√£o `filtrar_palavras_repetidas`. Mas por que ela seria necess√°ria?\n",
        "  - Porque, dependendo da forma como geramos as palavras poss√≠veis, podemos acabar com sugest√µes duplicadas.\n",
        "  - Ex.: se a palavra digitada for _suceso_, podemos gerar _sucesso_ duas vezes.\n",
        "    - Uma ao tentar acrescentar um _s_ depois do _e_,\n",
        "    - e outra ao tentar trocar um _s_ ap√≥s o _s_ j√° existente na palavra.\n",
        "\n",
        "##\n",
        "\n",
        "At√© o momento no _design top-down_ pode ser demonstrado no diagrama abaixo.\n",
        "\n",
        "```{mermaid}\n",
        "flowchart TD\n",
        "  A(corretor_ortografico) --> B(obter_sugestoes_correcao)\n",
        "  B --> C1(carregar_lista_palavras)\n",
        "  B --> C2(gerar_palavras_possiveis)\n",
        "  B --> C3(filtrar_palavras_reais)\n",
        "  B --> C4(filtrar_palavras_repetidas)\n",
        "```\n",
        "\n",
        "##\n",
        "\n",
        "::: {.callout-tip}\n",
        "## M√∫ltiplas formas de decompor um problema\n",
        "\n",
        "N√£o h√° uma √∫nica forma correta de fazer um `design top-down`.\n",
        "\n",
        "Voc√™ poderia ter pensado, por exemplo, em s√≥ gerar palavras que fosse reais,\n",
        "filtrando as palavras j√° no momento em que foram geradas.\n",
        "\n",
        "- Com isso a divis√£o de subproblemas seria diferente.\n",
        "- E √© recomend√°vel que voc√™ tente outras alternativas de decomposi√ß√£o para esse mesmo problema.\n",
        ":::\n",
        "\n",
        "##\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Decomposi√ß√£o √© um processo de tentativa e erro\n",
        "\n",
        "√â muito comum que comecemos com uma ideia de `design top-down` e, no meio do processo,\n",
        "percebamos que precisamos mudar nossa estrat√©gia.\n",
        "\n",
        "- Talvez porque em algum ponto ficou dif√≠cil dividir em subproblemas.\n",
        "- Ou porque chegamos a muitas fun√ß√µes que parecem muito espec√≠ficas (e n√£o seria √∫teis para problemas mais gerais).\n",
        "- Ou ainda porque estamos passando muitos par√¢metros para as fun√ß√µes ou passando um par√¢metro de fun√ß√£o em fun√ß√£o repetidamente.\n",
        "- Ou, por fim, porque apenas queremos experimentar outra abordagem.\n",
        "\n",
        "A recomenda√ß√£o √©: pr√°tica! Quanto mais praticar, mais habilidoso ser√° no processo de decomposi√ß√£o.\n",
        ":::\n",
        "\n",
        "## Carregar lista de palavras\n",
        "\n",
        "Vamos agora pensar em cada subproblema gerado no √∫ltimo passo da decomposi√ß√£o.\n",
        "\n",
        "- N√≥s precisamos quebrar a fun√ß√£o `carregar_lista_palavras` em subtarefas?\n",
        "\n",
        ". . .\n",
        "\n",
        "Poder√≠amos pensar em fases como: abrir o arquivo, carregar os dados em uma lista e fechar o arquivo.\n",
        "\n",
        "- Mas pelo que vimos sobre arquivos do Python na aula passada, sabemos que abrir e fechar o arquivo √© algo muito simples.\n",
        "- Ent√£o vamos manter essa tarefa em uma √∫nica fun√ß√£o.\n",
        "\n",
        "## Gerar a lista de todas as palavras poss√≠veis\n",
        "\n",
        "E a fun√ß√£o `gerar_palavras_possiveis` precisaria ser quebrada?\n",
        "\n",
        "- Vamos pensar em como exatamente essas palavras candidatas seriam geradas.\n",
        "- A ideia √© gerar todas as combina√ß√µes de adicionar uma letra, remover uma letra e trocar uma letra.\n",
        "  - S√≥ de descrever essa ideia j√° percebemos que existem tr√™s opera√ß√µes distintas.\n",
        "  - Que poderiam ent√£o ser tratadas como subproblemas.\n",
        "\n",
        "## Gerar a lista de todas as palavras poss√≠veis\n",
        "\n",
        "Poder√≠amos ent√£o quebrar a tarefa `gerar_palavras_possiveis` em tr√™s subtarefas:\n",
        "\n",
        "1. `adicionar_letra`: que gera uma palavra candidata para cada letra do alfabeto em cada posi√ß√£o poss√≠vel.\n",
        "  - Ex.: `suceso` -> `asuceso`, `bsuceso`, ..., `sauceso`, `sbuceso`, ..., `sucesoa`, `sucesob`.\n",
        "2. `remover_letra`: que gera uma palavra candidata removendo cada letra da palavra original.\n",
        "  - Ex.: `suceso` -> `uceso`, `sceso`, `sueso`, `sucso`, `suceo` e `suces`.\n",
        "3. `trocar_letra`: que gera uma palavra candidata para cada letra do alfabeto substituindo cada letra da palavra original.\n",
        "  - Ex.: `suceso` -> `auceso`, `buceso`, ..., `saceso`, `sbceso`, ..., `sucesy`, ..., `sucesz`.\n",
        "\n",
        "## Gerar a lista de todas as palavras poss√≠veis\n",
        "\n",
        "Precisamos quebrar ainda mais as tarefas anteriores?\n",
        "\n",
        "- Para cada tarefa, parece que precisaremos fazer um loop nas letras da palavra e/ou no alfabeto\n",
        "- E gerar uma palavra para cada combina√ß√£o.\n",
        "\n",
        ". . .\n",
        "\n",
        "Por ora, vamos manter as tarefas como est√£o.\n",
        "\n",
        "- Se, durante a fase de implementa√ß√£o percebermos que as tarefas s√£o mais complicadas que parecem n√≥s quebramos novamente.\n",
        "\n",
        "##\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Como saber quando parar de dividir em subtarefas?\n",
        "\n",
        "Em geral, saber quando para de decompor um subproblema √© mais arte do que ci√™ncia.\n",
        "\n",
        "√â necess√°ria muita pr√°tica para adquirir a intui√ß√£o de quando parar.\n",
        "Desenvolvedores experientes costumam j√° imaginar em sua cabe√ßa como uma tarefa poderia \n",
        "ser resolvida para decidir se deve dividi-la ou n√£o.\n",
        "\n",
        "Mas tudo bem se n√£o soubermos bem como fazer isso por agora. Podemos ter uma uma \n",
        "primeira vers√£o do _design_ e, durante a implementa√ß√£o, se uma fun√ß√£o se torna mais\n",
        "complexa que o esperado, n√≥s a dividimos em subtarefas. Por outro lado, se uma\n",
        "fun√ß√£o ficou muito pequena e espec√≠fica podemos reavaliar e n√£o ter receio de\n",
        "junt√°-la a outras fun√ß√µes.\n",
        ":::\n",
        "\n",
        "## Gerar a lista de todas as palavras reais\n",
        "\n",
        "A fun√ß√£o `filtrar_palavras_reais` receber√° duas listas, uma de palavras candidatas e\n",
        "outra de palavras reais \n",
        "\n",
        "- E precisar√° retornar as palavras candidatas que existem tamb√©m na lista de palavras reais.\n",
        "\n",
        ". . .\n",
        "\n",
        "Se pensarmos um pouco em como resolver esse problema, n√£o parece algo t√£o complicado.\n",
        "\n",
        "- Podemos pensar em um loop que percorre a lista de palavras candidatadas.\n",
        "- E, para cada uma delas, verifica se ela existe tamb√©m na lista de palavras reais.\n",
        "  - Se existir √© adicionada na lista de resposta.\n",
        "\n",
        ". . .\n",
        "\n",
        "Parece um problema simples o suficiente para ser tratado por uma √∫nica fun√ß√£o.\n",
        "\n",
        "## Filtrar palavras repetidas\n",
        "\n",
        "E a fun√ß√£o `filtrar_palavras_repetidas`?\n",
        "\n",
        "- Esse √© um exemplo de como seu conhecimento pr√©vio da linguagem pode mudar sua decis√£o.\n",
        "\n",
        ". . . \n",
        "\n",
        "A princ√≠pio podemos manter a fun√ß√£o, pois podemos pensar em um loop que percorre a lista de palavras\n",
        "\n",
        "- E, para cada palavra, a adicionamos na lista de resposta apenas se ela ainda n√£o estiver l√°.\n",
        "\n",
        ". . . \n",
        "\n",
        "Acontece que Python tem uma fun√ß√£o que remove duplica√ß√µes de uma lista com uma linha de c√≥digo.\n",
        "\n",
        "- Ent√£o se souber disso, voc√™ pode concluir que a fun√ß√£o `filtrar_palavras_repetidas` √© desnecess√°ria.\n",
        "\n",
        "## Resumo do _design top-down_ do corretor ortogr√°fico\n",
        "\n",
        "Nosso _design top-down_ final √© o seguinte:\n",
        "\n",
        "```{mermaid}\n",
        "flowchart TD\n",
        "  A(  ) --> B(obter_sugestoes_correcao)\n",
        "  B --> C1(carregar_lista_palavras)\n",
        "  B --> C2(gerar_palavras_possiveis)\n",
        "  C2 --> D1(adicionar_letra)\n",
        "  C2 --> D2(remover_letra)\n",
        "  C2 --> D3(trocar_letra)\n",
        "  B --> C3(filtrar_palavras_reais)\n",
        "  B --> C4(filtrar_palavras_repetidas)\n",
        "```\n",
        "\n",
        "# Implementa√ß√£o das Sugest√µes de Corre√ß√£o Ortogr√°fica usando  {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Ao fazer o design, n√≥s definimos as fun√ß√µes de cima para baixo (_top-down_).\n",
        "\n",
        "- Mas na hora de implementar √© melhor escrever os c√≥digos das fun√ß√µes de baixo para cima (_bottom-up_).\n",
        "- Por que?\n",
        "\n",
        ". . .\n",
        "\n",
        "Isso porque se gerarmos primeiro as fun√ß√µes de subproblemas finais usando Copilot,\n",
        "\n",
        "- se torna mais prov√°vel que ele as utilize quando pedirmos para gerar o c√≥digo das fun√ß√µes de subproblemas maiores.\n",
        "\n",
        "##\n",
        "\n",
        "A estrat√©gia do livro √© focar na **Decomposi√ß√£o de Problemas** e, por isso, n√£o segue\n",
        "cada passo do **Ciclo de projeto de fun√ß√µes** para cada fun√ß√£o.\n",
        "\n",
        "- Mais especificamente, ele j√° apresenta a solu√ß√£o que preferiram, sem detalhar a **Engenharia de Prompt** utilizada.\n",
        "- e nem acrescenta os **testes** das fun√ß√µes.\n",
        "\n",
        ". . .\n",
        "\n",
        "Eu planejei aqui incluir pelo menos os testes de fun√ß√µes.\n",
        "\n",
        "- Que √© algo importante e geralmente subestimado pelos alunos, e at√© por professores üòú\n",
        "- Mas vamos ver se o tempo da aula vai permitir passar por tudo.\n",
        "\n",
        "## `carregar_lista_palavras`\n",
        "\n",
        "Repare que come√ßar de baixo para cima n√£o significa necessariamente come√ßar pelo n√≠vel mais baixo do\n",
        "design.\n",
        "\n",
        "- O importante √© come√ßar por fun√ß√µes folha.\n",
        "- E s√≥ implementar uma fun√ß√£o se todas as suas subfun√ß√µes estiverem implementadas.\n",
        "\n",
        ". . .\n",
        "\n",
        "Por isso, vamos come√ßar com a fun√ß√£o `carregar_lista_palavras`.\n",
        "\n",
        "## `carregar_lista_palavras`\n",
        "\n",
        "Como j√° fizemos anteriormente, vamos definir a assinatura e a docstring e deixar o Copilot gerar o c√≥digo.\n",
        "\n",
        "\n",
        "```python\n",
        "def carregar_lista_palavras(caminho_arquivo):\n",
        "    \"\"\"\n",
        "    caminho_arquivo  √© o nome de um arquivo que tem uma palavra em portugu√™s por linha.\n",
        "    \n",
        "    Retorna uma lista com as palavras do arquivo.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "## `carregar_lista_palavras`\n",
        "\n",
        "Esse foi o c√≥digo gerado pelo Copilot no meu caso.\n",
        "\n",
        "```python\n",
        "def carregar_lista_palavras(caminho_arquivo):\n",
        "    \"\"\"\n",
        "    caminho_arquivo  √© o nome de um arquivo que tem uma palavra em portugu√™s por linha.\n",
        "    \n",
        "    Retorna uma lista com as palavras do arquivo.\n",
        "    \"\"\"\n",
        "    with open(caminho_arquivo, 'r', encoding='utf-8') as f:\n",
        "        palavras = f.read().splitlines()\n",
        "    return palavras\n",
        "```\n",
        "\n",
        "## Testes da fun√ß√£o `carregar_lista_palavras`\n",
        "\n",
        "Quais testes poder√≠amos pensar para a fun√ß√£o?\n",
        "\n",
        "- Podemos criar tr√™s arquivos de teste: um vazio, um com uma palavra e um com v√°rias palavras.\n",
        "- E criar uma fun√ß√£o de teste para cada caso.\n",
        "\n",
        ". . .\n",
        "\n",
        "No arquivo com uma palavra colocaremos:\n",
        "\n",
        "```\n",
        "exuberante\n",
        "```\n",
        "\n",
        "E no arquivo com v√°rias palavras\n",
        "\n",
        "```\n",
        "dinossauro\n",
        "exuberante\n",
        "melancia\n",
        "tucano\n",
        "```\n",
        "\n",
        "## Testes da fun√ß√£o `carregar_lista_palavras`\n",
        "\n",
        "Nossas fun√ß√µes de teste seriam ent√£o:\n",
        "\n",
        "```python\n",
        "from pathlib import Path\n",
        "from corretor.main import carregar_lista_palavras\n",
        "\n",
        "PASTA_ARQUIVOS = Path(__file__).parent / 'dados'\n",
        "\n",
        "def test_carregar_lista_palavras_vazia():\n",
        "    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'arquivo_vazio.txt')\n",
        "    assert palavras == []\n",
        "\n",
        "def test_carregar_lista_palavras_uma_palavra():\n",
        "    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'uma_palavra.txt')\n",
        "    assert palavras == ['exuberante']\n",
        "\n",
        "def test_carregar_lista_palavras_varias_palavras():\n",
        "    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'varias_palavras.txt')\n",
        "    assert palavras == ['dinossauro', 'exuberante', 'melancia', 'tucano']\n",
        "```\n",
        "\n",
        "## Observa√ß√£o sobre os slides\n",
        "\n",
        "Daqui por diante, na aula, n√≥s vamos criar todas as fun√ß√µes e suas respectivas fun√ß√µes\n",
        "de teste em um projeto no VS Code.\n",
        "\n",
        "- Esse projeto estar√° dispon√≠vel no reposit√≥rio [ufla-pasia/corretor-ortografico](https://github.com/ufla-pasia/corretor-ortografico).\n",
        "\n",
        ". . .\n",
        "\n",
        "J√° aqui nos slides vou manter apenas o prompt das fun√ß√µes (assinatura e docstring) e a\n",
        "descri√ß√£o em alto n√≠vel dos testes.\n",
        "\n",
        "## `adicionar_letra`\n",
        "\n",
        "```python\n",
        "def adicionar_letra(palavra):\n",
        "    \"\"\"\n",
        "    palavra √© uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as strings que podem ser obtidas\n",
        "    adicionando uma letra em qualquer posi√ß√£o da palavra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "Obs.: para simplificar, vamos ignorar o acr√©scimo de letras com acentos.\n",
        "\n",
        "---\n",
        "\n",
        "## `remover_letra`\n",
        "\n",
        "```python\n",
        "def remover_letra(palavra):\n",
        "    \"\"\"\n",
        "    palavra √© uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as strings que podem ser obtidas\n",
        "    removendo uma letra de qualquer posi√ß√£o da palavra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `trocar_letra`\n",
        "\n",
        "```python\n",
        "def trocar_letra(palavra):\n",
        "    \"\"\"\n",
        "    palavra √© uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as strings que podem ser obtidas\n",
        "    trocando uma letra de qualquer posi√ß√£o da palavra por outra letra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `gerar_palavras_possiveis`\n",
        "\n",
        "```python\n",
        "def gerar_palavras_possiveis(palavra):\n",
        "    \"\"\"\n",
        "    palavra √© uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as palavras poss√≠veis que podem ser geradas\n",
        "    a partir da palavra original, atrav√©s das opera√ß√µes de adicionar, remover\n",
        "    ou trocar uma letra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `filtrar_palavras_reais`\n",
        "\n",
        "```python\n",
        "def filtrar_palavras_reais(lista_palavras, palavras_possiveis):\n",
        "    \"\"\"\n",
        "    lista_palavras √© uma lista de strings com palavras em portugu√™s.\n",
        "    palavras_possiveis √© uma lista de palavras poss√≠veis.\n",
        "\n",
        "    Retorna uma lista das palavras poss√≠veis que est√£o na lista de palavras.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `filtrar_palavras_repetidas`\n",
        "\n",
        "```python\n",
        "def filtrar_palavras_repetidas(palavras_reais):\n",
        "    \"\"\"\n",
        "    palavras_reais √© uma lista de strings com palavras em portugu√™s.\n",
        "\n",
        "    Retorna a lista sem palavras repetidas.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `obter_sugestoes_correcao`\n",
        "\n",
        "```python\n",
        "def obter_sugestoes_correcao(caminho_arquivo, possivel_palavra):\n",
        "    \"\"\"\n",
        "    caminho_arquivo √© o nome de um arquivo que tem uma palavra em portugu√™s por linha.\n",
        "    possivel_palavra √©  uma string que pode ser ou n√£o uma palavra real em portugu√™s.\n",
        "\n",
        "    Retorna a lista de todas as poss√≠veis corre√ß√µes √∫nicas para a poss√≠vel palavra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `corretor_ortografico`\n",
        "\n",
        "```python\n",
        "def corretor_ortografico(caminho_arquivo):\n",
        "    \"\"\"\n",
        "    caminho_arquivo √© o nome de um arquivo que cont√©m palavras em portugu√™s.\n",
        "\n",
        "    Pede ao usu√°rio uma palavra e exibe todas as poss√≠veis corre√ß√µes para aquela palavra,\n",
        "    uma por linha."
      ],
      "id": "60b52121"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}