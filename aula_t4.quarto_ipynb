{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Decomposição de Problemas\n",
        "subtitle: PASIA - Aula T.4\n",
        "---\n",
        "\n",
        "##  \n",
        "\n",
        "O conteúdo dessa aula é inspirado no **capítulos 7** do livro abaixo.\n",
        "\n",
        "![](imagens/livro_potter_zingaro.png){fig-align=\"center\" fig-alt=\"Capa do livro de Potter e Zingaro.\" style=\"max-height: 50vh; width: auto;\"}\n",
        "\n",
        "# Introdução {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Já comentamos em aulas anteriores que não devemos pedir ao Copilot para resolver \n",
        "um problema muito grande de uma vez só.\n",
        "\n",
        "- Como: _Crie um jogo de estratégia multiplayer desafiador e divertido_.\n",
        "\n",
        ". . .\n",
        "\n",
        "No pior caso, o Copilot não vai gerar nada útil.\n",
        "\n",
        "- Há casos em que ele só fica gerando comentários em sequência.\n",
        "\n",
        "##\n",
        "\n",
        "E, na melhor das hipóteses, você teria um jogo _\"enlatado\"_ que não é muito divertido ou desafiador.\n",
        "\n",
        "- Parte do poder de ser um programador é conseguir customizar o que você cria.\n",
        "\n",
        ". . .\n",
        "\n",
        "Além disso, imagina a dificuldade que seria corrigir todos os erros de um jogo inteiro gerado de uma vez.\n",
        "\n",
        ". . .\n",
        "\n",
        "Nós precisamos pedir ao Copilot para resolver pequenos problemas pra gente.\n",
        "\n",
        "- E nós mesmos vamos juntando esses pedaços em nossos programas.\n",
        "\n",
        "##\n",
        "\n",
        "O objetivo dessa aula é aprender a quebrar um problema grande em subproblemas menores.\n",
        "\n",
        "- De forma que consigamos resolver grandes problemas usando programação.\n",
        "\n",
        "# Decomposição de Problemas {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "[Decomposição de problemas]{.alert} envolve começar com um problema grande e que não \n",
        "está bem especificado\n",
        "\n",
        "- e **quebrá-lo em subproblemas**, os quais são **bem definidos** e **úteis** para resolver o problema original.\n",
        "\n",
        ". . .\n",
        "\n",
        "Na aula vamos trabalhar com decomposição de funções.\n",
        "\n",
        "- O que faremos portanto é escrever funções para cada um dos subproblemas que identificamos.\n",
        "\n",
        "##\n",
        "\n",
        "Ao identificarmos um subproblema, pode ser que consigamos resolvê-lo escrevendo uma função.\n",
        "\n",
        "- Ou pode se que ele ainda seja muito grande para ser implementado em uma única função.\n",
        "- E então precisaremos quebrá-lo em sub-subproblemas.\n",
        "  - Esperamos então que cada sub-suproblema seja pequeno o suficiente.\n",
        "  - Mas se não for, continuamos quebrando em subproblemas sucessivamente.\n",
        "\n",
        "##\n",
        "\n",
        "A principal **razão** para decompormos problemas é a **complexidade**.\n",
        "\n",
        ". . .\n",
        "\n",
        "Cada função deve ser simples o suficiente de forma que:\n",
        "\n",
        "- consigamos entender o seu propósito;\n",
        "- consigamos pedir ao Copilot para implementá-la;\n",
        "- e, se tiver algum erro, não tenhamos muitas dificuldades em resolvê-lo.\n",
        "\n",
        "## \n",
        "\n",
        "Quando escrevemos um código que é muito complexo, é muito mais provável que cometamos erros.\n",
        "\n",
        "- O mesmo vale para o Copilot.\n",
        "\n",
        ". . .\n",
        "\n",
        "E quando temos erros em códigos grandes e complexos não é fácil encontrá-los e corrigi-los.\n",
        "\n",
        ". . .\n",
        "\n",
        "_\"É difícil exagerar a importância da decomposição de problemas para a qualidade de código\"_\n",
        "\n",
        "##\n",
        "\n",
        "No contexto da **Engenharia de Software** nós chamamos a decomposição de problemas de\n",
        "[design top-down]{.alert} (abordagem de cima pra baixo).\n",
        "\n",
        "- Tem esse nome porque começamos com uma tarefa grande que precisamos completar e a\n",
        "  dividimos em tarefas menores.\n",
        "- Durante o _design top-down_, nós criamos a \"casca\" das funções que precisamos implementar.\n",
        "- Depois que terminamos o _design_, podemos implementar o código das funções definidas.\n",
        "\n",
        "##\n",
        "\n",
        "Nós geralmente acabamos tendo:\n",
        "\n",
        "- uma função para o problema completo\n",
        "- que chama as funções que implementam os subproblemas.\n",
        "- E cada função de subproblema pode chamar funções de subsubproblemas.\n",
        "- E assim sucessivamente.\n",
        "\n",
        ". . .\n",
        "\n",
        "Nesse processo, procuramos definir funções que recebem poucos parâmetros e que\n",
        "retornam poucas informações, mas úteis.\n",
        "\n",
        "- O que ajuda muito a melhorar a facilidade de entendimento do código.\n",
        "\n",
        "# Pequenos exemplos de _design top-down_ {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Nas aulas anteriores já utilizamos alguns exemplos, ainda que simples, que poderiam ter sido tratados com _design top-down_.\n",
        "\n",
        ". . .\n",
        "\n",
        "Nós criamos, por exemplo, a função `obter_senha_forte`\n",
        "\n",
        "- que fica pedindo um usuário para digitar uma senha até que ele digite uma senha forte.\n",
        "\n",
        ". . .\n",
        "\n",
        "Seguindo o _design top-down_ poderíamos identificar uma subtarefa dessa tarefa.\n",
        "\n",
        "- Que é verificar se uma senha é forte.\n",
        "- O que é justamente o que a função `eh_senha_forte` faz.\n",
        "\n",
        "##\n",
        "\n",
        "Podemos representar o _design top down_ como mostrado abaixo.\n",
        "\n",
        "```{mermaid fontSize:25}\n",
        "flowchart TD\n",
        "  A(obter_senha_forte) --> B(eh_senha_forte)\n",
        "```\n",
        "\n",
        "## \n",
        "\n",
        "Nós também trabalhamos com uma função `melhor_palavra` que recebe uma\n",
        "lista de palavras e retorna aquela que faz mais pontos no jogo _Scrabble_.\n",
        "\n",
        "- Se tivéssemos criando a função usando _design top-down_, poderíamos \n",
        "identificar uma subtarefa que é calcular a pontuação de uma palavra.\n",
        "\n",
        ". . .\n",
        "\n",
        "Teríamos então o seguinte _design top-down_:\n",
        "\n",
        "```{mermaid fontSize:25}\n",
        "flowchart TD\n",
        "  A(melhor_palavra) --> B(numero_de_pontos)\n",
        "```\n",
        "\n",
        "##\n",
        "\n",
        "Quando nós criamos essas funções na aula passada, nós não usamos _design top-down_.\n",
        "\n",
        "- Nós começamos da subtarefa (função folha) e depois criamos a função que resolve o problema maior.\n",
        "\n",
        ". . .\n",
        "\n",
        "Agora, para implementar o código das funções, nós continuaremos a fazer dessa forma.\n",
        "\n",
        "- Mas antes disso, vamos projetar quais são as funções necessárias usando _design top-down_.\n",
        "\n",
        "##\n",
        "\n",
        "É importante ressaltar que, para esses exemplos pequenos, pode parecer que não faria\n",
        "muita diferença usar ou não _design top-down_.\n",
        "\n",
        "- Ou até mesmo pode parecer desnecessário implementar mais de uma função.\n",
        "\n",
        ". . .\n",
        "\n",
        "Mas, para problemas maiores, a decomposição de problemas é a única forma de manter\n",
        "a complexidade sob controle.\n",
        "\n",
        "- O nosso objetivo aqui é adquirir a [habilidade]{.alert} de quebrar um problema em problemas menores.\n",
        "\n",
        "# Sugestões de Correção Ortográfica {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Vamos agora resolver um problema usando _design top-down_ desde o início.\n",
        "\n",
        "- Ao longo da disciplina, nós vamos continuar abordando essa estratégia.\n",
        "- De forma que você consiga aplicá-la com susesso por conta própria.\n",
        "\n",
        ". . .\n",
        "\n",
        "Ops.. tem um erro na frase anterior.\n",
        "\n",
        "- O correto é _sucesso_ e não _susesso_.\n",
        "\n",
        "##\n",
        "\n",
        "É comum que erros de digitação ocorram ou que tenhamos dúvidas sobre a ortografia de uma palavra.\n",
        "\n",
        "- Ex.: exceção ou excesão ou excessão?\n",
        "\n",
        ". . .\n",
        "\n",
        "O que nós vamos fazer é pegar uma palavra que pode estar escrita errada\n",
        "\n",
        "- e oferecer sugestões de possíveis correções para ela.\n",
        "\n",
        ". . .\n",
        "\n",
        "Será um corretor ortográfico básico para palavras individuais.\n",
        "\n",
        "##\n",
        "\n",
        "Nós vamos tratar três tipos de erro de ortografia:\n",
        "\n",
        "- letra faltando: como _suceso_ ao invés de _sucesso_.\n",
        "- letra sobrando: como _menssagem_ ao invés de _mensagem_.\n",
        "- letra trocada: como _viajem_ ao invés de _viagem_.\n",
        "\n",
        "##\n",
        "\n",
        "Existem diversos outros erros de ortografia que não cobriremos:\n",
        "\n",
        "- Como o caso de _excessão_ ao invés de _exceção_ que tem uma letra trocada e uma letra sobrando.\n",
        "- Ou de _metereologia_ em vez de _meteorologia_ que tem uma letra trocada e em posição errada.\n",
        "\n",
        ". . .\n",
        "\n",
        "Mas a ideia aqui é aprendermos o _design top-down_ e não criar um corretor ortográfico perfeito.\n",
        "\n",
        "- Os casos que trataremos serão suficientes para o que precisamos.\n",
        "\n",
        "# _Design top-down_ das Sugestões de Correção Ortográfica {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "A nossa tarefa é:\n",
        "\n",
        "- _Escrever um programa que pega uma palavra que pode estar escrita errada_\n",
        "  _e oferece sugestões de possíveis correções para ela._\n",
        "- Essa tarefa é certamente muito grande para ser tratada de uma vez só.\n",
        "\n",
        "\n",
        "##\n",
        "\n",
        "Para dividi-la em subtarefas, a primeira sugestão é tratar os três passos que são\n",
        "muito comuns em diversos programas:\n",
        "\n",
        "1. Ler a entrada do usuário.\n",
        "2. Processar os dados.\n",
        "3. Exibir a saída.\n",
        "\n",
        ". . .\n",
        "\n",
        "Obs.: nós já tínhamos usado isso no exemplo do processamento dos dados de futebol.\n",
        "\n",
        "## \n",
        "\n",
        "<div style=\"font-size:0.8em\">\n",
        "\n",
        "| Fase | Papel  | Exemplo de uso com o Corretor |\n",
        "|------|--------|-------------------------------|\n",
        "| Entrada | Pegar, como entrada, a informação necessária para a função | Pegar a palavra errada _suceso_ e uma coleção de palavras reais (com ortografia correta) |\n",
        "| Processamento | Realizar as operações especificadas sobre os dados | Considerar alterações na palavra que possam levar a uma palavra escrita corretamente (deve ser tentadas todas as combinações dos 3 tipos de erros que estamos tratando; ex.: _sucesso_, mas também _ssuceso_) |\n",
        "| Saída | Exibir o resultado do processamento dos dados | Mostrar a sugestão _sucesso_ |\n",
        "\n",
        "</div>\n",
        "\n",
        "##\n",
        "\n",
        "Seguindo essas etapas, começamos nosso _design top-down_, divindo a tarefa do corretor em três subtarefas:\n",
        "\n",
        "1. Entrada: pedimos ao usuário uma palavra para a qual ele quer obter sugestões de correção.\n",
        "2. Processamento: precisaremos descobrir todas as possíveis sugestões para a palavra do usuário.\n",
        "3. Saída: exibimos para o usuário todas as sugestões que encontramos.\n",
        "\n",
        ". . .\n",
        "\n",
        "E agora criaremos uma função para cada subtarefa dessa, certo?\n",
        "\n",
        "- Ou não?\n",
        "\n",
        "##\n",
        "\n",
        "Apesar de muitas vezes criarmos uma função para cada subtarefa, isso nem sempre é necessário.\n",
        "\n",
        "- Veja que, para o tratamento da entrada do nosso problema, nós precisamos apenas pedir uma palavra ao usuário.\n",
        "  - Acontece que Python já tem uma função _input_ que faz exatamente isso.\n",
        "  - Portanto uma função para tratar a entrada teria apenas uma linha, o que parece uma divisão exagerada.\n",
        "- A mesma coisa pode ser dita sobre o passo de saída.\n",
        "  - Já que Python já possui uma função _print_ para isso.\n",
        "\n",
        "##\n",
        "\n",
        "Não é que esteja errado se resolvermos criar funções para esses passos.\n",
        "\n",
        "- Mas devemos refletir se vale realmente a pena criar funções com uma única linha.\n",
        "  - Um caso onde isso é útil é se ela fizer algo que precisa ser repetido várias vezes.\n",
        "\n",
        "## Dividindo o subproblema de Processamento\n",
        "\n",
        "Vamos chamar a função de processamento de `_obter_sugestoes_correcao`.\n",
        "\n",
        "- Quais parâmetros a função precisa receber?\n",
        "\n",
        ". . .\n",
        "\n",
        "Com certeza precisa receber a palavra que o usuário digitou.\n",
        "\n",
        "##\n",
        "\n",
        "Ela poderia receber também as palavras reais em português, para que consiga fazer as sugestões.\n",
        "\n",
        "- Isso pode ser feito de diferentes formas:\n",
        "  - Ela pode receber a lista de palavras reais como um parâmetro.\n",
        "  - Ou o nome de um arquivo que contém essas palavras.\n",
        "\n",
        "## \n",
        "\n",
        "Esse tipo de decisão é muito comum quando estamos fazendo decomposição de subproblemas.\n",
        "\n",
        "- Para nosso exemplo, vamos usar como parâmetro o nome de um arquivo.\n",
        "- Isso porque temos um arquivo contendo quase 150 mil palavras reais em português.\n",
        "- Que foram obtidas através de uma busca no Google (do repositório [fserb/pt-br](https://github.com/fserb/pt-br)).\n",
        "\n",
        "##\n",
        "\n",
        "Esse é o nosso _design top-down_ para o corretor até o momento:\n",
        "\n",
        "- Considerando que a função mais geral, do problema como um todo, se chama `corretor_ortografico`.\n",
        "\n",
        "```{mermaid fontSize:40 height=500}\n",
        "flowchart TD\n",
        "  A(corretor_ortografico) --> B(obter_sugestoes_correcao)\n",
        "```\n",
        "\n",
        "```{graphviz width=1000 height=600}\n",
        "digraph {\n",
        "  corretor_ortografico -> obter_sugestoes_correcao\n",
        "}\n",
        "```\n",
        "\n",
        "##\n",
        "\n",
        "\n",
        "E o que precisamos fazer na função de processamento?\n",
        "\n",
        "- Se pensarmos bem, podemos dividir a função em 4 subproblemas.\n",
        "\n",
        "  1. Obter uma lista de palavras a partir do arquivo.\n",
        "  2. Gerar uma lista de todas as palavras possíveis a partir da palavra digitada.\n",
        "  3. A partir das palavras possíveis, gerar uma lista contendo apenas palavras reais.\n",
        "  4. Retornar uma lista contendo as palavras reais (as sugestões) sem repetições. \n",
        "\n",
        ". . .\n",
        "\n",
        "Vamos acrescentar alguns detalhes a esses passos.\n",
        "\n",
        "##\n",
        "\n",
        "1. Obter uma lista de palavras a partir do arquivo.\n",
        "\n",
        "  - Função `carregar_lista_palavras` que carrega as palavras do arquivo em uma lista.\n",
        "  - O arquivo tem uma palavra real do português em cada linha.\n",
        "\n",
        "2. Gerar uma lista de todas as palavras possíveis a partir da palavra digitada.\n",
        "  - Função `gerar_palavras_possiveis` que recebe a palavra digitada e gera todas as combinações possíveis com os erros que estamos tratando.\n",
        "  - Ou seja, ela gera uma lista enorme de strings: acrescentado uma letra, removendo uma letra ou trocando uma letra.\n",
        "  - Vamos fazer isso sem se preocupar aqui se essas strings formam uma palavra válida ou não.\n",
        "\n",
        "##\n",
        "\n",
        "3. A partir das palavras possíveis, gerar uma lista contendo apenas palavras reais.\n",
        "  - Função `filtrar_palavras_reais` que recebe a lista de palavras possíveis e a lista de palavras reais.\n",
        "  - E retorna uma lista contendo apenas as palavras que estão nas duas listas.\n",
        "\n",
        "4. Retornar uma lista contendo as palavras reais (as sugestões) sem repetições.\n",
        "  - Função `filtrar_palavras_repetidas`. Mas por que ela seria necessária?\n",
        "  - Porque, dependendo da forma como geramos as palavras possíveis, podemos acabar com sugestões duplicadas.\n",
        "  - Ex.: se a palavra digitada for _suceso_, podemos gerar _sucesso_ duas vezes.\n",
        "    - Uma ao tentar acrescentar um _s_ depois do _e_,\n",
        "    - e outra ao tentar trocar um _s_ após o _s_ já existente na palavra.\n",
        "\n",
        "##\n",
        "\n",
        "Até o momento no _design top-down_ pode ser demonstrado no diagrama abaixo.\n",
        "\n",
        "```{mermaid}\n",
        "flowchart TD\n",
        "  A(corretor_ortografico) --> B(obter_sugestoes_correcao)\n",
        "  B --> C1(carregar_lista_palavras)\n",
        "  B --> C2(gerar_palavras_possiveis)\n",
        "  B --> C3(filtrar_palavras_reais)\n",
        "  B --> C4(filtrar_palavras_repetidas)\n",
        "```\n",
        "\n",
        "##\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Múltiplas formas de decompor um problema\n",
        "\n",
        "Não há uma única forma correta de fazer um `design top-down`.\n",
        "\n",
        "Você poderia ter pensado, por exemplo, em só gerar palavras que fosse reais,\n",
        "filtrando as palavras já no momento em que foram geradas.\n",
        "\n",
        "- Com isso a divisão de subproblemas seria diferente.\n",
        "- E é recomendável que você tente outras alternativas de decomposição para esse mesmo problema.\n",
        ":::\n",
        "\n",
        "##\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Decomposição é um processo de tentativa e erro\n",
        "\n",
        "É muito comum que comecemos com uma ideia de `design top-down` e, no meio do processo,\n",
        "percebamos que precisamos mudar nossa estratégia.\n",
        "\n",
        "- Talvez porque em algum ponto ficou difícil dividir em subproblemas.\n",
        "- Ou porque chegamos a muitas funções que parecem muito específicas (e não seria úteis para problemas mais gerais).\n",
        "- Ou ainda porque estamos passando muitos parâmetros para as funções ou passando um parâmetro de função em função repetidamente.\n",
        "- Ou, por fim, porque apenas queremos experimentar outra abordagem.\n",
        "\n",
        "A recomendação é: prática! Quanto mais praticar, mais habilidoso será no processo de decomposição.\n",
        ":::\n",
        "\n",
        "## Carregar lista de palavras\n",
        "\n",
        "Vamos agora pensar em cada subproblema gerado no último passo da decomposição.\n",
        "\n",
        "- Nós precisamos quebrar a função `carregar_lista_palavras` em subtarefas?\n",
        "\n",
        ". . .\n",
        "\n",
        "Poderíamos pensar em fases como: abrir o arquivo, carregar os dados em uma lista e fechar o arquivo.\n",
        "\n",
        "- Mas pelo que vimos sobre arquivos do Python na aula passada, sabemos que abrir e fechar o arquivo é algo muito simples.\n",
        "- Então vamos manter essa tarefa em uma única função.\n",
        "\n",
        "## Gerar a lista de todas as palavras possíveis\n",
        "\n",
        "E a função `gerar_palavras_possiveis` precisaria ser quebrada?\n",
        "\n",
        "- Vamos pensar em como exatamente essas palavras candidatas seriam geradas.\n",
        "- A ideia é gerar todas as combinações de adicionar uma letra, remover uma letra e trocar uma letra.\n",
        "  - Só de descrever essa ideia já percebemos que existem três operações distintas.\n",
        "  - Que poderiam então ser tratadas como subproblemas.\n",
        "\n",
        "## Gerar a lista de todas as palavras possíveis\n",
        "\n",
        "Poderíamos então quebrar a tarefa `gerar_palavras_possiveis` em três subtarefas:\n",
        "\n",
        "1. `adicionar_letra`: que gera uma palavra candidata para cada letra do alfabeto em cada posição possível.\n",
        "  - Ex.: `suceso` -> `asuceso`, `bsuceso`, ..., `sauceso`, `sbuceso`, ..., `sucesoa`, `sucesob`.\n",
        "2. `remover_letra`: que gera uma palavra candidata removendo cada letra da palavra original.\n",
        "  - Ex.: `suceso` -> `uceso`, `sceso`, `sueso`, `sucso`, `suceo` e `suces`.\n",
        "3. `trocar_letra`: que gera uma palavra candidata para cada letra do alfabeto substituindo cada letra da palavra original.\n",
        "  - Ex.: `suceso` -> `auceso`, `buceso`, ..., `saceso`, `sbceso`, ..., `sucesy`, ..., `sucesz`.\n",
        "\n",
        "## Gerar a lista de todas as palavras possíveis\n",
        "\n",
        "Precisamos quebrar ainda mais as tarefas anteriores?\n",
        "\n",
        "- Para cada tarefa, parece que precisaremos fazer um loop nas letras da palavra e/ou no alfabeto\n",
        "- E gerar uma palavra para cada combinação.\n",
        "\n",
        ". . .\n",
        "\n",
        "Por ora, vamos manter as tarefas como estão.\n",
        "\n",
        "- Se, durante a fase de implementação percebermos que as tarefas são mais complicadas que parecem nós quebramos novamente.\n",
        "\n",
        "##\n",
        "\n",
        "::: {.callout-tip}\n",
        "## Como saber quando parar de dividir em subtarefas?\n",
        "\n",
        "Em geral, saber quando para de decompor um subproblema é mais arte do que ciência.\n",
        "\n",
        "É necessária muita prática para adquirir a intuição de quando parar.\n",
        "Desenvolvedores experientes costumam já imaginar em sua cabeça como uma tarefa poderia \n",
        "ser resolvida para decidir se deve dividi-la ou não.\n",
        "\n",
        "Mas tudo bem se não soubermos bem como fazer isso por agora. Podemos ter uma uma \n",
        "primeira versão do _design_ e, durante a implementação, se uma função se torna mais\n",
        "complexa que o esperado, nós a dividimos em subtarefas. Por outro lado, se uma\n",
        "função ficou muito pequena e específica podemos reavaliar e não ter receio de\n",
        "juntá-la a outras funções.\n",
        ":::\n",
        "\n",
        "## Gerar a lista de todas as palavras reais\n",
        "\n",
        "A função `filtrar_palavras_reais` receberá duas listas, uma de palavras candidatas e\n",
        "outra de palavras reais \n",
        "\n",
        "- E precisará retornar as palavras candidatas que existem também na lista de palavras reais.\n",
        "\n",
        ". . .\n",
        "\n",
        "Se pensarmos um pouco em como resolver esse problema, não parece algo tão complicado.\n",
        "\n",
        "- Podemos pensar em um loop que percorre a lista de palavras candidatadas.\n",
        "- E, para cada uma delas, verifica se ela existe também na lista de palavras reais.\n",
        "  - Se existir é adicionada na lista de resposta.\n",
        "\n",
        ". . .\n",
        "\n",
        "Parece um problema simples o suficiente para ser tratado por uma única função.\n",
        "\n",
        "## Filtrar palavras repetidas\n",
        "\n",
        "E a função `filtrar_palavras_repetidas`?\n",
        "\n",
        "- Esse é um exemplo de como seu conhecimento prévio da linguagem pode mudar sua decisão.\n",
        "\n",
        ". . . \n",
        "\n",
        "A princípio podemos manter a função, pois podemos pensar em um loop que percorre a lista de palavras\n",
        "\n",
        "- E, para cada palavra, a adicionamos na lista de resposta apenas se ela ainda não estiver lá.\n",
        "\n",
        ". . . \n",
        "\n",
        "Acontece que Python tem uma função que remove duplicações de uma lista com uma linha de código.\n",
        "\n",
        "- Então se souber disso, você pode concluir que a função `filtrar_palavras_repetidas` é desnecessária.\n",
        "\n",
        "## Resumo do _design top-down_ do corretor ortográfico\n",
        "\n",
        "Nosso _design top-down_ final é o seguinte:\n",
        "\n",
        "```{mermaid}\n",
        "flowchart TD\n",
        "  A(  ) --> B(obter_sugestoes_correcao)\n",
        "  B --> C1(carregar_lista_palavras)\n",
        "  B --> C2(gerar_palavras_possiveis)\n",
        "  C2 --> D1(adicionar_letra)\n",
        "  C2 --> D2(remover_letra)\n",
        "  C2 --> D3(trocar_letra)\n",
        "  B --> C3(filtrar_palavras_reais)\n",
        "  B --> C4(filtrar_palavras_repetidas)\n",
        "```\n",
        "\n",
        "# Implementação das Sugestões de Correção Ortográfica usando  {background-color=\"#40666e\"}\n",
        "\n",
        "##\n",
        "\n",
        "Ao fazer o design, nós definimos as funções de cima para baixo (_top-down_).\n",
        "\n",
        "- Mas na hora de implementar é melhor escrever os códigos das funções de baixo para cima (_bottom-up_).\n",
        "- Por que?\n",
        "\n",
        ". . .\n",
        "\n",
        "Isso porque se gerarmos primeiro as funções de subproblemas finais usando Copilot,\n",
        "\n",
        "- se torna mais provável que ele as utilize quando pedirmos para gerar o código das funções de subproblemas maiores.\n",
        "\n",
        "##\n",
        "\n",
        "A estratégia do livro é focar na **Decomposição de Problemas** e, por isso, não segue\n",
        "cada passo do **Ciclo de projeto de funções** para cada função.\n",
        "\n",
        "- Mais especificamente, ele já apresenta a solução que preferiram, sem detalhar a **Engenharia de Prompt** utilizada.\n",
        "- e nem acrescenta os **testes** das funções.\n",
        "\n",
        ". . .\n",
        "\n",
        "Eu planejei aqui incluir pelo menos os testes de funções.\n",
        "\n",
        "- Que é algo importante e geralmente subestimado pelos alunos, e até por professores 😜\n",
        "- Mas vamos ver se o tempo da aula vai permitir passar por tudo.\n",
        "\n",
        "## `carregar_lista_palavras`\n",
        "\n",
        "Repare que começar de baixo para cima não significa necessariamente começar pelo nível mais baixo do\n",
        "design.\n",
        "\n",
        "- O importante é começar por funções folha.\n",
        "- E só implementar uma função se todas as suas subfunções estiverem implementadas.\n",
        "\n",
        ". . .\n",
        "\n",
        "Por isso, vamos começar com a função `carregar_lista_palavras`.\n",
        "\n",
        "## `carregar_lista_palavras`\n",
        "\n",
        "Como já fizemos anteriormente, vamos definir a assinatura e a docstring e deixar o Copilot gerar o código.\n",
        "\n",
        "\n",
        "```python\n",
        "def carregar_lista_palavras(caminho_arquivo):\n",
        "    \"\"\"\n",
        "    caminho_arquivo  é o nome de um arquivo que tem uma palavra em português por linha.\n",
        "    \n",
        "    Retorna uma lista com as palavras do arquivo.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "## `carregar_lista_palavras`\n",
        "\n",
        "Esse foi o código gerado pelo Copilot no meu caso.\n",
        "\n",
        "```python\n",
        "def carregar_lista_palavras(caminho_arquivo):\n",
        "    \"\"\"\n",
        "    caminho_arquivo  é o nome de um arquivo que tem uma palavra em português por linha.\n",
        "    \n",
        "    Retorna uma lista com as palavras do arquivo.\n",
        "    \"\"\"\n",
        "    with open(caminho_arquivo, 'r', encoding='utf-8') as f:\n",
        "        palavras = f.read().splitlines()\n",
        "    return palavras\n",
        "```\n",
        "\n",
        "## Testes da função `carregar_lista_palavras`\n",
        "\n",
        "Quais testes poderíamos pensar para a função?\n",
        "\n",
        "- Podemos criar três arquivos de teste: um vazio, um com uma palavra e um com várias palavras.\n",
        "- E criar uma função de teste para cada caso.\n",
        "\n",
        ". . .\n",
        "\n",
        "No arquivo com uma palavra colocaremos:\n",
        "\n",
        "```\n",
        "exuberante\n",
        "```\n",
        "\n",
        "E no arquivo com várias palavras\n",
        "\n",
        "```\n",
        "dinossauro\n",
        "exuberante\n",
        "melancia\n",
        "tucano\n",
        "```\n",
        "\n",
        "## Testes da função `carregar_lista_palavras`\n",
        "\n",
        "Nossas funções de teste seriam então:\n",
        "\n",
        "```python\n",
        "from pathlib import Path\n",
        "from corretor.main import carregar_lista_palavras\n",
        "\n",
        "PASTA_ARQUIVOS = Path(__file__).parent / 'dados'\n",
        "\n",
        "def test_carregar_lista_palavras_vazia():\n",
        "    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'arquivo_vazio.txt')\n",
        "    assert palavras == []\n",
        "\n",
        "def test_carregar_lista_palavras_uma_palavra():\n",
        "    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'uma_palavra.txt')\n",
        "    assert palavras == ['exuberante']\n",
        "\n",
        "def test_carregar_lista_palavras_varias_palavras():\n",
        "    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'varias_palavras.txt')\n",
        "    assert palavras == ['dinossauro', 'exuberante', 'melancia', 'tucano']\n",
        "```\n",
        "\n",
        "## Observação sobre os slides\n",
        "\n",
        "Daqui por diante, na aula, nós vamos criar todas as funções e suas respectivas funções\n",
        "de teste em um projeto no VS Code.\n",
        "\n",
        "- Esse projeto estará disponível no repositório [ufla-pasia/corretor-ortografico](https://github.com/ufla-pasia/corretor-ortografico).\n",
        "\n",
        ". . .\n",
        "\n",
        "Já aqui nos slides vou manter apenas o prompt das funções (assinatura e docstring) e a\n",
        "descrição em alto nível dos testes.\n",
        "\n",
        "## `adicionar_letra`\n",
        "\n",
        "```python\n",
        "def adicionar_letra(palavra):\n",
        "    \"\"\"\n",
        "    palavra é uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as strings que podem ser obtidas\n",
        "    adicionando uma letra em qualquer posição da palavra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "Obs.: para simplificar, vamos ignorar o acréscimo de letras com acentos.\n",
        "\n",
        "---\n",
        "\n",
        "## `remover_letra`\n",
        "\n",
        "```python\n",
        "def remover_letra(palavra):\n",
        "    \"\"\"\n",
        "    palavra é uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as strings que podem ser obtidas\n",
        "    removendo uma letra de qualquer posição da palavra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `trocar_letra`\n",
        "\n",
        "```python\n",
        "def trocar_letra(palavra):\n",
        "    \"\"\"\n",
        "    palavra é uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as strings que podem ser obtidas\n",
        "    trocando uma letra de qualquer posição da palavra por outra letra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `gerar_palavras_possiveis`\n",
        "\n",
        "```python\n",
        "def gerar_palavras_possiveis(palavra):\n",
        "    \"\"\"\n",
        "    palavra é uma string com pelo menos uma letra.\n",
        "\n",
        "    Retorna uma lista com todas as palavras possíveis que podem ser geradas\n",
        "    a partir da palavra original, através das operações de adicionar, remover\n",
        "    ou trocar uma letra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `filtrar_palavras_reais`\n",
        "\n",
        "```python\n",
        "def filtrar_palavras_reais(lista_palavras, palavras_possiveis):\n",
        "    \"\"\"\n",
        "    lista_palavras é uma lista de strings com palavras em português.\n",
        "    palavras_possiveis é uma lista de palavras possíveis.\n",
        "\n",
        "    Retorna uma lista das palavras possíveis que estão na lista de palavras.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `filtrar_palavras_repetidas`\n",
        "\n",
        "```python\n",
        "def filtrar_palavras_repetidas(palavras_reais):\n",
        "    \"\"\"\n",
        "    palavras_reais é uma lista de strings com palavras em português.\n",
        "\n",
        "    Retorna a lista sem palavras repetidas.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `obter_sugestoes_correcao`\n",
        "\n",
        "```python\n",
        "def obter_sugestoes_correcao(caminho_arquivo, possivel_palavra):\n",
        "    \"\"\"\n",
        "    caminho_arquivo é o nome de um arquivo que tem uma palavra em português por linha.\n",
        "    possivel_palavra é  uma string que pode ser ou não uma palavra real em português.\n",
        "\n",
        "    Retorna a lista de todas as possíveis correções únicas para a possível palavra.\n",
        "    \"\"\"\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## `corretor_ortografico`\n",
        "\n",
        "```python\n",
        "def corretor_ortografico(caminho_arquivo):\n",
        "    \"\"\"\n",
        "    caminho_arquivo é o nome de um arquivo que contém palavras em português.\n",
        "\n",
        "    Pede ao usuário uma palavra e exibe todas as possíveis correções para aquela palavra,\n",
        "    uma por linha."
      ],
      "id": "60b52121"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}