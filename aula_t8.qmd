---
title: Trabalhando com APIs
subtitle: PASIA - Aula T.8
---

##  

O conte√∫do dessa aula √© inspirado no **cap√≠tulo 17** do livro:


![](imagens/livro_curso_intensivo_python.jpg){fig-align="center" fig-alt="Capa do livro de Curso Intensivo de Python." style="max-height: 50vh; width: auto;"}


# Introdu√ß√£o {background-color="#40666e"}

## 

Nesta aula vamos aprender a fazer programas que apresentam visualiza√ß√£o de dados acessados via APIs.

- Usaremos [APIs]{.alert} (_Interfaces de Programa√ß√£o de Aplica√ß√µes_) para **requisitar** 
  automaticamente **informa√ß√µes** espec√≠ficas de um site.
- E usaremos essas informa√ß√µes para gerar visualiza√ß√µes.

. . .

O bacana dessa abordagem √© que sempre que executarmos nossa aplica√ß√£o

- ser√£o utilizados os dados mais recentes dispon√≠veis.

## Usando uma API

Uma API (web) √© a parte de um site desenvolvida para interagir com programas.

- Os programas que acessam uma API usam URLs ("links") bem espec√≠ficas para requisitar
  determinadas informa√ß√µes.
- N√≥s chamamos esse tipo de requisi√ß√£o de [chamada de API]{.alert}.

. . .

Os dados solicitados s√£o retornados em um formato que facilita o processamento.

- Geralmente JSON ou CSV.

##

A maioria das aplica√ß√µes que usa algum tipo de fonte externa de dados,

- como apps que se integram a sites de redes sociais,
- dependem de chamadas de APIs.

. . .

Inclusive, √© muito comum que um app de smartphone ou um site utilize v√°rias
APIs ao mesmo tempo.

# Usando a API do GitHub {background-color="#40666e"}

##

Come√ßaremos com um exemplo de uso da API do GitHub.

- Ela permite a busca de diversas informa√ß√µes relacionadas, por exemplo,
  aos reposit√≥rios da plataforma.

## Requisitando dados atrav√©s de uma chamada de API

. . .

Antes de fazermos chamada de API via c√≥digo, podemos ter uma ideia
do que √© uma chamada dessas acessando o link abaixo no nosso navegador.

- [https://api.github.com/search/repositories?q=language:python+sort:stars](https://api.github.com/search/repositories?q=language:python+sort:stars)
- Essa chamada retorna informa√ß√µes sobre reposit√≥rios Python mais populares atualmente hospedados no GitHub.

. . .

Vamos entender cada parte da URL de requisi√ß√£o.

##

- `https://api.github.com/`: direciona a requisi√ß√£o para a parte do site do GitHub que responde √†s chamadas de API.
- `search/repositories`: instrui a API a realizar uma pesquisa em todos os reposit√≥rios p√∫blicos no GitHub.
  - Cada API pode ter uma ou mais instru√ß√µes dispon√≠veis.
- `?`: indica que vamos passar par√¢metros para a instru√ß√£o.
- `q=`: o _q_ vem de _query_, indicando que vamos fazer uma consulta.
- `language:python`: par√¢metro que indica que queremos apenas os reposit√≥rios cuja linguagem principal seja Python.
- `+sort:stars`: ordena os reposit√≥rios pelo n√∫mero de estrelas recebidas.

##

Quanto ao resultado da requisi√ß√£o, podemos ver que √© retornado um JSON.

- Esse formato facilita o processamento por um programa.
- N√£o √© feito para a leitura direta como estamos fizemos :)

. . .

De todo modo, vamos avaliar pelos menos os campos no primeiro n√≠vel da hierarquia.

##

- `"total_count"`: indica quantos reposit√≥rios atendem aos crit√©rios da busca.
  - No caso √© o total de projetos Python p√∫blicos existentes atualmente no GitHub.
- `"incomplete_results"`: indica se a consulta foi feita de forma completa ou se foi interrompida.
  - Ela pode ser interrompida se a consulta passar de limite de tempo, por exemplo.
  - Isso √© feito para evitar que a API fique sobrecarregada e deixe de responder a todos os usu√°rios.
- `"items"`: 
  - √â a lista com os dados dos reposit√≥rios consultados.

##

Apesar do resultado ser grande, d√° para perceber que n√£o foram retornados os dados
de todos os milh√µes de reposit√≥rios Python.

- Isso porque as APIs geralmente retornam apenas parte dos dados solicitados.
- Para evitar sobrecarregar tanto a API, quanto o programa que est√° fazendo a consulta.
- Cada "parte" retornada √© geralmente chamada de p√°gina e cada p√°gina tem um tamanho padr√£o.

. . .

Assim, a consulta feita retornou apenas a primeira p√°gina de informa√ß√µes.


##

Se quisermos os dados da pr√≥xima p√°gina, podemos passar mais par√¢metros para a requisi√ß√£o.

- Usamos `&` para separar os par√¢metros.
- `page=2`: especifica que queremos a segunda p√°gina.
- `per_page=30`: √© recomend√°vel explicitar quantos itens queremos em cada p√°gina. 
- Portanto a consulta dos dados da segunda p√°gina seria:
  [https://api.github.com/search/repositories?q=language:python+sort:stars&per_page=30&page=2](https://api.github.com/search/repositories?q=language:python+sort:stars&per_page=30&page=2)

##

**Observa√ß√£o importante**:

- A API do GitHub n√£o garante que os resultados s√£o determin√≠sticos.
  - especialmente quando s√£o retornados muitos dados.
- E, claro, se o campo `"incomplete_results"` retornar `true`, chamadas
  sucessivas n√£o ter√£o consist√™ncia garantida.

. . .

**Dica**: use outros par√¢metros para refinar a busca de forma que ela tenha menos
resultados dispon√≠veis no total.

## M√≥dulo Requests

O m√≥dulo `requests` permite que um programa Python fa√ßa requisi√ß√µes em sites.

- Ele n√£o √© um m√≥dulo `built-in` e, portanto, precisa ser instalado.
- Dica: como j√° vimos, o ideal √© criar um ambiente virtual para fazer a instala√ß√£o. 

. . .

Vamos utiliz√°-lo para fazer uma requisi√ß√£o √† API do GitHub.


## Processando uma Resposta de API {auto-animate=true}

::: {.halfincfontsize}
```{.python code-line-numbers="1-5"}
import requests

url = "https://api.github.com/search/repositories"
url += "?q=language:python+sort:stars"
url += "+stars:>50000"
```
:::

- Importamos o m√≥dulo `requests` para fazer requisi√ß√µes HTTP.
- Montamos a URL da API com os par√¢metros de busca.
  - Estamos acrescentando aqui um filtro para s√≥ buscar reposit√≥rios com mais de 50 mil estrelas

## Processando uma Resposta de API {auto-animate=true}

::: {.halfincfontsize}
```{.python code-line-numbers="7"}
import requests

url = "https://api.github.com/search/repositories"
url += "?q=language:python+sort:stars"
url += "+stars:>50000" 

cabecalhos = {"Accept": "application/vnd.github.v3+json"}
```
:::

- Definimos os cabe√ßalhos da requisi√ß√£o especificando:
  - a vers√£o da API.
  - o formato de retorno da resposta

## Processando uma Resposta de API {auto-animate=true}

::: {.halfincfontsize}
```{.python code-line-numbers="8"}
import requests

url = "https://api.github.com/search/repositories"
url += "?q=language:python+sort:stars"
url += "+stars:>50000" 

cabecalhos = {"Accept": "application/vnd.github.v3+json"}
resposta = requests.get(url, headers=cabecalhos)
```
:::

- Fazemos a chamada GET para a API com a URL e os cabe√ßalhos.
- E guardamos a resposta retornada.

## Processando uma Resposta de API {auto-animate=true}

::: {.halfincfontsize}
```{.python code-line-numbers="10"}
import requests

url = "https://api.github.com/search/repositories"
url += "?q=language:python+sort:stars"
url += "+stars:>50000" 

cabecalhos = {"Accept": "application/vnd.github.v3+json"}
resposta = requests.get(url, headers=cabecalhos)

if resposta.status_code == 200:
```
:::

- Verificamos se a requisi√ß√£o foi bem-sucedida.
- Existem diferentes valores que podem ser retornados como, 
  por exemplo: `404` (n√£o encontrado) ou `403` (proibido).

## {auto-animate=true}

::: {.halfincfontsize}
```{.python code-line-numbers="11-12"}
import requests

url = "https://api.github.com/search/repositories"
url += "?q=language:python+sort:stars"
url += "+stars:>50000" 

cabecalhos = {"Accept": "application/vnd.github.v3+json"}
resposta = requests.get(url, headers=cabecalhos)

if resposta.status_code == 200:
  dados = resposta.json()
  print(dados.keys())
```
:::

- Convertemos a resposta JSON em um dicion√°rio Python.
- E mostramos as chaves principais do dicion√°rio retornado.


## Trabalhando com o Dicion√°rio de Resposta

Vamos agora processar os dados que guardamos no dicion√°rio

- acrescentando o seguinte trecho ao c√≥digo anterior:

. . .

```{.python startFrom="14"}
    print(f"Total de reposit√≥rios: {dados['total_count']}")
    print(f"Resultados s√£o completos? {'N√£o' if dados['incomplete_results'] else 'Sim'}")
    print(f"N√∫mero de reposit√≥rios retornados: {len(dados['items'])}\n")

    # Mostra dados do primeiro reposit√≥rio
    repositorio = dados['items'][0]
    print(f"Chaves dispon√≠veis: {len(repositorio)}")
    for chave in sorted(repositorio.keys()):
        print(chave)
```

##

Quando fiz essa consulta, obtive o seguinte resultado.

- Use a barra de rolagem para ver o retorno completo.

```
Total de reposit√≥rios: 69
Resultados s√£o completos? Sim
N√∫mero de reposit√≥rios retornados: 30

Chaves dispon√≠veis: 80
allow_forking
archive_url
archived
assignees_url
blobs_url
branches_url
clone_url
collaborators_url
comments_url
commits_url
compare_url
contents_url
contributors_url
created_at
default_branch
deployments_url
description
disabled
downloads_url
events_url
fork
forks
forks_count
forks_url
full_name
git_commits_url
git_refs_url
git_tags_url
git_url
has_discussions
has_downloads
has_issues
has_pages
has_projects
has_wiki
homepage
hooks_url
html_url
id
is_template
issue_comment_url
issue_events_url
issues_url
keys_url
labels_url
language
languages_url
license
merges_url
milestones_url
mirror_url
name
node_id
notifications_url
open_issues
open_issues_count
owner
private
pulls_url
pushed_at
releases_url
score
size
ssh_url
stargazers_count
stargazers_url
statuses_url
subscribers_url
subscription_url
svn_url
tags_url
teams_url
topics
trees_url
updated_at
url
visibility
watchers
watchers_count
web_commit_signoff_required
```

##

Verificando as chaves retornadas vamos escolher algumas informa√ß√µes
a serem exibidos para o primeiro reposit√≥rio retornado.

. . .

```{.python startFrom="18"}
    repositorio = dados['items'][0]
    print("Primeiro reposit√≥rio:")
    print(f"Nome: {repositorio['name']}")
    print(f"Descri√ß√£o: {repositorio['description']}")
    print(f"Propriet√°rio: {repositorio['owner']['login']}")
    print(f"N√∫mero de estrelas: {repositorio['stargazers_count']}")
    print(f"URL: {repositorio['html_url']}")
```

##

```{.python startFrom="18"}
    repositorio = dados['items'][0]
    print("Primeiro reposit√≥rio:")
    print(f"Nome: {repositorio['name']}")
    print(f"Descri√ß√£o: {repositorio['description']}")
    print(f"Propriet√°rio: {repositorio['owner']['login']}")
    print(f"N√∫mero de estrelas: {repositorio['stargazers_count']}")
    print(f"URL: {repositorio['html_url']}")
```

Resultado:

```{.output}
Primeiro reposit√≥rio:
Nome: free-programming-books
Descri√ß√£o: :books: Freely available programming books
Propriet√°rio: EbookFoundation
N√∫mero de estrelas: 370665
URL: https://github.com/EbookFoundation/free-programming-books
```


## Resumo dos Reposit√≥rios Top

Com o c√≥digo que fizemos conseguimos agora mostrar facilmente as 
informa√ß√µes selecionadas de todos os reposit√≥rios retornados.

. . .

```{.python startFrom="18"}
    print("Informa√ß√µes dos reposit√≥rios retornados:")
    for repositorio in dados['items']:
        print(f"\nNome: {repositorio['name']}")
        print(f"  Descri√ß√£o: {repositorio['description']}")
        print(f"  Propriet√°rio: {repositorio['owner']['login']}")
        print(f"  N√∫mero de estrelas: {repositorio['stargazers_count']}")
        print(f"  URL: {repositorio['html_url']}")
```

## Monitorando Limites de Requisi√ß√µes da API

A maioria das APIs p√∫blicas imp√µe limites de requisi√ß√µes.

- ou seja, um n√∫mero m√°ximo de chamadas que podem ser feitas em um determinado per√≠odo de tempo.
- Isso √© feito para evitar que a API fique sobrecarregada e deixe de responder a todos os usu√°rios.

. . .

No caso da API do GitHub, podemos consultar esses limites pelo seguinte link:

- [https://api.github.com/rate_limit](https://api.github.com/rate_limit)

##

Se fizermos muitas consultas consecutivas, podemos receber uma mensagem de erro

- A mensagem indica que atingimos o limite de requisi√ß√µes.
- Nesse caso, precisamos aguardar um tempo antes de fazer novas requisi√ß√µes.

. . .

::: {.callout-tip}
Muitas APIs exigem o registro e obten√ß√£o de uma chave de API ou token de acesso
para fazer chamadas de API.

No caso do GitHub, podemos fazer chamadas sem autentica√ß√£o.
Mas, usando autentica√ß√£o, podemos fazer um n√∫mero maior de requisi√ß√µes.
:::

# Visualizando dados do GitHub com Plotly {background-color="#40666e"}

## Gr√°fico b√°sico com os reposit√≥rios

Vamos, com ajuda do Copilot, criar um gr√°fico com os dados que obtivemos.

::: {.callout-caution title="Prompt" icon="false"}
::: {.halfincfontsize}
```python
# Exibe gr√°fico no plotly mostrando os nomes dos reposit√≥rios no eixo x 
# e o n√∫mero de estrelas no eixo y
```
:::
:::

. . .

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
::: {.halfincfontsize}
```{.python code-line-numbers="false"}
    import plotly.express as px
    
    nomes = [item['name'] for item in dados['items']]
    estrelas = [item['stargazers_count'] for item in dados['items']]
    fig = px.bar(x=nomes, y=estrelas, labels={'x': 'Reposit√≥rio', 'y': 'Estrelas'},
                 title='Reposit√≥rios Python mais populares no GitHub')
    fig.show()
```
:::
:::

##

Observa√ß√£o:

- Para executar o c√≥digo gerado, foi necess√°rio instalar os m√≥dulos abaixo
  no ambiente virtual:
  
  ```text
  plotly[express]
  pandas
  ```

##

![](imagens/api_github_repo_pop.png){fig-align="center"}

## Customizando tooltip

Vamos agora customizar as _tooltips_ do gr√°fico.

- S√£o as informa√ß√µes que aparecem quando passamos o mouse sobre as barras do gr√°fico.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Altere as tooltips do gr√°fico para mostrar a descri√ß√£o e o propriet√°rio do reposit√≥rio
junto com o n√∫mero de estrelas.
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
::: {.halfincfontsize}
```{.python code-line-numbers="false"}
nomes = [item['name'] for item in dados['items']]
    estrelas = [item['stargazers_count'] for item in dados['items']]
    descricoes = [item['description'] for item in dados['items']]
    proprietarios = [item['owner']['login'] for item in dados['items']]

    fig = px.bar(
        x=nomes,
        y=estrelas,
        labels={'x': 'Reposit√≥rio', 'y': 'Estrelas'},
        title='Reposit√≥rios Python mais populares no GitHub',
        hover_data={
            'Descri√ß√£o': descricoes,
            'Propriet√°rio': proprietarios,
            'Estrelas': estrelas
        }
    )
    fig.show()
```
:::
:::

##

![](imagens/api_github_repo_pop_tooltip.png){fig-align="center"}

## Adicionando links clic√°veis

O Plotly permite o uso de HTML nos seus textos.

- Com isso, podemos transformar os nomes dos reposit√≥rios em links clic√°veis.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Altere os nomes dos reposit√≥rios no eixo x para que sejam links clic√°veis
que direcionem para a p√°gina do reposit√≥rio no GitHub.
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
```{.python code-line-numbers="false"}
    nomes = [item['name'] for item in dados['items']]
    estrelas = [item['stargazers_count'] for item in dados['items']]
    descricoes = [item['description'] for item in dados['items']]
    proprietarios = [item['owner']['login'] for item in dados['items']]
    urls = [item['html_url'] for item in dados['items']]

    # Cria nomes como links HTML
    nomes_links = [f'<a href="{url}">{nome}</a>' for nome, url in zip(nomes, urls)]

    fig = px.bar(
        x=nomes_links,
        y=estrelas,
        labels={'x': 'Reposit√≥rio', 'y': 'Estrelas'},
        title='Reposit√≥rios Python mais populares no GitHub',
        hover_data={
            'Descri√ß√£o': descricoes,
            'Propriet√°rio': proprietarios,
            'Estrelas': estrelas
        }
    )
    fig.update_xaxes(tickfont=dict(size=10), tickmode='array', tickvals=nomes_links, ticktext=nomes_links)
    fig.update_layout(xaxis_tickangle=-45)
    fig.update_traces(hovertemplate='<b>%{x}</b><br>Estrelas: %{y}<extra></extra>', selector=dict(type='bar'))
    fig.show()
```
:::


# Usando API de Nomes do IBGE {background-color="#40666e"}

##

Vamos agora passar a outro exemplo.

- O IBGE possui diversas APIs p√∫blicas, com informa√ß√µes interessantes.
- Uma delas √© a API de Nomes, que disponibiliza dados sobre a frequ√™ncia de nomes no Brasil.

## Documenta√ß√£o e Copilot

Para usar uma API, podemos consultar sua documenta√ß√£o.

- Al√©m, √© claro, de usar Assistentes de IA para ajudar a escrever o c√≥digo.
- A documenta√ß√£o da API citada est√° dispon√≠vel no link abaixo:
  [https://servicodados.ibge.gov.br/api/docs/nomes?versao=2](https://servicodados.ibge.gov.br/api/docs/nomes?versao=2).


## Consultando ranking dos nomes mais comuns

Vamos ent√£o usar o Copilot para criar um c√≥digo que:

- consulte o ranking dos nomes mais comuns
- e exiba o resultado em um gr√°fico usando plotly.

. . . 

::: {.callout-caution title="Prompt" icon="false"}
Gostaria de gerar um gr√°fico usando Plotly que mostrasse o ranking dos nomes mais comuns no Brasil. Essa informa√ß√£o pode ser obtida da API do IBGE, dispon√≠vel no link https://servicodados.ibge.gov.br/api/docs/nomes?versao=2
:::

##

```python
import requests
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd

def obter_ranking_nomes(limite=20):
    """
    Obt√©m o ranking dos nomes mais comuns no Brasil usando a API do IBGE
    
    Args:
        limite (int): N√∫mero de nomes para exibir no ranking
        
    Returns:
        pd.DataFrame: DataFrame com os nomes e suas frequ√™ncias
    """
    try:
        # URL da API do IBGE para ranking de nomes
        url = f"https://servicodados.ibge.gov.br/api/v2/censos/nomes/ranking?qtd={limite}"
        
        # Fazendo a requisi√ß√£o
        response = requests.get(url)
        response.raise_for_status()  # Levanta exce√ß√£o se houver erro HTTP
        
        # Convertendo para JSON
        dados = response.json()
        
        # Extraindo nomes e frequ√™ncias
        nomes = []
        frequencias = []
        
        for item in dados[0]['res']:  # dados[0]['res'] cont√©m a lista de nomes
            nomes.append(item['nome'])
            frequencias.append(item['freq'])
        
        # Criando DataFrame
        df = pd.DataFrame({
            'Nome': nomes,
            'Frequ√™ncia': frequencias,
            'Posi√ß√£o': range(1, len(nomes) + 1)
        })
        
        return df
        
    except requests.exceptions.RequestException as e:
        print(f"Erro ao acessar a API: {e}")
        return None
    except KeyError as e:
        print(f"Erro ao processar dados da API: {e}")
        return None

def criar_grafico_ranking(df, titulo="Ranking dos Nomes Mais Comuns no Brasil"):
    """
    Cria gr√°fico de barras horizontais com o ranking dos nomes
    
    Args:
        df (pd.DataFrame): DataFrame com os dados dos nomes
        titulo (str): T√≠tulo do gr√°fico
        
    Returns:
        plotly.graph_objects.Figure: Figura do Plotly
    """
    # Ordenando por frequ√™ncia (decrescente) para garantir ordem correta
    df_ordenado = df.sort_values('Frequ√™ncia', ascending=True)  # True para barras horizontais
    
    # Criando gr√°fico de barras horizontais
    fig = px.bar(
        df_ordenado,
        x='Frequ√™ncia',
        y='Nome',
        orientation='h',
        title=titulo,
        labels={'Frequ√™ncia': 'N√∫mero de Pessoas', 'Nome': 'Nome'},
        color='Frequ√™ncia',
        color_continuous_scale='viridis',
        text='Frequ√™ncia'
    )
    
    # Personalizando o layout
    fig.update_layout(
        height=600,
        width=1000,
        title_font_size=16,
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        showlegend=False,
        title_x=0.5  # Centraliza o t√≠tulo
    )
    
    # Personalizando as barras
    fig.update_traces(
        texttemplate='%{text:,.0f}',  # Formato dos n√∫meros
        textposition='outside',
        marker_line_color='rgba(0,0,0,0.3)',
        marker_line_width=1
    )
    
    # Ajustando eixos
    fig.update_xaxes(tickformat=',.0f')  # Formato dos n√∫meros no eixo X
    
    return fig

def criar_grafico_top10(df):
    """
    Cria um gr√°fico circular (pizza) com os top 10 nomes
    
    Args:
        df (pd.DataFrame): DataFrame com os dados dos nomes
        
    Returns:
        plotly.graph_objects.Figure: Figura do Plotly
    """
    # Pegando apenas os top 10
    df_top10 = df.head(10)
    
    fig = px.pie(
        df_top10,
        values='Frequ√™ncia',
        names='Nome',
        title='Top 10 Nomes Mais Comuns no Brasil',
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    
    fig.update_traces(
        textposition='inside',
        textinfo='percent+label',
        hovertemplate='<b>%{label}</b><br>Pessoas: %{value:,.0f}<br>Percentual: %{percent}<extra></extra>'
    )
    
    fig.update_layout(
        title_font_size=16,
        title_x=0.5,
        height=600,
        width=800
    )
    
    return fig

def main():
    """Fun√ß√£o principal que executa o programa"""
    print("Buscando dados dos nomes mais comuns no Brasil...")
    
    # Obtendo os dados
    df_nomes = obter_ranking_nomes(limite=25)
    
    if df_nomes is not None:
        print(f"‚úÖ Dados obtidos com sucesso! {len(df_nomes)} nomes encontrados.\n")
        
        # Exibindo os primeiros 10 nomes
        print("üèÜ Top 10 Nomes Mais Comuns:")
        print("-" * 40)
        for idx, row in df_nomes.head(10).iterrows():
            print(f"{row['Posi√ß√£o']:2d}¬∫ - {row['Nome']:<15} ({row['Frequ√™ncia']:,} pessoas)")
        
        # Criando e exibindo gr√°fico de barras
        print("\nüìä Gerando gr√°fico de barras...")
        fig_barras = criar_grafico_ranking(df_nomes)
        fig_barras.show()
        
        # Criando e exibindo gr√°fico de pizza
        print("ü•ß Gerando gr√°fico de pizza...")
        fig_pizza = criar_grafico_top10(df_nomes)
        fig_pizza.show()
        
        # Salvando os gr√°ficos (opcional)
        print("\nüíæ Salvando gr√°ficos...")
        fig_barras.write_html("ranking_nomes_barras.html")
        fig_pizza.write_html("ranking_nomes_pizza.html")
        print("Gr√°ficos salvos como 'ranking_nomes_barras.html' e 'ranking_nomes_pizza.html'")
        
    else:
        print("‚ùå Erro ao obter dados da API do IBGE.")

if __name__ == "__main__":
    main()
```

##

O c√≥digo gerado deu erro na linha 33:

- indicando que a chave `'freq'` n√£o existia no dicion√°rio de resposta.

```{.python startFrom="33"}
            frequencias.append(item['freq'])
```

. . .

Usei o depurador do VSCode para inspecionar o conte√∫do de `item`.

- E percebi que a chave correta era `'frequencia'`.

. . .

```{.python startFrom="33"}
            frequencias.append(item['frequencia'])
```

##

O c√≥digo gerado foi bem completo.

- Inclusive foram gerados dois gr√°ficos em vez de apenas um como eu tinha pedido.

. . . 

Talvez porque eu estava usando o `Cladue Sonnet 4` como modelo no Copilot.

- Em vez do `GPT-4.1` que eu vinha usando at√© ent√£o.

##

![](imagens/api_ibge_ranking_nomes_barras.png){fig-align="center"}


##

![](imagens/api_ibge_ranking_nomes_pizza.png){fig-align="center"}

## Consultando frequ√™ncia de um nome

A API do IBGE tamb√©m permite consultar a frequ√™ncia de um nome espec√≠fico.

- Vamos criar outro programa agora para fazer essa consulta.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Gostaria de um programa em Python que consultasse a frequ√™ncia de um nome espec√≠fico no Brasil usando a API do IBGE. O programa deve solicitar ao usu√°rio que digite um nome e, em seguida, exibir a frequ√™ncia desse nome ao longo dos anos em um gr√°fico usando Plotly.
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
```python
import requests
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd

def obter_frequencia_nome(nome):
    """
    Obt√©m a frequ√™ncia de um nome espec√≠fico ao longo dos anos usando a API do IBGE
    
    Args:
        nome (str): Nome para consultar
        
    Returns:
        tuple: (pd.DataFrame, dict) DataFrame com dados anuais e dict com informa√ß√µes gerais
    """
    try:
        # URL da API do IBGE para consulta de nome espec√≠fico
        url = f"https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nome}"
        
        # Fazendo a requisi√ß√£o
        response = requests.get(url)
        response.raise_for_status()
        
        # Convertendo para JSON
        dados = response.json()
        
        if not dados or len(dados) == 0:
            return None, None
            
        # Extraindo informa√ß√µes gerais
        info_geral = {
            'nome': dados[0]['nome'],
            'sexo': dados[0].get('sexo', 'N√£o informado'),
            'localidade': dados[0]['localidade'],
            'frequencia_total': dados[0]['freq']
        }
        
        # Extraindo dados por d√©cada/per√≠odo
        anos = []
        frequencias = []
        
        for item in dados[0]['res']:
            anos.append(item['periodo'])
            frequencias.append(item['frequencia'])
        
        # Criando DataFrame
        df = pd.DataFrame({
            'Per√≠odo': anos,
            'Frequ√™ncia': frequencias
        })
        
        # Ordenando por per√≠odo
        df = df.sort_values('Per√≠odo')
        
        return df, info_geral
        
    except requests.exceptions.RequestException as e:
        print(f"Erro ao acessar a API: {e}")
        return None, None
    except (KeyError, IndexError) as e:
        print(f"Nome n√£o encontrado ou erro ao processar dados: {e}")
        return None, None

def criar_grafico_linha_temporal(df, info_geral):
    """
    Cria gr√°fico de linha mostrando a evolu√ß√£o da frequ√™ncia do nome ao longo do tempo
    
    Args:
        df (pd.DataFrame): DataFrame com dados temporais
        info_geral (dict): Informa√ß√µes gerais do nome
        
    Returns:
        plotly.graph_objects.Figure: Figura do Plotly
    """
    nome = info_geral['nome']
    
    fig = px.line(
        df,
        x='Per√≠odo',
        y='Frequ√™ncia',
        title=f'Evolu√ß√£o da Frequ√™ncia do Nome "{nome}" no Brasil',
        markers=True,
        line_shape='linear'
    )
    
    # Personalizando a linha
    fig.update_traces(
        line=dict(color='#1f77b4', width=3),
        marker=dict(size=8, color='#ff7f0e'),
        hovertemplate='<b>Per√≠odo:</b> %{x}<br><b>Nascimentos:</b> %{y:,.0f}<extra></extra>'
    )
    
    # Personalizando o layout
    fig.update_layout(
        height=500,
        width=1000,
        title_font_size=16,
        xaxis_title="Per√≠odo (D√©cada)",
        yaxis_title="N√∫mero de Nascimentos",
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_x=0.5,
        hovermode='x unified',
        plot_bgcolor='white',
        paper_bgcolor='white'
    )
    
    # Personalizando eixos
    fig.update_xaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor='lightgray',
        tickformat='d'
    )
    
    fig.update_yaxes(
        showgrid=True,
        gridwidth=1,
        gridcolor='lightgray',
        tickformat=',.0f'
    )
    
    # Adicionando anota√ß√£o com total
    total = info_geral['frequencia_total']
    fig.add_annotation(
        text=f"Total de pessoas com este nome: {total:,}",
        xref="paper", yref="paper",
        x=0.02, y=0.98,
        showarrow=False,
        font=dict(size=12, color="black"),
        bgcolor="rgba(255,255,255,0.8)",
        bordercolor="gray",
        borderwidth=1
    )
    
    return fig

def criar_grafico_barras_decadas(df, info_geral):
    """
    Cria gr√°fico de barras por d√©cada
    
    Args:
        df (pd.DataFrame): DataFrame com dados temporais
        info_geral (dict): Informa√ß√µes gerais do nome
        
    Returns:
        plotly.graph_objects.Figure: Figura do Plotly
    """
    nome = info_geral['nome']
    
    # Criando gr√°fico de barras
    fig = px.bar(
        df,
        x='Per√≠odo',
        y='Frequ√™ncia',
        title=f'Distribui√ß√£o por D√©cada - Nome "{nome}"',
        color='Frequ√™ncia',
        color_continuous_scale='viridis',
        text='Frequ√™ncia'
    )
    
    # Personalizando as barras
    fig.update_traces(
        texttemplate='%{text:,.0f}',
        textposition='outside',
        hovertemplate='<b>D√©cada:</b> %{x}<br><b>Nascimentos:</b> %{y:,.0f}<extra></extra>'
    )
    
    # Personalizando layout
    fig.update_layout(
        height=500,
        width=1000,
        title_font_size=16,
        xaxis_title="D√©cada",
        yaxis_title="N√∫mero de Nascimentos",
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_x=0.5,
        showlegend=False,
        plot_bgcolor='white'
    )
    
    fig.update_xaxes(tickformat='d')
    fig.update_yaxes(tickformat=',.0f')
    
    return fig

def exibir_estatisticas(df, info_geral):
    """
    Exibe estat√≠sticas resumidas do nome
    
    Args:
        df (pd.DataFrame): DataFrame com dados temporais
        info_geral (dict): Informa√ß√µes gerais do nome
    """
    nome = info_geral['nome']
    total = info_geral['frequencia_total']
    
    print(f"\nüìä ESTAT√çSTICAS DO NOME '{nome.upper()}'")
    print("=" * 50)
    print(f"üèÜ Total de pessoas: {total:,}")
    print(f"üìÖ Per√≠odos dispon√≠veis: {len(df)} d√©cadas")
    print(f"üîù D√©cada com mais nascimentos: {df.loc[df['Frequ√™ncia'].idxmax(), 'Per√≠odo']}")
    print(f"üìà Maior frequ√™ncia: {df['Frequ√™ncia'].max():,} nascimentos")
    print(f"üìâ Menor frequ√™ncia: {df['Frequ√™ncia'].min():,} nascimentos")
    print(f"üìä M√©dia por d√©cada: {df['Frequ√™ncia'].mean():,.0f} nascimentos")
    
    print(f"\nüìã DISTRIBUI√á√ÉO POR D√âCADA:")
    print("-" * 30)
    for _, row in df.iterrows():
        percentual = (row['Frequ√™ncia'] / total) * 100
        print(f"{row['Per√≠odo']}: {row['Frequ√™ncia']:7,} ({percentual:4.1f}%)")

def main():
    """Fun√ß√£o principal que executa o programa"""
    print("üîç CONSULTA DE FREQU√äNCIA DE NOMES NO BRASIL")
    print("=" * 50)
    print("Digite um nome para consultar sua frequ√™ncia ao longo dos anos.")
    print("Exemplos: Maria, Jo√£o, Ana, Carlos, etc.")
    print("-" * 50)
    
    while True:
        # Solicitando nome ao usu√°rio
        nome = input("\nüìù Digite o nome que deseja consultar (ou 'sair' para encerrar): ").strip()
        
        if nome.lower() == 'sair':
            print("üëã Encerrando programa...")
            break
            
        if not nome:
            print("‚ùå Por favor, digite um nome v√°lido.")
            continue
            
        print(f"\nüîé Buscando informa√ß√µes sobre o nome '{nome}'...")
        
        # Obtendo dados da API
        df_temporal, info_geral = obter_frequencia_nome(nome)
        
        if df_temporal is not None and info_geral is not None:
            print("‚úÖ Dados encontrados!")
            
            # Exibindo estat√≠sticas
            exibir_estatisticas(df_temporal, info_geral)
            
            # Criando e exibindo gr√°ficos
            print("\nüìä Gerando gr√°ficos...")
            
            # Gr√°fico de linha temporal
            fig_linha = criar_grafico_linha_temporal(df_temporal, info_geral)
            fig_linha.show()
            
            # Gr√°fico de barras por d√©cada
            fig_barras = criar_grafico_barras_decadas(df_temporal, info_geral)
            fig_barras.show()
            
            # Op√ß√£o de salvar gr√°ficos
            salvar = input("\nüíæ Deseja salvar os gr√°ficos? (s/n): ").lower()
            if salvar == 's':
                nome_arquivo = nome.lower().replace(' ', '_')
                fig_linha.write_html(f"{nome_arquivo}_linha_temporal.html")
                fig_barras.write_html(f"{nome_arquivo}_barras_decadas.html")
                print(f"‚úÖ Gr√°ficos salvos como '{nome_arquivo}_linha_temporal.html' e '{nome_arquivo}_barras_decadas.html'")
            
        else:
            print(f"‚ùå Nome '{nome}' n√£o encontrado na base de dados do IBGE.")
            print("üí° Dica: Verifique a grafia ou tente varia√ß√µes do nome.")
        
        # Perguntando se deseja continuar
        continuar = input("\nüîÑ Deseja consultar outro nome? (s/n): ").lower()
        if continuar != 's':
            print("üëã Encerrando programa...")
            break

if __name__ == "__main__":
    main()
```
:::

##

O c√≥digo gerado mais uma vez foi muito completo.

- E mais uma vez gerou erro, mas agora um pouco mais complicado.

. . .

O erro ocorreu na linha 35:

```{.python startFrom="35"}
    'frequencia_total': dados[0]['freq']
```

. . .

Experimentei mudar para `frequencia` mas n√£o resolveu.

- E depurei o c√≥digo e vi que n√£o tinha essa informa√ß√£o.

##

Pedi ent√£o ao Copilot para corrigir o erro.

. . .

::: {.callout-caution title="Prompt" icon="false"}
`/fix` n√£o h√° um campo com informa√ß√£o de frequ√™ncia total nos dados retornados.
:::

. . .

A resposta do Copilot modificou o c√≥digo para somar as frequ√™ncias de cada d√©cada.

- E considerar isso como a frequ√™ncia total.
- Mas isso faz sentido?

##

Isso n√£o faz sentido, pois a mesma pessoa seria contada v√°rias vezes.

. . .

Experimentei comentar a linha, mas isso causava outros problemas no c√≥digo.

- Inclusive percebi que esse total era usado para calcular a frequ√™ncia relativa de um nome.
- Mas isso n√£o era correto.

##

::: {.callout-warning}
## Fica a dica!

Cuidado com respostas de Assistentes de IA.

Precisamos saber o que queremos em vez de simplesmente entrar em um ciclo de
pedir corre√ß√µes.

Nesse caso, a solu√ß√£o n√£o fazia sentido com o que eu estava solicitando.
:::

##

Tentei ent√£o pedir ao Copilot para remover completamente o tratamento
referente a uma frequ√™ncia total.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Os dados retornados n√£o possuem uma frequ√™ncia total e n√£o faz sentido calcular a soma das frequ√™ncias de cada d√©cada como uma frequ√™ncia total. Remova qualquer refer√™ncia a uma frequ√™ncia total. Quero apenas um gr√°fico simples, de barras, que mostre a frequ√™ncia do nome escolhido a cada d√©cada.
:::

. . .

E a√≠ funcionou!

##


::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
```python
import requests
import plotly.express as px
import pandas as pd

def obter_frequencia_nome(nome):
    """
    Obt√©m a frequ√™ncia de um nome espec√≠fico ao longo dos anos usando a API do IBGE
    
    Args:
        nome (str): Nome para consultar
        
    Returns:
        tuple: (pd.DataFrame, dict) DataFrame com dados anuais e dict com informa√ß√µes gerais
    """
    try:
        # URL da API do IBGE para consulta de nome espec√≠fico
        url = f"https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nome}"
        
        # Fazendo a requisi√ß√£o
        response = requests.get(url)
        response.raise_for_status()
        
        # Convertendo para JSON
        dados = response.json()
        
        if not dados or len(dados) == 0:
            return None, None
            
        # Extraindo informa√ß√µes gerais
        info_geral = {
            'nome': dados[0]['nome'],
            'sexo': dados[0].get('sexo', 'N√£o informado'),
            'localidade': dados[0]['localidade']
        }
        
        # Extraindo dados por d√©cada/per√≠odo
        anos = []
        frequencias = []
        
        for item in dados[0]['res']:
            anos.append(item['periodo'])
            frequencias.append(item['frequencia'])
        
        # Criando DataFrame
        df = pd.DataFrame({
            'Per√≠odo': anos,
            'Frequ√™ncia': frequencias
        })
        
        # Ordenando por per√≠odo
        df = df.sort_values('Per√≠odo')
        
        return df, info_geral
        
    except requests.exceptions.RequestException as e:
        print(f"Erro ao acessar a API: {e}")
        return None, None
    except (KeyError, IndexError) as e:
        print(f"Nome n√£o encontrado ou erro ao processar dados: {e}")
        return None, None

def criar_grafico_barras_decadas(df, info_geral):
    """
    Cria gr√°fico de barras por d√©cada
    
    Args:
        df (pd.DataFrame): DataFrame com dados temporais
        info_geral (dict): Informa√ß√µes gerais do nome
        
    Returns:
        plotly.graph_objects.Figure: Figura do Plotly
    """
    nome = info_geral['nome']
    
    # Criando gr√°fico de barras
    fig = px.bar(
        df,
        x='Per√≠odo',
        y='Frequ√™ncia',
        title=f'Frequ√™ncia do Nome "{nome}" por D√©cada no Brasil',
        color='Frequ√™ncia',
        color_continuous_scale='viridis',
        text='Frequ√™ncia'
    )
    
    # Personalizando as barras
    fig.update_traces(
        texttemplate='%{text:,.0f}',
        textposition='outside',
        hovertemplate='<b>D√©cada:</b> %{x}<br><b>Nascimentos:</b> %{y:,.0f}<extra></extra>'
    )
    
    # Personalizando layout
    fig.update_layout(
        height=500,
        width=1000,
        title_font_size=16,
        xaxis_title="D√©cada",
        yaxis_title="N√∫mero de Nascimentos",
        xaxis_title_font_size=14,
        yaxis_title_font_size=14,
        title_x=0.5,
        showlegend=False,
        plot_bgcolor='white'
    )
    
    fig.update_xaxes(tickformat='d')
    fig.update_yaxes(tickformat=',.0f')
    
    return fig

def exibir_estatisticas(df, info_geral):
    """
    Exibe estat√≠sticas resumidas do nome
    
    Args:
        df (pd.DataFrame): DataFrame com dados temporais
        info_geral (dict): Informa√ß√µes gerais do nome
    """
    nome = info_geral['nome']
    
    print(f"\nüìä ESTAT√çSTICAS DO NOME '{nome.upper()}'")
    print("=" * 50)
    print(f"üìÖ Per√≠odos dispon√≠veis: {len(df)} d√©cadas")
    print(f"üîù D√©cada com mais nascimentos: {df.loc[df['Frequ√™ncia'].idxmax(), 'Per√≠odo']}")
    print(f"üìà Maior frequ√™ncia: {df['Frequ√™ncia'].max():,} nascimentos")
    print(f"üìâ Menor frequ√™ncia: {df['Frequ√™ncia'].min():,} nascimentos")
    print(f"üìä M√©dia por d√©cada: {df['Frequ√™ncia'].mean():,.0f} nascimentos")
    
    print(f"\nüìã DISTRIBUI√á√ÉO POR D√âCADA:")
    print("-" * 30)
    for _, row in df.iterrows():
        print(f"{row['Per√≠odo']}: {row['Frequ√™ncia']:7,} nascimentos")

def main():
    """Fun√ß√£o principal que executa o programa"""
    print("üîç CONSULTA DE FREQU√äNCIA DE NOMES NO BRASIL")
    print("=" * 50)
    print("Digite um nome para consultar sua frequ√™ncia ao longo dos anos.")
    print("Exemplos: Maria, Jo√£o, Ana, Carlos, etc.")
    print("-" * 50)
    
    while True:
        # Solicitando nome ao usu√°rio
        nome = input("\nüìù Digite o nome que deseja consultar (ou 'sair' para encerrar): ").strip()
        
        if nome.lower() == 'sair':
            print("üëã Encerrando programa...")
            break
            
        if not nome:
            print("‚ùå Por favor, digite um nome v√°lido.")
            continue
            
        print(f"\nüîé Buscando informa√ß√µes sobre o nome '{nome}'...")
        
        # Obtendo dados da API
        df_temporal, info_geral = obter_frequencia_nome(nome)
        
        if df_temporal is not None and info_geral is not None:
            print("‚úÖ Dados encontrados!")
            
            # Exibindo estat√≠sticas
            exibir_estatisticas(df_temporal, info_geral)
            
            # Criando e exibindo gr√°fico
            print("\nüìä Gerando gr√°fico...")
            
            # Gr√°fico de barras por d√©cada
            fig_barras = criar_grafico_barras_decadas(df_temporal, info_geral)
            fig_barras.show()
            
            # Op√ß√£o de salvar gr√°fico
            salvar = input("\nüíæ Deseja salvar o gr√°fico? (s/n): ").lower()
            if salvar == 's':
                nome_arquivo = nome.lower().replace(' ', '_')
                fig_barras.write_html(f"{nome_arquivo}_frequencia_decadas.html")
                print(f"‚úÖ Gr√°fico salvo como '{nome_arquivo}_frequencia_decadas.html'")
            
        else:
            print(f"‚ùå Nome '{nome}' n√£o encontrado na base de dados do IBGE.")
            print("üí° Dica: Verifique a grafia ou tente varia√ß√µes do nome.")
        
        # Perguntando se deseja continuar
        continuar = input("\nüîÑ Deseja consultar outro nome? (s/n): ").lower()
        if continuar != 's':
            print("üëã Encerrando programa...")
            break

if __name__ == "__main__":
    main()
```
:::

##

![](imagens/api_ibge_nome_maria.png){fig-align="center"}

##

![](imagens/api_ibge_nome_julio.png){fig-align="center"}


## Verificando por munic√≠pio

Para finalizar, os exemplos com a API de nomes do IBGE, podemos verificar a frequ√™ncia de um nome por munic√≠pio.

- A API permite essa consulta, mas exige o c√≥digo do munic√≠pio.
- Esses c√≥digos podem ser obtidos na API de munic√≠pios do IBGE.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Gostaria de um programa em Python que consultasse a frequ√™ncia de um nome espec√≠fico em um munic√≠pio do Brasil usando a API do IBGE. 
O programa deve solicitar ao usu√°rio que digite um nome e um munic√≠pio. 
Em seguida, deve usar a API do IBGE para descobrir o c√≥digo do munic√≠pio 
e ent√£o seguida exibir a frequ√™ncia desse nome no munic√≠pio em um gr√°fico usando Plotly.
:::

##

Dessa vez eu mudei o modelo do Copilot para o `GPT-4.1`.

- Meu objetivo foi comparar o tipo de resposta com o modelo `Claude Sonnet 4` que eu vinha usando.
- Obs.: note que eu n√£o forneci o link da documenta√ß√£o da API dessa vez.

. . . 

Como ver√° no c√≥digo a seguir, o c√≥digo gerado foi bem mais sucinto.

- Foi direto ao ponto sobre o que eu tinha solicitado.

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
```python
import requests
import plotly.graph_objects as go

def buscar_codigo_municipio(nome_municipio):
    url = f"https://servicodados.ibge.gov.br/api/v1/localidades/municipios"
    resposta = requests.get(url)
    municipios = resposta.json()
    for municipio in municipios:
        if municipio['nome'].lower() == nome_municipio.lower():
            return municipio['id']
    return None

def buscar_frequencia_nome(nome, codigo_municipio):
    url = f"https://servicodados.ibge.gov.br/api/v2/censos/nomes/{nome}?localidade={codigo_municipio}"
    resposta = requests.get(url)
    if resposta.status_code == 200 and resposta.json():
        return resposta.json()[0]['res']
    return []

def main():
    nome = input("Digite o nome a ser pesquisado: ").strip()
    municipio = input("Digite o nome do munic√≠pio: ").strip()

    codigo = buscar_codigo_municipio(municipio)
    if not codigo:
        print("Munic√≠pio n√£o encontrado.")
        return

    frequencias = buscar_frequencia_nome(nome, codigo)
    if not frequencias:
        print("Nome n√£o encontrado ou sem dados para este munic√≠pio.")
        return

    periodos = [item['periodo'] for item in frequencias]
    valores = [item['frequencia'] for item in frequencias]

    fig = go.Figure([go.Bar(x=periodos, y=valores)])
    fig.update_layout(title=f"Frequ√™ncia do nome '{nome}' em {municipio}",
                     xaxis_title="Per√≠odo",
                     yaxis_title="Frequ√™ncia")
    fig.show()

if __name__ == "__main__":
    main()
```
:::

##

![](imagens/api_ibge_nome_municipio.png){fig-align="center"}

# Usando API da FIPE {background-color="#40666e"}

## 

Para fechar os exemplos de uso de API da aula, vamos ver um exemplo com a API da FIPE.

- A API da FIPE disponibiliza dados sobre pre√ßos de ve√≠culos no Brasil.

. . .

Mas, dessa vez, segui uma abordagem diferente.

- Em vez de consultar a documenta√ß√£o da API antes e planejar o que o programa faria, 
- eu tive conversa explorat√≥ria com o Copilot e meio _vibe coding_ mesmo.
  - A ideia foi explorar possibilidades.

##

Eu criei um projeto vazio no VS Code.

- E usei o Copilot com o modelo `GPT-4.1` no modo `Ask`.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Eu gostaria de usar a API da FIPE para consultar dados sobre ve√≠culos no Brasil. Que tipo de informa√ß√µes eu posso obter dessa API?
:::

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
A API da FIPE permite consultar diversas informa√ß√µes sobre ve√≠culos no Brasil, como:

- Marcas de carros, motos e caminh√µes
- Modelos dispon√≠veis para cada marca
- Anos/modelos de fabrica√ß√£o
- Pre√ßo m√©dio de mercado (valor FIPE) para cada ve√≠culo
- Tipo de combust√≠vel
- C√≥digo FIPE do ve√≠culo
- Informa√ß√µes sobre atualiza√ß√µes de pre√ßos

Esses dados s√£o √∫teis para consultas de valores de compra, venda, seguros e avalia√ß√µes de ve√≠culos.
:::

##

Resolvi ent√£o pedir ao Copilot para criar um programa que usasse a API.

- O mais recomendado seria continuar explorando em mais detalhes,
  mas tentei ir direto ao ponto.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Gostaria de criar um programa Python no qual eu informasse o nome de um modelo de Carro e o programa me informasse o pre√ßo atual desse modelo em Minas Gerais. 
:::

##

O Copilot gerou uma sugest√£o de estrutura de projeto completa como resposta.

- Incluindo `requirements.txt` e um arquivo `README.md`.

. . .

![](imagens/copilot_app_fipe.png){fig-align="center"}

##

Mas, para a minha decep√ß√£o, o c√≥digo gerado era apenas um esqueleto.

- N√£o fazia nenhuma chamada real √† API da FIPE.

. . .

```python
def get_car_price(car_model):
    # This function simulates fetching the car price from a database or an API.
    # In a real application, you would replace this with actual data fetching logic.
    car_prices = {
        "Fusca": 30000,
        "Civic": 120000,
        "Corolla": 115000,
        "Onix": 70000,
        "HB20": 75000
    }
    return car_prices.get(car_model, "Model not found")

def main():
    car_model = input("Enter the car model: ")
    price = get_car_price(car_model)
    print(f"The current price of {car_model} in Minas Gerais is: {price}")

if __name__ == "__main__":
    main()
```

##

Esse print n√£o mostra o estado real da resposta do Copilot.

:::: {.columns}

::: {.column width="50%"}
![](imagens/copilot_app_fipe.png){fig-align="center"}
:::

::: {.column width="50%"}
Por que na hora que ela apareceu, logo √† frente de _Workspace_, tinha um link:

- `rerun wihtot`: que significa refazer a pergunta sem usar o agente `@workspace`.
- Usei essa op√ß√£o e a√≠ a resposta foi bem diferente.
:::

::::

##

::: {.callout-note title="GitHub Copilot (in√≠cio)" icon="false" .nonincremental}
Voc√™ pode fazer isso utilizando a [API p√∫blica da Tabela FIPE](https://deividfortuna.github.io/fipe/), que n√£o exige autentica√ß√£o. Abaixo est√° um exemplo de programa Python que solicita o nome do modelo, busca o modelo correspondente e exibe o pre√ßo atual em Minas Gerais:

````python
import requests

def buscar_marcas():
    url = "https://parallelum.com.br/fipe/api/v1/carros/marcas"
    return requests.get(url).json()

def buscar_modelos(codigo_marca):
    url = f"https://parallelum.com.br/fipe/api/v1/carros/marcas/{codigo_marca}/modelos"
    return requests.get(url).json()['modelos']

def buscar_anos(codigo_marca, codigo_modelo):
    url = f"https://parallelum.com.br/fipe/api/v1/carros/marcas/{codigo_marca}/modelos/{codigo_modelo}/anos"
    return requests.get(url).json()

def buscar_preco(codigo_marca, codigo_modelo, codigo_ano):
    url = f"https://parallelum.com.br/fipe/api/v1/carros/marcas/{codigo_marca}/modelos/{codigo_modelo}/anos/{codigo_ano}"
    return requests.get(url).json()
````
:::

##

::: {.callout-note title="GitHub Copilot (continua√ß√£o)" icon="false" .nonincremental}

````{.python startFrom="19"}
def main():
    modelo_nome = input("Digite o nome do modelo do carro: ").strip().lower()
    marcas = buscar_marcas()
    print("Buscando marcas...")
    for marca in marcas:
        modelos = buscar_modelos(marca['codigo'])
        for modelo in modelos:
            if modelo_nome in modelo['nome'].lower():
                print(f"Modelo encontrado: {modelo['nome']} ({marca['nome']})")
                anos = buscar_anos(marca['codigo'], modelo['codigo'])
                if anos:
                    # Pega o ano mais recente
                    ano = anos[-1]['codigo']
                    preco = buscar_preco(marca['codigo'], modelo['codigo'], ano)
                    print(f"Pre√ßo FIPE em MG: {preco['Valor']} ({preco['AnoModelo']})")
                    print(f"Marca: {preco['Marca']}, Modelo: {preco['Modelo']}, Combust√≠vel: {preco['Combustivel']}")
                    return
    print("Modelo n√£o encontrado.")

if __name__ == "__main__":
    main()
````
:::

##

::: {.callout-note title="GitHub Copilot (continua√ß√£o)" icon="false" .nonincremental}


**Observa√ß√µes:**
- A API FIPE n√£o retorna pre√ßos por estado, apenas o pre√ßo m√©dio nacional. O pre√ßo exibido √© o valor FIPE nacional, n√£o espec√≠fico de Minas Gerais.
- O programa busca o modelo pelo nome informado e retorna o pre√ßo do ano mais recente dispon√≠vel.
- Para refinar a busca, voc√™ pode adaptar o c√≥digo para listar op√ß√µes caso haja mais de um modelo correspondente.

Se precisar de ajustes, me avise!
:::

##

A boa not√≠cia √© que o c√≥digo gerado funciona.

. . .

```output
Digite o nome do modelo do carro: Fusca
Buscando marcas...
Modelo encontrado: Fusca (VW - VolksWagen)
Pre√ßo FIPE em MG: R$ 27.357,00 (1985)
Marca: VW - VolksWagen, Modelo: Fusca, Combust√≠vel: Gasolina
```

. . .

Mas, analisando o c√≥digo gerado percebi algumas coisas.

##

1. Meu prompt original n√£o era bom pois eu coloquei "pre√ßo atual do modelo",
mas o pre√ßo √© diferente dependendo do ano do carro.
2. Al√©m disso, o mesmo modelo, no mesmo ano, pode ter v√°rias varia√ß√µes (LX, EX, etc.).
3. E, por fim, n√£o h√° nenhum refer√™ncia no c√≥digo que indique que os dados se refiram a Minas Gerais.

. . .

Sem contar que a busca √© lenta porque procura o carro em todas as marcas.

##

Comecei ent√£o pedindo que o Copilot alterasse o c√≥digo para que o usu√°rio informasse o ano do carro.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Altere o programa para que o ano do carro seja pedido ao usu√°rio.
:::

. . .

Foi gerado um c√≥digo que parecia fazer sentido.

##

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
```{.python startFrom="19"}
def main():
    modelo_nome = input("Digite o nome do modelo do carro: ").strip().lower()
    ano_usuario = input("Digite o ano do carro: ").strip()
    marcas = buscar_marcas()
    print("Buscando marcas...")
    for marca in marcas:
        modelos = buscar_modelos(marca['codigo'])
        for modelo in modelos:
            if modelo_nome in modelo['nome'].lower():
                print(f"Modelo encontrado: {modelo['nome']} ({marca['nome']})")
                anos = buscar_anos(marca['codigo'], modelo['codigo'])
                ano_encontrado = None
                for ano in anos:
                    if ano_usuario == ano['nome']:
                        ano_encontrado = ano['codigo']
                        break
                if ano_encontrado:
                    preco = buscar_preco(marca['codigo'], modelo['codigo'], ano_encontrado)
                    print(f"Pre√ßo FIPE em MG: {preco['Valor']} ({preco['AnoModelo']})")
                    print(f"Marca: {preco['Marca']}, Modelo: {preco['Modelo']}, Combust√≠vel: {preco['Combustivel']}")
                    return
                else:
                    print("Ano n√£o encontrado para este modelo.")
                    return
    print("Modelo n√£o encontrado.")
```
:::

##

Mas ao testar usando `Fusca`e ano `1985`, o programa n√£o encontrou a informa√ß√£o.

- Mas o dado do `Fusca` exibido na vers√£o anterior do programa mostrava `1985` como
  o ano mais recente dispon√≠vel.

. . .

Usando o depurador do VS Code, percebi que o dado retornado pela API
n√£o era exatamente `1985` 

- mas sim `1985 Gasolina`, por exemplo.

. . .

Assim a compara√ß√£o abaixo n√£o funcionava.

```python
if ano_usuario == ano['nome']:
```

##

Fiz ent√£o um novo prompt para o Copilot corrigir esse problema.

. . .

::: {.callout-caution title="Prompt" icon="false"}
O programa n√£o est√° funcionando porque o ano retornado pode ser "1985 gasolina", por exemplo, em vez de "1985". Gostaria que o programa mostrasse todas as op√ß√µes retornadas do ano solicitado para que o usu√°rio escolhesse qual ele deseja. Al√©m disso, na hora de exibir o resultado, mostre o m√°ximo de detalhes poss√≠vel.
:::

##

O c√≥digo gerado funcionava, mas vi outro problema.

- Ele parava no primeiro modelo encontrado com o nome informado.
- Assim, procurando `Onix`, por exemplo, ele olhava apenas um modelo espec√≠fico.
  - `ONIX  Lollapalooza 1.0 F.Power 5p Mec.` 
  - e n√£o encontrava dados para ano `2024`, j√° que esse modelo s√≥ teve produ√ß√£o em 2014.

. . .

::: {.callout-caution title="Prompt" icon="false"}
Podem existir v√°rios modelos com o nome passado pelo usu√°rio. Assim como foi feito com o ano, gostaria que fossem exibidos todos os modelos para que o usu√°rio escolhesse o que deseja.
:::

##

O c√≥digo gerado gerou o seguinte erro:

```output
Traceback (most recent call last):
  File "/home/julio/Downloads/projeto/app.py", line 83, in <module>
    main()
  File "/home/julio/Downloads/projeto/app.py", line 27, in main
    modelos = buscar_modelos(marca['codigo'])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/julio/Downloads/projeto/app.py", line 9, in buscar_modelos
    return requests.get(url).json()['modelos']
           ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^
KeyError: 'modelos'
```

##

Joguei o erro no chat do Copilot e obtive a resposta abaixo, junto com o c√≥digo alterado.

. . .

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
O erro KeyError: 'modelos' ocorre porque algumas marcas n√£o possuem modelos cadastrados, e a resposta da API pode n√£o conter a chave 'modelos'. Para evitar esse erro, fa√ßa uma verifica√ß√£o antes de acessar 'modelos':
:::

##

Continuou gerando erro:

```output
Traceback (most recent call last):
  File "/home/julio/Downloads/projeto/app.py", line 84, in <module>
    main()
  File "/home/julio/Downloads/projeto/app.py", line 28, in main
    modelos = buscar_modelos(marca['codigo'])
                             ~~~~~^^^^^^^^^^
TypeError: string indices must be integers, not 'str'
```

. . .

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
O erro ocorre porque a lista `marcas` cont√©m dicion√°rios, mas em algum momento ela pode estar vindo como uma lista de strings. Isso geralmente acontece se a API retorna algo inesperado ou se o c√≥digo espera um dicion√°rio, mas recebe uma string.

Para garantir que cada item de `marcas` seja um dicion√°rio, ajuste o loop para verificar o tipo e trate poss√≠veis inconsist√™ncias. Al√©m disso, adicione tratamento de erro para garantir que a API est√° retornando o esperado.
:::

##

Junto com a resposta veio um c√≥digo alterado com prote√ß√µes mas que
n√£o retornava nenhuma informa√ß√£o.

- O que voc√™ acha que estava acontecendo?

. . .

Usando o depurador vi que estava sendo retornada uma mensagem de erro
dizendo que a taxa de requisi√ß√µes da API tinha sido excedida.

##

::: {.callout-caution title="Prompt" icon="false"}
Depurando, eu notei que a vari√°vel marcas est√° agora vindo com o valor {'error': 'limite de taxa excedido. Por favor, visite https://fipe.online para obter um token'}. Altere o c√≥digo para identificar essa situa√ß√£o e informar o su√°rio que n√£o √© poss√≠vel consultar a informa√ß√£o no momento.
:::

##

```python
import requests

def buscar_marcas():
    url = "https://parallelum.com.br/fipe/api/v1/carros/marcas"
    return requests.get(url).json()

def buscar_modelos(codigo_marca):
    url = f"https://parallelum.com.br/fipe/api/v1/carros/marcas/{codigo_marca}/modelos"
    resposta = requests.get(url).json()
    return resposta.get('modelos', [])

def buscar_anos(codigo_marca, codigo_modelo):
    url = f"https://parallelum.com.br/fipe/api/v1/carros/marcas/{codigo_marca}/modelos/{codigo_modelo}/anos"
    return requests.get(url).json()

def buscar_preco(codigo_marca, codigo_modelo, codigo_ano):
    url = f"https://parallelum.com.br/fipe/api/v1/carros/marcas/{codigo_marca}/modelos/{codigo_modelo}/anos/{codigo_ano}"
    return requests.get(url).json()

def main():
    modelo_nome = input("Digite o nome do modelo do carro: ").strip().lower()
    ano_usuario = input("Digite o ano do carro (ex: 2015): ").strip()
    marcas = buscar_marcas()

    # Verifica se houve erro de limite de taxa
    if isinstance(marcas, dict) and 'error' in marcas:
        print("N√£o foi poss√≠vel consultar a informa√ß√£o no momento: limite de taxa da API excedido.")
        print("Tente novamente mais tarde ou acesse https://fipe.online para obter um token.")
        return

    print("Buscando modelos que correspondem ao nome informado...")

    modelos_encontrados = []
    for marca in marcas:
        if not isinstance(marca, dict) or 'codigo' not in marca or 'nome' not in marca:
            continue
        modelos = buscar_modelos(marca['codigo'])
        for modelo in modelos:
            if modelo_nome in modelo['nome'].lower():
                modelos_encontrados.append({
                    'marca': marca,
                    'modelo': modelo
                })

    if not modelos_encontrados:
        print("Nenhum modelo encontrado com esse nome.")
        return

    print("\nModelos encontrados:")
    for idx, item in enumerate(modelos_encontrados):
        print(f"{idx}: {item['modelo']['nome']} ({item['marca']['nome']})")

    escolha_modelo = input("Escolha o n√∫mero correspondente ao modelo desejado: ").strip()
    try:
        escolha_modelo_idx = int(escolha_modelo)
        modelo_escolhido = modelos_encontrados[escolha_modelo_idx]
    except (ValueError, IndexError):
        print("Op√ß√£o de modelo inv√°lida.")
        return

    anos = buscar_anos(modelo_escolhido['marca']['codigo'], modelo_escolhido['modelo']['codigo'])
    opcoes_ano = [
        (i, ano) for i, ano in enumerate(anos)
        if ano_usuario in ano['nome']
    ]
    if not opcoes_ano:
        print("Nenhuma op√ß√£o de ano encontrada para esse modelo.")
        return

    print("\nOp√ß√µes de ano encontradas:")
    for idx, ano in opcoes_ano:
        print(f"{idx}: {ano['nome']}")

    escolha_ano = input("Escolha o n√∫mero correspondente ao ano desejado: ").strip()
    try:
        escolha_ano_idx = int(escolha_ano)
        ano_escolhido = opcoes_ano[escolha_ano_idx][1]
    except (ValueError, IndexError):
        print("Op√ß√£o de ano inv√°lida.")
        return

    preco = buscar_preco(
        modelo_escolhido['marca']['codigo'],
        modelo_escolhido['modelo']['codigo'],
        ano_escolhido['codigo']
    )

    print("\nDetalhes do ve√≠culo:")
    for chave, valor in preco.items():
        print(f"{chave}: {valor}")

if __name__ == "__main__":
    main()
```

## 

Sobre a quest√£o do c√≥digo n√£o parecer estar consultando informa√ß√µes
espec√≠ficas sobre Minas Gerais, escrevi o seguinte prompt.

::: {.callout-caution title="Prompt" icon="false"}
No in√≠cio eu tinha pedido pre√ßos de Minas Gerais. Mas n√£o h√° nada no c√≥digo que indique que os pre√ßos se referem ao estado. Existe alguma forma de fazer a consulta por estado?
:::

##

E tive a seguinte resposta:

::: {.callout-note title="GitHub Copilot" icon="false" .nonincremental}
Atualmente, a API p√∫blica da FIPE (https://parallelum.com.br/fipe/api/v1/) **n√£o permite consultar pre√ßos por estado**. O valor retornado √© sempre o pre√ßo m√©dio nacional calculado pela FIPE, sem distin√ß√£o regional.

**Resumo:**
- O pre√ßo retornado √© nacional, n√£o estadual.
- N√£o h√° par√¢metro ou endpoint para filtrar por estado (ex: Minas Gerais).
- Se precisar de pre√ßos regionais, ser√° necess√°rio buscar fontes alternativas, como portais de classificados ou APIs privadas de mercado automotivo.

Se precisar, posso adicionar uma mensagem ao seu programa informando ao usu√°rio que o valor exibido √© nacional.
:::
