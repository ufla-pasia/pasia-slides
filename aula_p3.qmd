---
title: Testes
subtitle: PASIA - Aula P.3
---

##  

O conteúdo dessa aula é baseado no **capítulo 6** do livro abaixo.

![](imagens/livro_potter_zingaro.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

# Por que é essencial testar código? {background-color="#40666e"}

##

Já mencionamos nas aulas anteriores sobre testes de código.

- [Testar código]{.alert} é uma **habilidade essencial** porque nos dá confiança de que o código funciona apropriadamente.

. . .

É importante que você adquira essa habilitade e consiga conferir por você mesmo se o seu código funciona.

- Mesmo que o Copilot possa ser usado para gerar testes (e ele está ficando cada vez melhor nisso),
- entendemos que você deve ser capaz de escrever testes por conta própria, para verificar se um código gerado pelo Copilot está correto.

##

**Programadores iniciantes** geralmente têm aversão a testes (e mesmo nem tão novatos assim).

- Eles têm dificuldade de perceber que, mesmo que um código pareça fazer sentido, ele pode conter erros sutis.
- Há também um sentimento de que _"se eu testar vou descobrir que tem problema, então melhor deixar quieto"_.

##

**Engenheiros de Software profissionais** seguem uma abordagem completamente oposta.

- Eles levam testes extremamente a sério, porque sabem o quanto isso pode trazer de consequências para suas empresas.
- Ninguém quer ser a pessoa que 
  - causou um prejuízo enorme para sua empresa ou para algum de seus clientes;
  - deixou hacker obter acesso a dados confidenciais de usuários;
  - ou causou um acidente de um carro autônomo.

##

Dado o potencial **custo** de um erro, faz muito mais sentido **assumir que o código está errado** até que se prove o contrário.

. . .

Apenas com testes rigorosos podemos ter confiança de que o código funciona apropriadamente.

- Empresas geralmente não testam uma única vez.
- Possuem toda uma metodologia e infraestrutura de testes contínuos para garantir que tudo funciona a cada alteração no código.

## TDD

Algumas empresas levam isso tão a sério que seguem uma abordagem chamada [TDD - Test Driven Development]{.alert}.

- A ideia central é escrever primeiro os testes e depois a função/módulo a ser testado.

. . .

Não vamos seguir essa abordagem aqui,

- mas precisamos nos lembrar que assistentes de IA erram e precisamos verificar nossos códigos.

# Testes de Caixa-Preta e de Caixa-Branca {background-color="#40666e"}

## Testes de Caixa-Preta

. . .

[Testes de Caixa-Preta]{.alert} assumem que não sabemos nada sobre como o código funciona.

- Apenas sabemos o que ele deve fazer.
- O teste envolve então experimentar diferentes entradas e verificar se as saídas estão corretas.

. . .

Podemos aplicar testes de caixa-preta a cada função ou a um programa inteiro.

- Uma vantagem desse tipo de teste é que não precisamos olhar o código para escrevê-lo.
- Focamos apenas no comportamento desejado do código.

##

Como exemplo, suponha que precisamos testar uma função que 
**pega uma lista de palavras (strings) e retorna a maior delas**.

. . .

::: {.halfincfontsize}
```python
def maior_palavra(palavras):
```
:::

Mais precisamente, dada a assinatura acima, o comportamento esperando é que a função retorne a
palavra que tenha mais caracteres.

- Se existirem várias palavras com o mesmo número máximo de caracteres, a função deve retornar a 
  primeira delas presente na lista.

##

Há duas categorias principais que costumamos pensar ao escrever testes.

- [Casos de uso comuns]{.alert}: incluem as entradas que imaginamos que serão utilizadas na prática.
- [Casos de borda _(edge cases)_]{.alert}: são casos incomuns, mas possíveis, que podem quebrar o código.
  - Há entradas que podem testar algumas regras da função em maior profundidade ou que contenham entradas inesperadas
   (ex. uma lista contendo só strings vazias).

## Casos de uso comuns

Pensando na função `maior_palavra`, vamos pensar nos casos de testes que deveríamos usar.

- Para especificar os casos de testes vamos escrever como se estivéssemos usando um terminal Python.

. . .

Começando com **casos de uso comuns**:

. . .

Podemos pensar em um teste com poucas palavras nas quais apenas uma é maior que todas as outras.

::: {.halfincfontsize}
```python
>>> maior_palavra(['gato', 'pássaro', 'cachorro'])
'cachorro'
```
:::

## Casos de uso comuns

Podemos agora testar uma lista com mais palavras e com a maior palavra aparecendo em outra posição da lista.

::: {.halfincfontsize}
```python
>>> maior_palavra(['feliz', 'aniversário', 'para', 'meu', 'cachorro'])
'aniversário'
```
:::

. . .

Por fim, podemos pensar em uma lista contendo uma única palavra.

::: {.halfincfontsize}
```python
>>> maior_palavra(['feliz'])
'feliz'
```
:::

## Casos de borda

Se o programa estiver funcionando para esses casos de testes comuns, é hora de pensarmos nos **casos de borda**.

- Podemos começar testando o caso de termos empate na maior palavra, 
- que, pela especificação da função, deve ser retornadada a primeira delas.
- Obs.: algumas pessoas podem considerar esse um caso comum e outras um caso de borda.

. . .

::: {.halfincfontsize}
```python
>>> maior_palavra(['gato', 'cão', 'sapo'])
'gato'
```
:::

## Casos de borda

E se nenhuma palavra tiver caracteres? 

- A maior palavra é uma string vazia.

. . .

::: {.halfincfontsize}
```python
>>> maior_palavra(['', '', ''])
''
```
:::

. . .

::: {.callout-tip}
Em códigos que usam loops é muito comum que erros ocorram em verificações do primeiro 
ou do último elementos, por falhas na construção da lógica do loop.

Assim, se presumimos que uma função pode ter que percorrer uma lista, ou algo similar,
é interessante pensarmos em casos de borda sobre isso.
:::

## Casos de borda

E como deveríamos testar o caso do método ser chamado com uma lista vazia?

- Veja que, neste caso, a especificação do comportamento da função não é clara.
- A função poderia retornar `None` ou poderia gerar uma exceção, por exemplo.

. . .

Assumindo que a função retorne `None` para esse caso, o teste seria:

::: {.halfincfontsize}
```python
>>> maior_palavra([])
None
```
:::

## Testes de entrada incorreta

Há ainda um outro tipo de teste que poderíamos pensar, que é o caso da 
função ser chamada com parâmetros errados.

- Como Python é fracamente tipado, nada impede que a função `maior_palavra` seja chamada com 
  tipos de dados inesperados, como números, lista de números, `None`, etc.

. . .

Nessa aula vamos ignorar esse tipo de situação.

- Mas em sistemas em produção isso é algo importante.
- E, para esse caso, _type hints_ podem ser mais interessantes do que testes exaustivos.


## Como saber quais casos de testes usar

Podemos começar considerando os tipos de dados dos parâmetros e variando seus valores.

- Se o parâmetro for uma lista (ou string), podemos verificar testar vazia, com um ou com vários elementos.
- Na maioria das vezes, "vários" podem ser 4 elementos.
  - Já que é improvável que uma função funcione para 4 elementos mas não para 5, 6 ou mais.
- Já para uma função que recebe dois números, podemos pensar em testes considerando quando
  - um deles é zero, os dois são zero, um é negativo, ambos são negativos ou ambos são positivos.

## Como saber quais casos de testes usar

Outro tipo de caso de teste é levar em conta o comportamento específico da função.

- Como no caso do empate da função `maior_palavra`.

. . .

No final das contas, como já mencionamos, testar é uma mistura de ciência e arte.

- A prática é o melhor caminho para que descubra os melhores testes para suas necessidades.


## Testes de Caixa-Branca

. . .

A ideia do [teste de caixa-branca]{.alert} é examinar o código para pensarmos em casos de testes
adicionais que podemos escrever.

- Ao ler o código de uma função se vermos que ela usa um loop, devemos pensar nos casos comuns de erros com loops.
- Se houver uma estrutura condicional com verificação com `>` ou `>=`, por exemplo, é outro caso a se avaliar.

. . .

A ideia, portanto, é usar o conhecimento do código a ser testado para completar os testes necessários.

# Como testar seu código? {background-color="#40666e"}

##

Qual é a estratégia de testes mais simples que podemos pensar?

- Podemos testar nossa função no terminal Python como fizemos nas aulas anteriores.

. . .

Fazemos a chamada como especificamos no caso de testes e comparamos o resultado exibido com o esperado.

::: {.halfincfontsize}
```python
>>> maior_palavra(['gato', 'cão', 'sapo'])
'gato'
```
:::

##

Quais são as **vantagens** de testes usando o terminal?

- É rápido de rodar.
- É fácil acrescentar novos testes de acordo com o resultado dos testes anterioress.

##

Mas e as **desvantagens** de testar usando o terminal?

. . .

Os problemas começam quando fazemos uma correção no código após detecarmos um problema em um teste.

- É muito comum que, ao corrigir um erro, lembremos de repetir apenas o teste que tinha falhado.
- Mas pode ser que a correção tenha provocado um efeito colateral em outros casos de teste que tínhamos verificado antes.
- E, portanto, o correto seria reexecutar todos os testes.
  - E aí começa a ficar muito improdutivo seguir essa estratégia.

##

E qual seria a segunda abordagem mais simples para testar o código?

- Seria inserir os casos de teste no próprio código.
- Por exemplo, poderíamos inserir testes no mesmo arquivo da função `maior_palavra` logo após a definição dela.
- Mas isso seria muito ruim quando o código fosse usado em produção.
  - Precisaríamos comentar esse código de teste, ou ter uma maneira de desabilitá-lo.

## 

A melhor abordagem, na verdade, é usar um [framework de testes]{.alert}.

- A biblioteca mais popular para testes em Python é a [pytest](https://docs.pytest.org).
- Ela permite escrever testes de forma simples e organizada.
  - E, ao mesmo tempo, oferece recursos avançados.

. . .

Obs.: o livro de Potter e Zingaro usa o módulo `doctest`, que é parte da biblioteca padrão do Python.

- Ele é útil para testes bem simples, mas não é tão poderoso quanto o `pytest`.

## Instalando `pytest`

Nesta aula nós veremos apenas o básico do `pytest`.

- Mas que será suficiente para os testes que precisaremos fazer.

. . .

A primeira coisa que precisamos fazer é instalar o `pytest`, já que não é um módulo padrão do Python.

::: {.halfincfontsize}
```bash
pip install pytest
```
:::

## Implementando um teste com `pytest`

O módulo `pytest` fornece uma maneira simples de implementar testes.

- Nós, basicamente, escrevemos uma função para cada teste que queremos realizar.
- E, na implementação da função, usamos o comando `assert` para realizar o teste.

. . . 

::: {.halfincfontsize}
```python
def test_maior_palavra():
    assert maior_palavra(['gato', 'pássaro', 'cachorro']) == 'cachorro'
```
:::

## O comando `assert`

O comando `assert` serve para verificar se uma condição é verdadeira.

- Se for, o código continua sendo executado normalmente.
- Se não for, é lançada uma exceção `AssertionError`.
- É como se ele significasse: _"Eu espero que isso seja verdade"_. 

. . .

Nós podemos ainda definir uma mensagem de erro personalizada.

- O formato é: 

. . .

::: {.halfincfontsize}
```python
assert <condição>, <mensagem_opcional_de_erro>
```
:::

## `pytest` e comando `assert`

O módulo `pytest` utiliza o comando `assert` para verificar se as condições dos testes são atendidas.

- Se todas as condições forem verdadeiras, significa que nosso código passou nos testes.
- Já se um `assert` falha, o Pytest automaticamente fornece informações detalhadas
  sobre os valores das variáveis envolvidas na comparação, o que simplifica muito a depuração.

## Convenção de nomenclatura do `pytest`

O módulo `pytest` procura de forma automática os testes escritos em nosso projeto.

- Ele procura por arquivos que começam com `test_`.
- Dentro deles, procura por funções que começam com `test_`.
- Podemos ainda organizar os testes em classes, que devem começar com `Test` e não podem ter construtor.

##

Vamos então implementar todos os testes que levantamos para a função `maior_palavra`.

- Vamos primeiro deixar clara a estrutura de pastas e arquivos que vamos usar.

. . .

Suponha que nossa função `maior_palavra` esteja implementada em um arquivo `meu_app/main.py`.

- Vamos então criar uma subpasta chamada `testes` e, dentro dela, criar um arquivo
  `test_maior_palavra.py`, onde escreveremos nossos testes.

##

A estrutura fica então assim.

::: {.halfincfontsize}
```
meu_projeto/
│
├── meu_app/
│   ├── __init__.py
│   └── main.py
│
└── testes/
    ├── __init__.py
    └── test_utilitarios.py
```
:::

. . .

Obs.: os arquivos `__init__.py` são arquivos vazios que servem para que suas pastas (`meu_app` e `testes`) 
  sejam reconhecidas como módulos Python.

- É similar ao conceito de pacotes em Java.

##

No nosso arquivo `meu_app/main.py`, devemos implementar a função `maior_palavra`.

```python
def maior_palavra(palavras):
    if not palavras:
        return None
    maior = palavras[0]
    for p in palavras[1:]:
        if len(p) > len(maior):
            maior = p
    return maior
```

##

Já nosso arquivo `test_maior_palavra.py` ficaria então assim:

```python
from meu_app.main import maior_palavra

def test_maior_palavra_unica():
    assert maior_palavra(['gato', 'pássaro', 'cachorro']) == 'cachorro'

def test_maior_palavra_unica_lista_maior():
    assert maior_palavra(['feliz', 'aniversário', 'para', 'meu', 'cachorro']) == 'aniversário'

def test_maior_palavra_lista_1_elemento():
    assert maior_palavra(['feliz']) == 'feliz'

def test_maior_palavra_empate():
    assert maior_palavra(['gato', 'cão', 'sapo']) == 'gato'

def test_maior_palavra_strings_vazias():
    assert maior_palavra(['', '', '']) == ''

def test_maior_palavra_lista_vazia():
    assert maior_palavra([]) is None
```

## 

Repare em um detalhe importante do último teste.

- Para verificar se o retorno é `None`, usamos `is None` em vez de `== None`.

. . .

É que o operador `==` compara o conteúdo de dois objetos.

- De forma similar ao `equals` no Java.
- Já o operador `is` verifica se duas variáveis apontam para o mesmo objeto.
  - Que é similar ao `==` do Java 😁

. . .

Como `None` é um objeto único no Java, é mais eficiente e seguro usar `is None` para verificar se uma variável é `None`.

## Execução do `pytest`

Agora, para executar os testes, basta executar o comando `pytest` na pasta principal do projeto.

::: {.halfincfontsize}
```bash
pytest
```
:::

. . .

Se nossa função passar em todos os testes, esse seria um exemplo de saída esperada.

```bash
=================== test session starts ===================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/julio/Downloads/aula_p2
collected 6 items

testes/test_maior_palavra.py ......                   [100%]

===================== 6 passed in 0.01s ====================

```

## 

Vamos agora forçar dois erros em nossa função `maior_palavra`

- para ver como o `pytest` vai reportar esses erros.

::: {.halfincfontsize}
```python
def maior_palavra(palavras):
    # removemos a verificação de lista vazia
    maior = palavras[0]
    for p in palavras[1:]:
        # trocamos > por >=
        if len(p) >= len(maior):
            maior = p
    return maior
```
:::

## 

Obtemos então a seguinte saída com `pytest`.


```bash
==================== test session starts =====================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/julio/Downloads/aula_p2
collected 6 items                                            

testes/test_maior_palavra.py ...F.F                    [100%]

========================== FAILURES ==========================
_________________ test_maior_palavra_empate __________________

    def test_maior_palavra_empate():
>       assert maior_palavra(['gato', 'cão', 'sapo']) == 'gato'
E       AssertionError: assert 'sapo' == 'gato'
E         
E         - gato
E         + sapo

testes/test_maior_palavra.py:13: AssertionError
_______________ test_maior_palavra_lista_vazia _______________

    def test_maior_palavra_lista_vazia():
>       assert maior_palavra([]) == None
               ^^^^^^^^^^^^^^^^^

testes/test_maior_palavra.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

palavras = []

    def maior_palavra(palavras):
        # removemos a verificação de lista vazia
>       maior = palavras[0]
                ^^^^^^^^^^^
E       IndexError: list index out of range

meu_app/main.py:3: IndexError
================== short test summary info ===================
FAILED testes/test_maior_palavra.py::test_maior_palavra_empate - AssertionError: assert 'sapo' == 'gato'
FAILED testes/test_maior_palavra.py::test_maior_palavra_lista_vazia - IndexError: list index out of range
================ 2 failed, 4 passed in 0.04s =================
```

## 

Na saída anterior vemos que foram encontrados 6 testes dos quais dois não passaram

```bash
collected 6 items                                            

testes/test_maior_palavra.py ...F.F                    [100%]
```

. . .

Em seguida são apresentados detalhes dos testes que falharam.

- Que nos ajudam a identificar o problema para corrigi-lo.

# Atualizando o ciclo de projeto de funções {background-color="#40666e"}

##

Nas aulas anteriores vimos o **ciclo de projeto de funções**.

- Vamos agora atualizá-lo para incluir a etapa de testes.

##

- **A**. Defina o comportamento desejado da função
- **B**. Escreva um prompt que descreve a função
- **C**. Use o Copilot para gerar o código
- **D**. O código parece razoável? Sim: **E**, não: **I**.
- **E**. Escreva casos de teste usando pytest
- **F**. Rode os testes. Passou nos testes? Sim: **G**, não: **J**
- **G**. Escreveu todos os casos de testes? Sim: **H**, não: **E**
- **H**. Pronto!
- **I**. Explore alternativas do Copilot. Alguma parece razoável?  Sim: **E**, não: **J**
- **J**. Revise o prompt para melhorar a descrição da função e vá para **C** .

##

```{mermaid}
flowchart TD
  A(Defina o comportamento desejado da função) --> B(Escreva um prompt que descreve a função)
  B --> C(Use o Copilot para gerar o código)
  C --> D(O código parece razoável?)
  D --Sim--> E(Escreva casos de teste usando pytest)
  E --> F(Rode os testes. Passou nos testes?)
  F -- Sim --> G(Escreveu todos os casos de testes?)
  G -- Sim --> H(Pronto!)
  G -- Não --> E
  D -- Não --> I(Explore alternativas do Copilot. Alguma parece razoável?)
  I -- Sim --> E
  I -- Não --> J(Revise o prompt para melhorar a descrição da função)
  J --> C
  F -- Não --> J
```

# Como testar seu código? {background-color="#40666e"}

## 