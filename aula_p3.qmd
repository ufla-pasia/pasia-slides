---
title: Testes
subtitle: PASIA - Aula P.3
---

##  

O conte√∫do dessa aula √© baseado no **cap√≠tulo 6** do livro abaixo.

![](imagens/livro_potter_zingaro.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

# Por que √© essencial testar c√≥digo? {background-color="#40666e"}

##

J√° mencionamos nas aulas anteriores sobre testes de c√≥digo.

- [Testar c√≥digo]{.alert} √© uma **habilidade essencial** porque nos d√° confian√ßa de que o c√≥digo funciona apropriadamente.

. . .

√â importante que voc√™ adquira essa habilitade e consiga conferir por voc√™ mesmo se o seu c√≥digo funciona.

- Mesmo que o Copilot possa ser usado para gerar testes (e ele est√° ficando cada vez melhor nisso),
- entendemos que voc√™ deve ser capaz de escrever testes por conta pr√≥pria, para verificar se um c√≥digo gerado pelo Copilot est√° correto.

##

**Programadores iniciantes** geralmente t√™m avers√£o a testes (e mesmo nem t√£o novatos assim).

- Eles t√™m dificuldade de perceber que, mesmo que um c√≥digo pare√ßa fazer sentido, ele pode conter erros sutis.
- H√° tamb√©m um sentimento de que _"se eu testar vou descobrir que tem problema, ent√£o melhor deixar quieto"_.

##

**Engenheiros de Software profissionais** seguem uma abordagem completamente oposta.

- Eles levam testes extremamente a s√©rio, porque sabem o quanto isso pode trazer de consequ√™ncias para suas empresas.
- Ningu√©m quer ser a pessoa que 
  - causou um preju√≠zo enorme para sua empresa ou para algum de seus clientes;
  - deixou hacker obter acesso a dados confidenciais de usu√°rios;
  - ou causou um acidente de um carro aut√¥nomo.

##

Dado o potencial **custo** de um erro, faz muito mais sentido **assumir que o c√≥digo est√° errado** at√© que se prove o contr√°rio.

. . .

Apenas com testes rigorosos podemos ter confian√ßa de que o c√≥digo funciona apropriadamente.

- Empresas geralmente n√£o testam uma √∫nica vez.
- Possuem toda uma metodologia e infraestrutura de testes cont√≠nuos para garantir que tudo funciona a cada altera√ß√£o no c√≥digo.

## TDD

Algumas empresas levam isso t√£o a s√©rio que seguem uma abordagem chamada [TDD - Test Driven Development]{.alert}.

- A ideia central √© escrever primeiro os testes e depois a fun√ß√£o/m√≥dulo a ser testado.

. . .

N√£o vamos seguir essa abordagem aqui,

- mas precisamos nos lembrar que assistentes de IA erram e precisamos verificar nossos c√≥digos.

# Testes de Caixa-Preta e de Caixa-Branca {background-color="#40666e"}

## Testes de Caixa-Preta

. . .

[Testes de Caixa-Preta]{.alert} assumem que n√£o sabemos nada sobre como o c√≥digo funciona.

- Apenas sabemos o que ele deve fazer.
- O teste envolve ent√£o experimentar diferentes entradas e verificar se as sa√≠das est√£o corretas.

. . .

Podemos aplicar testes de caixa-preta a cada fun√ß√£o ou a um programa inteiro.

- Uma vantagem desse tipo de teste √© que n√£o precisamos olhar o c√≥digo para escrev√™-lo.
- Focamos apenas no comportamento desejado do c√≥digo.

##

Como exemplo, suponha que precisamos testar uma fun√ß√£o que 
**pega uma lista de palavras (strings) e retorna a maior delas**.

. . .

::: {.halfincfontsize}
```python
def maior_palavra(palavras):
```
:::

Mais precisamente, dada a assinatura acima, o comportamento esperando √© que a fun√ß√£o retorne a
palavra que tenha mais caracteres.

- Se existirem v√°rias palavras com o mesmo n√∫mero m√°ximo de caracteres, a fun√ß√£o deve retornar a 
  primeira delas presente na lista.

##

H√° duas categorias principais que costumamos pensar ao escrever testes.

- [Casos de uso comuns]{.alert}: incluem as entradas que imaginamos que ser√£o utilizadas na pr√°tica.
- [Casos de borda _(edge cases)_]{.alert}: s√£o casos incomuns, mas poss√≠veis, que podem quebrar o c√≥digo.
  - H√° entradas que podem testar algumas regras da fun√ß√£o em maior profundidade ou que contenham entradas inesperadas
   (ex. uma lista contendo s√≥ strings vazias).

## Casos de uso comuns

Pensando na fun√ß√£o `maior_palavra`, vamos pensar nos casos de testes que dever√≠amos usar.

- Para especificar os casos de testes vamos escrever como se estiv√©ssemos usando um terminal Python.

. . .

Come√ßando com **casos de uso comuns**:

. . .

Podemos pensar em um teste com poucas palavras nas quais apenas uma √© maior que todas as outras.

::: {.halfincfontsize}
```python
>>> maior_palavra(['gato', 'p√°ssaro', 'cachorro'])
'cachorro'
```
:::

## Casos de uso comuns

Podemos agora testar uma lista com mais palavras e com a maior palavra aparecendo em outra posi√ß√£o da lista.

::: {.halfincfontsize}
```python
>>> maior_palavra(['feliz', 'anivers√°rio', 'para', 'meu', 'cachorro'])
'anivers√°rio'
```
:::

. . .

Por fim, podemos pensar em uma lista contendo uma √∫nica palavra.

::: {.halfincfontsize}
```python
>>> maior_palavra(['feliz'])
'feliz'
```
:::

## Casos de borda

Se o programa estiver funcionando para esses casos de testes comuns, √© hora de pensarmos nos **casos de borda**.

- Podemos come√ßar testando o caso de termos empate na maior palavra, 
- que, pela especifica√ß√£o da fun√ß√£o, deve ser retornadada a primeira delas.
- Obs.: algumas pessoas podem considerar esse um caso comum e outras um caso de borda.

. . .

::: {.halfincfontsize}
```python
>>> maior_palavra(['gato', 'c√£o', 'sapo'])
'gato'
```
:::

## Casos de borda

E se nenhuma palavra tiver caracteres? 

- A maior palavra √© uma string vazia.

. . .

::: {.halfincfontsize}
```python
>>> maior_palavra(['', '', ''])
''
```
:::

. . .

::: {.callout-tip}
Em c√≥digos que usam loops √© muito comum que erros ocorram em verifica√ß√µes do primeiro 
ou do √∫ltimo elementos, por falhas na constru√ß√£o da l√≥gica do loop.

Assim, se presumimos que uma fun√ß√£o pode ter que percorrer uma lista, ou algo similar,
√© interessante pensarmos em casos de borda sobre isso.
:::

## Casos de borda

E como dever√≠amos testar o caso do m√©todo ser chamado com uma lista vazia?

- Veja que, neste caso, a especifica√ß√£o do comportamento da fun√ß√£o n√£o √© clara.
- A fun√ß√£o poderia retornar `None` ou poderia gerar uma exce√ß√£o, por exemplo.

. . .

Assumindo que a fun√ß√£o retorne `None` para esse caso, o teste seria:

::: {.halfincfontsize}
```python
>>> maior_palavra([])
None
```
:::

## Testes de entrada incorreta

H√° ainda um outro tipo de teste que poder√≠amos pensar, que √© o caso da 
fun√ß√£o ser chamada com par√¢metros errados.

- Como Python √© fracamente tipado, nada impede que a fun√ß√£o `maior_palavra` seja chamada com 
  tipos de dados inesperados, como n√∫meros, lista de n√∫meros, `None`, etc.

. . .

Nessa aula vamos ignorar esse tipo de situa√ß√£o.

- Mas em sistemas em produ√ß√£o isso √© algo importante.
- E, para esse caso, _type hints_ podem ser mais interessantes do que testes exaustivos.


## Como saber quais casos de testes usar

Podemos come√ßar considerando os tipos de dados dos par√¢metros e variando seus valores.

- Se o par√¢metro for uma lista (ou string), podemos verificar testar vazia, com um ou com v√°rios elementos.
- Na maioria das vezes, "v√°rios" podem ser 4 elementos.
  - J√° que √© improv√°vel que uma fun√ß√£o funcione para 4 elementos mas n√£o para 5, 6 ou mais.
- J√° para uma fun√ß√£o que recebe dois n√∫meros, podemos pensar em testes considerando quando
  - um deles √© zero, os dois s√£o zero, um √© negativo, ambos s√£o negativos ou ambos s√£o positivos.

## Como saber quais casos de testes usar

Outro tipo de caso de teste √© levar em conta o comportamento espec√≠fico da fun√ß√£o.

- Como no caso do empate da fun√ß√£o `maior_palavra`.

. . .

No final das contas, como j√° mencionamos, testar √© uma mistura de ci√™ncia e arte.

- A pr√°tica √© o melhor caminho para que descubra os melhores testes para suas necessidades.


## Testes de Caixa-Branca

. . .

A ideia do [teste de caixa-branca]{.alert} √© examinar o c√≥digo para pensarmos em casos de testes
adicionais que podemos escrever.

- Ao ler o c√≥digo de uma fun√ß√£o se vermos que ela usa um loop, devemos pensar nos casos comuns de erros com loops.
- Se houver uma estrutura condicional com verifica√ß√£o com `>` ou `>=`, por exemplo, √© outro caso a se avaliar.

. . .

A ideia, portanto, √© usar o conhecimento do c√≥digo a ser testado para completar os testes necess√°rios.

# Como testar seu c√≥digo? {background-color="#40666e"}

##

Qual √© a estrat√©gia de testes mais simples que podemos pensar?

- Podemos testar nossa fun√ß√£o no terminal Python como fizemos nas aulas anteriores.

. . .

Fazemos a chamada como especificamos no caso de testes e comparamos o resultado exibido com o esperado.

::: {.halfincfontsize}
```python
>>> maior_palavra(['gato', 'c√£o', 'sapo'])
'gato'
```
:::

##

Quais s√£o as **vantagens** de testes usando o terminal?

- √â r√°pido de rodar.
- √â f√°cil acrescentar novos testes de acordo com o resultado dos testes anterioress.

##

Mas e as **desvantagens** de testar usando o terminal?

. . .

Os problemas come√ßam quando fazemos uma corre√ß√£o no c√≥digo ap√≥s detecarmos um problema em um teste.

- √â muito comum que, ao corrigir um erro, lembremos de repetir apenas o teste que tinha falhado.
- Mas pode ser que a corre√ß√£o tenha provocado um efeito colateral em outros casos de teste que t√≠nhamos verificado antes.
- E, portanto, o correto seria reexecutar todos os testes.
  - E a√≠ come√ßa a ficar muito improdutivo seguir essa estrat√©gia.

##

E qual seria a segunda abordagem mais simples para testar o c√≥digo?

- Seria inserir os casos de teste no pr√≥prio c√≥digo.
- Por exemplo, poder√≠amos inserir testes no mesmo arquivo da fun√ß√£o `maior_palavra` logo ap√≥s a defini√ß√£o dela.
- Mas isso seria muito ruim quando o c√≥digo fosse usado em produ√ß√£o.
  - Precisar√≠amos comentar esse c√≥digo de teste, ou ter uma maneira de desabilit√°-lo.

## 

A melhor abordagem, na verdade, √© usar um [framework de testes]{.alert}.

- A biblioteca mais popular para testes em Python √© a [pytest](https://docs.pytest.org).
- Ela permite escrever testes de forma simples e organizada.
  - E, ao mesmo tempo, oferece recursos avan√ßados.

. . .

Obs.: o livro de Potter e Zingaro usa o m√≥dulo `doctest`, que √© parte da biblioteca padr√£o do Python.

- Ele √© √∫til para testes bem simples, mas n√£o √© t√£o poderoso quanto o `pytest`.

## Instalando `pytest`

Nesta aula n√≥s veremos apenas o b√°sico do `pytest`.

- Mas que ser√° suficiente para os testes que precisaremos fazer.

. . .

A primeira coisa que precisamos fazer √© instalar o `pytest`, j√° que n√£o √© um m√≥dulo padr√£o do Python.

::: {.halfincfontsize}
```bash
pip install pytest
```
:::

## Implementando um teste com `pytest`

O m√≥dulo `pytest` fornece uma maneira simples de implementar testes.

- N√≥s, basicamente, escrevemos uma fun√ß√£o para cada teste que queremos realizar.
- E, na implementa√ß√£o da fun√ß√£o, usamos o comando `assert` para realizar o teste.

. . . 

::: {.halfincfontsize}
```python
def test_maior_palavra():
    assert maior_palavra(['gato', 'p√°ssaro', 'cachorro']) == 'cachorro'
```
:::

## O comando `assert`

O comando `assert` serve para verificar se uma condi√ß√£o √© verdadeira.

- Se for, o c√≥digo continua sendo executado normalmente.
- Se n√£o for, √© lan√ßada uma exce√ß√£o `AssertionError`.
- √â como se ele significasse: _"Eu espero que isso seja verdade"_. 

. . .

N√≥s podemos ainda definir uma mensagem de erro personalizada.

- O formato √©: 

. . .

::: {.halfincfontsize}
```python
assert <condi√ß√£o>, <mensagem_opcional_de_erro>
```
:::

## `pytest` e comando `assert`

O m√≥dulo `pytest` utiliza o comando `assert` para verificar se as condi√ß√µes dos testes s√£o atendidas.

- Se todas as condi√ß√µes forem verdadeiras, significa que nosso c√≥digo passou nos testes.
- J√° se um `assert` falha, o Pytest automaticamente fornece informa√ß√µes detalhadas
  sobre os valores das vari√°veis envolvidas na compara√ß√£o, o que simplifica muito a depura√ß√£o.

## Conven√ß√£o de nomenclatura do `pytest`

O m√≥dulo `pytest` procura de forma autom√°tica os testes escritos em nosso projeto.

- Ele procura por arquivos que come√ßam com `test_`.
- Dentro deles, procura por fun√ß√µes que come√ßam com `test_`.
- Podemos ainda organizar os testes em classes, que devem come√ßar com `Test` e n√£o podem ter construtor.

##

Vamos ent√£o implementar todos os testes que levantamos para a fun√ß√£o `maior_palavra`.

- Vamos primeiro deixar clara a estrutura de pastas e arquivos que vamos usar.

. . .

Suponha que nossa fun√ß√£o `maior_palavra` esteja implementada em um arquivo `meu_app/main.py`.

- Vamos ent√£o criar uma subpasta chamada `testes` e, dentro dela, criar um arquivo
  `test_maior_palavra.py`, onde escreveremos nossos testes.

##

A estrutura fica ent√£o assim.

::: {.halfincfontsize}
```
meu_projeto/
‚îÇ
‚îú‚îÄ‚îÄ meu_app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ main.py
‚îÇ
‚îî‚îÄ‚îÄ testes/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ test_utilitarios.py
```
:::

. . .

Obs.: os arquivos `__init__.py` s√£o arquivos vazios que servem para que suas pastas (`meu_app` e `testes`) 
  sejam reconhecidas como m√≥dulos Python.

- √â similar ao conceito de pacotes em Java.

##

No nosso arquivo `meu_app/main.py`, devemos implementar a fun√ß√£o `maior_palavra`.

```python
def maior_palavra(palavras):
    if not palavras:
        return None
    maior = palavras[0]
    for p in palavras[1:]:
        if len(p) > len(maior):
            maior = p
    return maior
```

##

J√° nosso arquivo `test_maior_palavra.py` ficaria ent√£o assim:

```python
from meu_app.main import maior_palavra

def test_maior_palavra_unica():
    assert maior_palavra(['gato', 'p√°ssaro', 'cachorro']) == 'cachorro'

def test_maior_palavra_unica_lista_maior():
    assert maior_palavra(['feliz', 'anivers√°rio', 'para', 'meu', 'cachorro']) == 'anivers√°rio'

def test_maior_palavra_lista_1_elemento():
    assert maior_palavra(['feliz']) == 'feliz'

def test_maior_palavra_empate():
    assert maior_palavra(['gato', 'c√£o', 'sapo']) == 'gato'

def test_maior_palavra_strings_vazias():
    assert maior_palavra(['', '', '']) == ''

def test_maior_palavra_lista_vazia():
    assert maior_palavra([]) is None
```

## 

Repare em um detalhe importante do √∫ltimo teste.

- Para verificar se o retorno √© `None`, usamos `is None` em vez de `== None`.

. . .

√â que o operador `==` compara o conte√∫do de dois objetos.

- De forma similar ao `equals` no Java.
- J√° o operador `is` verifica se duas vari√°veis apontam para o mesmo objeto.
  - Que √© similar ao `==` do Java üòÅ

. . .

Como `None` √© um objeto √∫nico no Java, √© mais eficiente e seguro usar `is None` para verificar se uma vari√°vel √© `None`.

## Execu√ß√£o do `pytest`

Agora, para executar os testes, basta executar o comando `pytest` na pasta principal do projeto.

::: {.halfincfontsize}
```bash
pytest
```
:::

. . .

Se nossa fun√ß√£o passar em todos os testes, esse seria um exemplo de sa√≠da esperada.

```bash
=================== test session starts ===================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/julio/Downloads/aula_p2
collected 6 items

testes/test_maior_palavra.py ......                   [100%]

===================== 6 passed in 0.01s ====================

```

## 

Vamos agora for√ßar dois erros em nossa fun√ß√£o `maior_palavra`

- para ver como o `pytest` vai reportar esses erros.

::: {.halfincfontsize}
```python
def maior_palavra(palavras):
    # removemos a verifica√ß√£o de lista vazia
    maior = palavras[0]
    for p in palavras[1:]:
        # trocamos > por >=
        if len(p) >= len(maior):
            maior = p
    return maior
```
:::

## 

Obtemos ent√£o a seguinte sa√≠da com `pytest`.


```bash
==================== test session starts =====================
platform linux -- Python 3.12.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /home/julio/Downloads/aula_p2
collected 6 items                                            

testes/test_maior_palavra.py ...F.F                    [100%]

========================== FAILURES ==========================
_________________ test_maior_palavra_empate __________________

    def test_maior_palavra_empate():
>       assert maior_palavra(['gato', 'c√£o', 'sapo']) == 'gato'
E       AssertionError: assert 'sapo' == 'gato'
E         
E         - gato
E         + sapo

testes/test_maior_palavra.py:13: AssertionError
_______________ test_maior_palavra_lista_vazia _______________

    def test_maior_palavra_lista_vazia():
>       assert maior_palavra([]) == None
               ^^^^^^^^^^^^^^^^^

testes/test_maior_palavra.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

palavras = []

    def maior_palavra(palavras):
        # removemos a verifica√ß√£o de lista vazia
>       maior = palavras[0]
                ^^^^^^^^^^^
E       IndexError: list index out of range

meu_app/main.py:3: IndexError
================== short test summary info ===================
FAILED testes/test_maior_palavra.py::test_maior_palavra_empate - AssertionError: assert 'sapo' == 'gato'
FAILED testes/test_maior_palavra.py::test_maior_palavra_lista_vazia - IndexError: list index out of range
================ 2 failed, 4 passed in 0.04s =================
```

## 

Na sa√≠da anterior vemos que foram encontrados 6 testes dos quais dois n√£o passaram

```bash
collected 6 items                                            

testes/test_maior_palavra.py ...F.F                    [100%]
```

. . .

Em seguida s√£o apresentados detalhes dos testes que falharam.

- Que nos ajudam a identificar o problema para corrigi-lo.

# Atualizando o ciclo de projeto de fun√ß√µes {background-color="#40666e"}

##

Nas aulas anteriores vimos o **ciclo de projeto de fun√ß√µes**.

- Vamos agora atualiz√°-lo para incluir a etapa de testes.

##

- **A**. Defina o comportamento desejado da fun√ß√£o
- **B**. Escreva um prompt que descreve a fun√ß√£o
- **C**. Use o Copilot para gerar o c√≥digo
- **D**. O c√≥digo parece razo√°vel? Sim: **E**, n√£o: **I**.
- **E**. Escreva casos de teste usando pytest
- **F**. Rode os testes. Passou nos testes? Sim: **G**, n√£o: **J**
- **G**. Escreveu todos os casos de testes? Sim: **H**, n√£o: **E**
- **H**. Pronto!
- **I**. Explore alternativas do Copilot. Alguma parece razo√°vel?  Sim: **E**, n√£o: **J**
- **J**. Revise o prompt para melhorar a descri√ß√£o da fun√ß√£o e v√° para **C** .

##

```{mermaid}
flowchart TD
  A(Defina o comportamento desejado da fun√ß√£o) --> B(Escreva um prompt que descreve a fun√ß√£o)
  B --> C(Use o Copilot para gerar o c√≥digo)
  C --> D(O c√≥digo parece razo√°vel?)
  D --Sim--> E(Escreva casos de teste usando pytest)
  E --> F(Rode os testes. Passou nos testes?)
  F -- Sim --> G(Escreveu todos os casos de testes?)
  G -- Sim --> H(Pronto!)
  G -- N√£o --> E
  D -- N√£o --> I(Explore alternativas do Copilot. Alguma parece razo√°vel?)
  I -- Sim --> E
  I -- N√£o --> J(Revise o prompt para melhorar a descri√ß√£o da fun√ß√£o)
  J --> C
  F -- N√£o --> J
```

# Como testar seu c√≥digo? {background-color="#40666e"}

## 