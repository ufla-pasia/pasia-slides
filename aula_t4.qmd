---
title: Decomposi√ß√£o de Problemas
subtitle: PASIA - Aula T.4
---

##  

O conte√∫do dessa aula √© inspirado no **cap√≠tulos 7** do livro abaixo.

![](imagens/livro_potter_zingaro.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

# Introdu√ß√£o {background-color="#40666e"}

##

J√° comentamos em aulas anteriores que n√£o devemos pedir ao Copilot para resolver 
um problema muito grande de uma vez s√≥.

- Como: _Crie um jogo de estrat√©gia multiplayer desafiador e divertido_.

. . .

No pior caso, o Copilot n√£o vai gerar nada √∫til.

- H√° casos em que ele s√≥ fica gerando coment√°rios em sequ√™ncia.

##

E, na melhor das hip√≥teses, voc√™ teria um jogo _"enlatado"_ que n√£o √© muito divertido ou desafiador.

- Parte do poder de ser um programador √© conseguir customizar o que voc√™ cria.

. . .

Al√©m disso, imagina a dificuldade que seria corrigir todos os erros de um jogo inteiro gerado de uma vez.

. . .

N√≥s precisamos pedir ao Copilot para resolver pequenos problemas pra gente.

- E n√≥s mesmos vamos juntando esses peda√ßos em nossos programas.

##

O objetivo dessa aula √© aprender a quebrar um problema grande em subproblemas menores.

- De forma que consigamos resolver grandes problemas usando programa√ß√£o.

# Decomposi√ß√£o de Problemas {background-color="#40666e"}

##

[Decomposi√ß√£o de problemas]{.alert} envolve come√ßar com um problema grande e que n√£o 
est√° bem especificado

- e **quebr√°-lo em subproblemas**, os quais s√£o **bem definidos** e **√∫teis** para resolver o problema original.

. . .

Na aula vamos trabalhar com decomposi√ß√£o de fun√ß√µes.

- O que faremos portanto √© escrever fun√ß√µes para cada um dos subproblemas que identificamos.

##

Ao identificarmos um subproblema, pode ser que consigamos resolv√™-lo escrevendo uma fun√ß√£o.

- Ou pode se que ele ainda seja muito grande para ser implementado em uma √∫nica fun√ß√£o.
- E ent√£o precisaremos quebr√°-lo em sub-subproblemas.
  - Esperamos ent√£o que cada sub-suproblema seja pequeno o suficiente.
  - Mas se n√£o for, continuamos quebrando em subproblemas sucessivamente.

##

A principal **raz√£o** para decompormos problemas √© a **complexidade**.

. . .

Cada fun√ß√£o deve ser simples o suficiente de forma que:

- consigamos entender o seu prop√≥sito;
- consigamos pedir ao Copilot para implement√°-la;
- e, se tiver algum erro, n√£o tenhamos muitas dificuldades em resolv√™-lo.

## 

Quando escrevemos um c√≥digo que √© muito complexo, √© muito mais prov√°vel que cometamos erros.

- O mesmo vale para o Copilot.

. . .

E quando temos erros em c√≥digos grandes e complexos n√£o √© f√°cil encontr√°-los e corrigi-los.

. . .

_"√â dif√≠cil exagerar a import√¢ncia da decomposi√ß√£o de problemas para a qualidade de c√≥digo"_

##

No contexto da **Engenharia de Software** n√≥s chamamos a decomposi√ß√£o de problemas de
[design top-down]{.alert} (abordagem de cima pra baixo).

- Tem esse nome porque come√ßamos com uma tarefa grande que precisamos completar e a
  dividimos em tarefas menores.
- Durante o _design top-down_, n√≥s criamos a "casca" das fun√ß√µes que precisamos implementar.
- Depois que terminamos o _design_, podemos implementar o c√≥digo das fun√ß√µes definidas.

##

N√≥s geralmente acabamos tendo:

- uma fun√ß√£o para o problema completo
- que chama as fun√ß√µes que implementam os subproblemas.
- E cada fun√ß√£o de subproblema pode chamar fun√ß√µes de subsubproblemas.
- E assim sucessivamente.

. . .

Nesse processo, procuramos definir fun√ß√µes que recebem poucos par√¢metros e que
retornam poucas informa√ß√µes, mas √∫teis.

- O que ajuda muito a melhorar a facilidade de entendimento do c√≥digo.

# Pequenos exemplos de _design top-down_ {background-color="#40666e"}

##

Nas aulas anteriores j√° utilizamos alguns exemplos, ainda que simples, que poderiam ter sido tratados com _design top-down_.

. . .

N√≥s criamos, por exemplo, a fun√ß√£o `obter_senha_forte`

- que fica pedindo um usu√°rio para digitar uma senha at√© que ele digite uma senha forte.

. . .

Seguindo o _design top-down_ poder√≠amos identificar uma subtarefa dessa tarefa.

- Que √© verificar se uma senha √© forte.
- O que √© justamente o que a fun√ß√£o `eh_senha_forte` faz.

##

Podemos representar o _design top down_ como mostrado abaixo.

```{mermaid fontSize:25}
flowchart TD
  A(obter_senha_forte) --> B(eh_senha_forte)
```

## 

N√≥s tamb√©m trabalhamos com uma fun√ß√£o `melhor_palavra` que recebe uma
lista de palavras e retorna aquela que faz mais pontos no jogo _Scrabble_.

- Se tiv√©ssemos criando a fun√ß√£o usando _design top-down_, poder√≠amos 
identificar uma subtarefa que √© calcular a pontua√ß√£o de uma palavra.

. . .

Ter√≠amos ent√£o o seguinte _design top-down_:

```{mermaid fontSize:25}
flowchart TD
  A(melhor_palavra) --> B(numero_de_pontos)
```

##

Quando n√≥s criamos essas fun√ß√µes na aula passada, n√≥s n√£o usamos _design top-down_.

- N√≥s come√ßamos da subtarefa (fun√ß√£o folha) e depois criamos a fun√ß√£o que resolve o problema maior.

. . .

Agora, para implementar o c√≥digo das fun√ß√µes, n√≥s continuaremos a fazer dessa forma.

- Mas antes disso, vamos projetar quais s√£o as fun√ß√µes necess√°rias usando _design top-down_.

##

√â importante ressaltar que, para esses exemplos pequenos, pode parecer que n√£o faria
muita diferen√ßa usar ou n√£o _design top-down_.

- Ou at√© mesmo pode parecer desnecess√°rio implementar mais de uma fun√ß√£o.

. . .

Mas, para problemas maiores, a decomposi√ß√£o de problemas √© a √∫nica forma de manter
a complexidade sob controle.

- O nosso objetivo aqui √© adquirir a [habilidade]{.alert} de quebrar um problema em problemas menores.

# Sugest√µes de Corre√ß√£o Ortogr√°fica {background-color="#40666e"}

##

Vamos agora resolver um problema usando _design top-down_ desde o in√≠cio.

- Ao longo da disciplina, n√≥s vamos continuar abordando essa estrat√©gia.
- De forma que voc√™ consiga aplic√°-la com susesso por conta pr√≥pria.

. . .

Ops.. tem um erro na frase anterior.

- O correto √© _sucesso_ e n√£o _susesso_.

##

√â comum que erros de digita√ß√£o ocorram ou que tenhamos d√∫vidas sobre a ortografia de uma palavra.

- Ex.: exce√ß√£o ou exces√£o ou excess√£o?

. . .

O que n√≥s vamos fazer √© pegar uma palavra que pode estar escrita errada

- e oferecer sugest√µes de poss√≠veis corre√ß√µes para ela.

. . .

Ser√° um corretor ortogr√°fico b√°sico para palavras individuais.

##

N√≥s vamos tratar tr√™s tipos de erro de ortografia:

- letra faltando: como _suceso_ ao inv√©s de _sucesso_.
- letra sobrando: como _menssagem_ ao inv√©s de _mensagem_.
- letra trocada: como _viajem_ ao inv√©s de _viagem_.

##

Existem diversos outros erros de ortografia que n√£o cobriremos:

- Como o caso de _excess√£o_ ao inv√©s de _exce√ß√£o_ que tem uma letra trocada e uma letra sobrando.
- Ou de _metereologia_ em vez de _meteorologia_ que tem uma letra trocada e em posi√ß√£o errada.

. . .

Mas a ideia aqui √© aprendermos o _design top-down_ e n√£o criar um corretor ortogr√°fico perfeito.

- Os casos que trataremos ser√£o suficientes para o que precisamos.

# _Design top-down_ das Sugest√µes de Corre√ß√£o Ortogr√°fica {background-color="#40666e"}

##

A nossa tarefa √©:

- _Escrever um programa que pega uma palavra que pode estar escrita errada_
  _e oferece sugest√µes de poss√≠veis corre√ß√µes para ela._
- Essa tarefa √© certamente muito grande para ser tratada de uma vez s√≥.


##

Para dividi-la em subtarefas, a primeira sugest√£o √© tratar os tr√™s passos que s√£o
muito comuns em diversos programas:

1. Ler a entrada do usu√°rio.
2. Processar os dados.
3. Exibir a sa√≠da.

. . .

Obs.: n√≥s j√° t√≠nhamos usado isso no exemplo do processamento dos dados de futebol.

## 

<div style="font-size:0.8em">

| Fase | Papel  | Exemplo de uso com o Corretor |
|------|--------|-------------------------------|
| Entrada | Pegar, como entrada, a informa√ß√£o necess√°ria para a fun√ß√£o | Pegar a palavra errada _suceso_ e uma cole√ß√£o de palavras reais (com ortografia correta) |
| Processamento | Realizar as opera√ß√µes especificadas sobre os dados | Considerar altera√ß√µes na palavra que possam levar a uma palavra escrita corretamente (deve ser tentadas todas as combina√ß√µes dos 3 tipos de erros que estamos tratando; ex.: _sucesso_, mas tamb√©m _ssuceso_) |
| Sa√≠da | Exibir o resultado do processamento dos dados | Mostrar a sugest√£o _sucesso_ |

</div>

##

Seguindo essas etapas, come√ßamos nosso _design top-down_, divindo a tarefa do corretor em tr√™s subtarefas:

1. Entrada: pedimos ao usu√°rio uma palavra para a qual ele quer obter sugest√µes de corre√ß√£o.
2. Processamento: precisaremos descobrir todas as poss√≠veis sugest√µes para a palavra do usu√°rio.
3. Sa√≠da: exibimos para o usu√°rio todas as sugest√µes que encontramos.

. . .

E agora criaremos uma fun√ß√£o para cada subtarefa dessa, certo?

- Ou n√£o?

##

Apesar de muitas vezes criarmos uma fun√ß√£o para cada subtarefa, isso nem sempre √© necess√°rio.

- Veja que, para o tratamento da entrada do nosso problema, n√≥s precisamos apenas pedir uma palavra ao usu√°rio.
  - Acontece que Python j√° tem uma fun√ß√£o _input_ que faz exatamente isso.
  - Portanto uma fun√ß√£o para tratar a entrada teria apenas uma linha, o que parece uma divis√£o exagerada.
- A mesma coisa pode ser dita sobre o passo de sa√≠da.
  - J√° que Python j√° possui uma fun√ß√£o _print_ para isso.

##

N√£o √© que esteja errado se resolvermos criar fun√ß√µes para esses passos.

- Mas devemos refletir se vale realmente a pena criar fun√ß√µes com uma √∫nica linha.
  - Um caso onde isso √© √∫til √© se ela fizer algo que precisa ser repetido v√°rias vezes.

## Dividindo o subproblema de Processamento

Vamos focar ent√£o na etapa de processamento.

- Vamos chamar a fun√ß√£o de processamento de `_obter_sugestoes_correcao`.

- Quais par√¢metros a fun√ß√£o precisa receber?

. . .

Com certeza precisa receber a palavra que o usu√°rio digitou.

##

Ela poderia receber tamb√©m as palavras reais em portugu√™s, para que consiga fazer as sugest√µes.

- Isso pode ser feito de diferentes formas:
  - Ela pode receber a lista de palavras reais como um par√¢metro.
  - Ou o nome de um arquivo que cont√©m essas palavras.

## 

Esse tipo de decis√£o √© muito comum quando estamos fazendo decomposi√ß√£o de subproblemas.

- Para nosso exemplo, vamos usar como par√¢metro o nome de um arquivo.
- Isso porque temos um arquivo contendo quase 150 mil palavras reais em portugu√™s.
- Que foram obtidas atrav√©s de uma busca no Google (do reposit√≥rio [fserb/pt-br](https://github.com/fserb/pt-br)).

##

Esse √© o nosso _design top-down_ para o corretor at√© o momento:

- Considerando que a fun√ß√£o mais geral, do problema como um todo, se chama `corretor_ortografico`.

```{mermaid fontSize:40 height=500}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
```

##


E o que precisamos fazer na fun√ß√£o de processamento?

- Se pensarmos bem, podemos dividir a fun√ß√£o em 4 subproblemas.

  1. Obter uma lista de palavras a partir do arquivo.
  2. Gerar uma lista de todas as palavras poss√≠veis a partir da palavra digitada.
  3. A partir das palavras poss√≠veis, gerar uma lista contendo apenas palavras reais.
  4. Retornar uma lista contendo as palavras reais (as sugest√µes) sem repeti√ß√µes. 

##


Vamos acrescentar alguns detalhes a esses passos.

. . .

1. Obter uma lista de palavras a partir do arquivo.
  - Fun√ß√£o `carregar_lista_palavras` que carrega as palavras do arquivo em uma lista.
  - O arquivo tem uma palavra real do portugu√™s em cada linha.

##

2. Gerar uma lista de todas as palavras poss√≠veis a partir da palavra digitada.
  - Fun√ß√£o `gerar_palavras_possiveis` que recebe a palavra digitada e gera todas as combina√ß√µes poss√≠veis com os erros que estamos tratando.
  - Ou seja, ela gera uma lista enorme de strings: acrescentado uma letra, removendo uma letra ou trocando uma letra.
  - Vamos fazer isso sem nos preocuparmos aqui se essas strings formam uma palavra v√°lida ou n√£o.

##

3. A partir das palavras poss√≠veis, gerar uma lista contendo apenas palavras reais.
  - Fun√ß√£o `filtrar_palavras_reais` que recebe a lista de palavras poss√≠veis e a lista de palavras reais.
  - E retorna uma lista contendo apenas as palavras que est√£o nas duas listas.

##

4. Retornar uma lista contendo as palavras reais (as sugest√µes) sem repeti√ß√µes.
  - Fun√ß√£o `filtrar_palavras_repetidas`. Mas por que ela seria necess√°ria?
  - Porque, dependendo da forma como geramos as palavras poss√≠veis, podemos acabar com sugest√µes duplicadas.
  - Ex.: se a palavra digitada for _suceso_, podemos gerar _sucesso_ duas vezes.
    - Uma ao tentar acrescentar um _s_ depois do _e_,
    - e outra ao tentar trocar um _s_ ap√≥s o _s_ j√° existente na palavra.

##

At√© o momento no _design top-down_ pode ser demonstrado no diagrama abaixo.

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras)
  B --> C2(gerar_palavras_possiveis)
  B --> C3(filtrar_palavras_reais)
  B --> C4(filtrar_palavras_repetidas)
```

##

::: {.callout-tip}
## M√∫ltiplas formas de decompor um problema

N√£o h√° uma √∫nica forma correta de fazer um `design top-down`.

Voc√™ poderia ter pensado, por exemplo, em s√≥ gerar palavras que fossem reais,
filtrando as palavras j√° no momento em que foram geradas.

- Com isso a divis√£o de subproblemas seria diferente.
- E √© recomend√°vel que voc√™ tente outras alternativas de decomposi√ß√£o para esse mesmo problema.
:::

##

::: {.callout-tip}
## Decomposi√ß√£o √© um processo de tentativa e erro

√â muito comum que comecemos com uma ideia de `design top-down` e, no meio do processo,
percebamos que precisamos mudar nossa estrat√©gia.

- Talvez porque em algum ponto ficou dif√≠cil dividir em subproblemas.
- Ou porque chegamos a muitas fun√ß√µes que parecem muito espec√≠ficas (e n√£o seriam √∫teis para problemas mais gerais).
- Ou ainda porque estamos passando muitos par√¢metros para as fun√ß√µes ou passando um par√¢metro de fun√ß√£o em fun√ß√£o repetidamente.
- Ou, por fim, porque apenas queremos experimentar outra abordagem.

A recomenda√ß√£o √©: pr√°tica! Quanto mais praticar, mais habilidoso ser√° no processo de decomposi√ß√£o.
:::

## Carregar lista de palavras

Vamos agora pensar em cada subproblema gerado no √∫ltimo passo da decomposi√ß√£o.

- N√≥s precisamos quebrar a fun√ß√£o `carregar_lista_palavras` em subtarefas?

. . .

Poder√≠amos pensar em fases como: abrir o arquivo, carregar os dados em uma lista e fechar o arquivo.

- Mas pelo que vimos sobre arquivos do Python na aula passada, sabemos que abrir e fechar o arquivo √© algo muito simples.
- Ent√£o vamos manter essa tarefa em uma √∫nica fun√ß√£o.

## Gerar a lista de todas as palavras poss√≠veis

E a fun√ß√£o `gerar_palavras_possiveis` precisaria ser quebrada?

- Vamos pensar em como exatamente essas palavras candidatas seriam geradas.
- A ideia √© gerar todas as combina√ß√µes de adicionar uma letra, remover uma letra e trocar uma letra.
  - S√≥ de descrever essa ideia j√° percebemos que existem tr√™s opera√ß√µes distintas.
  - Que poderiam ent√£o ser tratadas como subproblemas.

## Gerar a lista de todas as palavras poss√≠veis

Poder√≠amos ent√£o quebrar a tarefa `gerar_palavras_possiveis` em tr√™s subtarefas:

1. `adicionar_letra`: que gera uma palavra candidata para cada letra do alfabeto em cada posi√ß√£o poss√≠vel.
  - Ex.: `suceso` -> `asuceso`, `bsuceso`, ..., `sauceso`, `sbuceso`, ..., `sucesoa`, `sucesob`.
2. `remover_letra`: que gera uma palavra candidata removendo cada letra da palavra original.
  - Ex.: `suceso` -> `uceso`, `sceso`, `sueso`, `sucso`, `suceo` e `suces`.

## Gerar a lista de todas as palavras poss√≠veis

3. `trocar_letra`: que gera uma palavra candidata para cada letra do alfabeto substituindo cada letra da palavra original.
  - Ex.: `suceso` -> `auceso`, `buceso`, ..., `saceso`, `sbceso`, ..., `sucesy`, ..., `sucesz`.

## Gerar a lista de todas as palavras poss√≠veis

Precisamos quebrar ainda mais as tarefas anteriores?

- Para cada tarefa, parece que precisaremos fazer um loop nas letras da palavra e/ou no alfabeto
- E gerar uma palavra para cada combina√ß√£o.

. . .

Por ora, vamos manter as tarefas como est√£o.

- Se, durante a fase de implementa√ß√£o percebermos que as tarefas s√£o mais complicadas que parecem n√≥s quebramos novamente.

##

::: {.callout-tip}
## Como saber quando parar de dividir em subtarefas?

Em geral, saber quando para de decompor um subproblema √© mais arte do que ci√™ncia.

√â necess√°ria muita pr√°tica para adquirir a intui√ß√£o de quando parar.
Desenvolvedores experientes costumam j√° imaginar em sua cabe√ßa como uma tarefa poderia 
ser resolvida para decidir se deve dividi-la ou n√£o.

Mas tudo bem se n√£o soubermos bem como fazer isso por agora. Podemos ter uma uma 
primeira vers√£o do _design_ e, durante a implementa√ß√£o, se uma fun√ß√£o se torna mais
complexa que o esperado, n√≥s a dividimos em subtarefas. Por outro lado, se uma
fun√ß√£o ficou muito pequena e espec√≠fica podemos reavaliar e n√£o ter receio de
junt√°-la a outras fun√ß√µes.
:::

## Gerar a lista de todas as palavras reais

A fun√ß√£o `filtrar_palavras_reais` receber√° duas listas, uma de palavras candidatas e
outra de palavras reais 

- E precisar√° retornar as palavras candidatas que existem tamb√©m na lista de palavras reais.

. . .

Se pensarmos um pouco em como resolver esse problema, n√£o parece algo t√£o complicado.

## Gerar a lista de todas as palavras reais

Podemos pensar em um loop que percorre a lista de palavras candidatas.

- E, para cada uma delas, verifica se ela existe tamb√©m na lista de palavras reais.
- Se existir √© adicionada na lista de resposta.

. . .

Parece um problema simples o suficiente para ser tratado por uma √∫nica fun√ß√£o.

## Filtrar palavras repetidas

E a fun√ß√£o `filtrar_palavras_repetidas`?

- Esse √© um exemplo de como seu conhecimento pr√©vio da linguagem pode mudar sua decis√£o.

. . . 

A princ√≠pio podemos manter a fun√ß√£o, pois podemos pensar em um loop que percorre a lista de palavras

- E, para cada palavra, a adicionamos na lista de resposta apenas se ela ainda n√£o estiver l√°.

## Filtrar palavras repetidas

Acontece que Python tem uma fun√ß√£o que remove duplica√ß√µes de uma lista com uma linha de c√≥digo.

- Ent√£o se souber disso, voc√™ pode concluir que a fun√ß√£o `filtrar_palavras_repetidas` √© desnecess√°ria.

## Resumo do _design top-down_ do corretor ortogr√°fico

Nosso _design top-down_ final √© o seguinte:

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras)
  B --> C2(gerar_palavras_possiveis)
  C2 --> D1(adicionar_letra)
  C2 --> D2(remover_letra)
  C2 --> D3(trocar_letra)
  B --> C3(filtrar_palavras_reais)
  B --> C4(filtrar_palavras_repetidas)
```

# Implementa√ß√£o das Sugest√µes de Corre√ß√£o Ortogr√°fica {background-color="#40666e"}

##

Ao fazer o design, n√≥s definimos as fun√ß√µes de cima para baixo (_top-down_).

- Mas na hora de implementar √© melhor escrever os c√≥digos das fun√ß√µes de baixo para cima (_bottom-up_).
- Por que?

. . .

Isso porque se gerarmos primeiro as fun√ß√µes de subproblemas finais usando Copilot,

- se torna mais prov√°vel que ele as utilize quando pedirmos para gerar o c√≥digo das fun√ß√µes de subproblemas maiores.

##

A estrat√©gia do livro √© focar na **Decomposi√ß√£o de Problemas** e, por isso, n√£o segue
cada passo do **Ciclo de projeto de fun√ß√µes** para cada fun√ß√£o.

- Mais especificamente, ele j√° apresenta a solu√ß√£o que preferiram, sem detalhar a **Engenharia de Prompt** utilizada.
- e n√£o acrescentam os **testes** das fun√ß√µes.

. . .

Eu planejei aqui incluir pelo menos os testes de fun√ß√µes.

- Que √© algo importante e geralmente subestimado pelos alunos, e at√© por professores üòú
- Mas vamos ver se o tempo da aula vai permitir passar por tudo.

## `carregar_lista_palavras`

Repare que come√ßar de baixo para cima n√£o significa necessariamente come√ßar pelo n√≠vel mais baixo do
design.

- O importante √© come√ßar por fun√ß√µes folha.
- E s√≥ implementar uma fun√ß√£o se todas as suas subfun√ß√µes estiverem implementadas.

. . .

Por isso, vamos come√ßar com a fun√ß√£o `carregar_lista_palavras`.

## `carregar_lista_palavras`

Como j√° fizemos anteriormente, vamos definir a assinatura e a docstring e deixar o Copilot gerar o c√≥digo.


```python
def carregar_lista_palavras(caminho_arquivo):
    """
    caminho_arquivo  √© o nome de um arquivo que tem uma palavra 
    em portugu√™s por linha.
    
    Retorna uma lista com as palavras do arquivo.
    """
```

## `carregar_lista_palavras`

Esse foi o c√≥digo gerado pelo Copilot no meu caso.

```python
def carregar_lista_palavras(caminho_arquivo):
    """
    caminho_arquivo  √© o nome de um arquivo que tem uma palavra 
    em portugu√™s por linha.
    
    Retorna uma lista com as palavras do arquivo.
    """
    with open(caminho_arquivo, 'r', encoding='utf-8') as f:
        palavras = f.read().splitlines()
    return palavras
```

## Testes da fun√ß√£o `carregar_lista_palavras`

Quais testes poder√≠amos pensar para a fun√ß√£o?

- Podemos criar tr√™s arquivos de teste: um vazio, um com uma palavra e um com v√°rias palavras.
- E criar uma fun√ß√£o de teste para cada caso.

. . .

No arquivo com uma palavra colocaremos:

```
exuberante
```

E no arquivo com v√°rias palavras

```
dinossauro
exuberante
melancia
tucano
```

## Testes da fun√ß√£o `carregar_lista_palavras`

Nossas fun√ß√µes de teste poderiam ser ent√£o:

```python
from pathlib import Path
from corretor.main import carregar_lista_palavras

PASTA_ARQUIVOS = Path(__file__).parent / 'dados'

def test_carregar_lista_palavras_vazia():
    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'arquivo_vazio.txt')
    assert palavras == []

def test_carregar_lista_palavras_uma_palavra():
    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'uma_palavra.txt')
    assert palavras == ['exuberante']

def test_carregar_lista_palavras_varias_palavras():
    palavras = carregar_lista_palavras(PASTA_ARQUIVOS / 'varias_palavras.txt')
    assert palavras == ['dinossauro', 'exuberante', 'melancia', 'tucano']
```

## Observa√ß√£o sobre os slides

Daqui por diante, na aula, n√≥s vamos criar todas as fun√ß√µes e suas respectivas fun√ß√µes
de teste em um projeto no VS Code.

- Esse projeto estar√° dispon√≠vel no reposit√≥rio [ufla-pasia/corretor-ortografico](https://github.com/ufla-pasia/corretor-ortografico).

. . .

J√° aqui nos slides vou manter apenas o prompt das fun√ß√µes (assinatura e docstring) e a
descri√ß√£o em alto n√≠vel dos testeas.

##

J√° implementamos ent√£o a fun√ß√£o que carrega as palavras. 

- Vamos agora para a pr√≥xima fun√ß√£o folha: `adicionar_letra`.


```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras fa:fa-check)
  B --> C2(gerar_palavras_possiveis)
  C2 --> D1(adicionar_letra)
  C2 --> D2(remover_letra)
  C2 --> D3(trocar_letra)
  B --> C3(filtrar_palavras_reais)
  B --> C4(filtrar_palavras_repetidas)
```

## `adicionar_letra`

```python
def adicionar_letra(palavra):
    """
    palavra √© uma string com pelo menos uma letra.

    Retorna uma lista com todas as strings que podem ser obtidas
    adicionando uma letra em qualquer posi√ß√£o da palavra.
    """
```

Obs.: para simplificar, vamos ignorar o acr√©scimo de letras com acentos.

. . .

Testes: 

- palavra comum (_boi_), palavra de uma letra (_a_), palavra com letra repetida (_passar_)

##

A pr√≥xima fun√ß√£o agora ser√° `remover_letra`.

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras fa:fa-check)
  B --> C2(gerar_palavras_possiveis)
  C2 --> D1(adicionar_letra fa:fa-check)
  C2 --> D2(remover_letra)
  C2 --> D3(trocar_letra)
  B --> C3(filtrar_palavras_reais)
  B --> C4(filtrar_palavras_repetidas)
```

## `remover_letra`

```python
def remover_letra(palavra):
    """
    palavra √© uma string com pelo menos uma letra.

    Retorna uma lista com todas as strings que podem ser obtidas
    removendo uma letra de qualquer posi√ß√£o da palavra.
    """
```

. . .

Testes: 

- palavra comum (_boi_), palavra de uma letra (_a_), palavra com letra repetida (_passar_)


## `trocar_letra`

```python
def trocar_letra(palavra):
    """
    palavra √© uma string com pelo menos uma letra.

    Retorna uma lista com todas as strings que podem ser obtidas
    trocando uma letra de qualquer posi√ß√£o da palavra por outra letra.
    """
```

. . .

Testes: 

- palavra comum (_boi_), palavra de uma letra (_a_), palavra com letra repetida (_passar_)

##

Agora n√≥s j√° temos todos os subproblemas da fun√ß√£o `gerar_palavras_possiveis` resolvidos e, 
portanto, podemos implement√°-la.

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras fa:fa-check)
  B --> C2(gerar_palavras_possiveis)
  C2 --> D1(adicionar_letra fa:fa-check)
  C2 --> D2(remover_letra fa:fa-check)
  C2 --> D3(trocar_letra fa:fa-check)
  B --> C3(filtrar_palavras_reais)
  B --> C4(filtrar_palavras_repetidas)
```


## `gerar_palavras_possiveis`

```python
def gerar_palavras_possiveis(palavra):
    """
    palavra √© uma string com pelo menos uma letra.

    Retorna uma lista com todas as palavras poss√≠veis que podem ser geradas
    a partir da palavra original, atrav√©s das opera√ß√µes de adicionar, remover
    ou trocar uma letra.
    """
```

. . .

Testes: 

- palavra comum (_boi_), palavra de uma letra (_a_), palavra com letra repetida (_passar_)

##

Nosso sistema est√° evoluindo bem. Pr√≥ximo passo: `filtrar_palavras_reais` e depois 
`filtrar_palavras_repetidas`.

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras fa:fa-check)
  B --> C2(gerar_palavras_possiveis fa:fa-check)
  C2 --> D1(adicionar_letra fa:fa-check)
  C2 --> D2(remover_letra fa:fa-check)
  C2 --> D3(trocar_letra fa:fa-check)
  B --> C3(filtrar_palavras_reais)
  B --> C4(filtrar_palavras_repetidas)
```



## `filtrar_palavras_reais`

```python
def filtrar_palavras_reais(lista_palavras, palavras_possiveis):
    """
    lista_palavras √© uma lista de strings com palavras em portugu√™s.
    palavras_possiveis √© uma lista de palavras poss√≠veis.

    Retorna uma lista das palavras poss√≠veis que est√£o na lista de palavras.
    """
```


## `filtrar_palavras_repetidas`

```python
def filtrar_palavras_repetidas(palavras_reais):
    """
    palavras_reais √© uma lista de strings com palavras em portugu√™s.

    Retorna a lista sem palavras repetidas.
    """
```

. . .

Testes: 

- uma palavra sugerida, v√°rias palavras sugeridas e nenhuma palavra sugerida.

##

J√° resolvemos todos os subproblemas da fun√ß√£o `obter_sugestoes_correcao` e hora de implement√°-la.

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao)
  B --> C1(carregar_lista_palavras fa:fa-check)
  B --> C2(gerar_palavras_possiveis fa:fa-check)
  C2 --> D1(adicionar_letra fa:fa-check)
  C2 --> D2(remover_letra fa:fa-check)
  C2 --> D3(trocar_letra fa:fa-check)
  B --> C3(filtrar_palavras_reais fa:fa-check)
  B --> C4(filtrar_palavras_repetidas fa:fa-check)
```



## `obter_sugestoes_correcao`

```python
def obter_sugestoes_correcao(caminho_arquivo, possivel_palavra):
    """
    caminho_arquivo √© o nome de um arquivo que tem uma palavra 
    em portugu√™s por linha.
    possivel_palavra √©  uma string que pode ser ou n√£o uma 
    palavra real em portugu√™s.

    Retorna a lista de todas as poss√≠veis corre√ß√µes √∫nicas para 
    a poss√≠vel palavra.
    """
```

. . .

Testes: 

- Situa√ß√µes que retornem uma sugest√£o, v√°rias sugest√µes e nenhuma sugest√£o.


##

Ufa... agora s√≥ falta a fun√ß√£o principal e terminamos nosso corretor.

```{mermaid}
flowchart TD
  A(corretor_ortografico) --> B(obter_sugestoes_correcao fa:fa-check)
  B --> C1(carregar_lista_palavras fa:fa-check)
  B --> C2(gerar_palavras_possiveis fa:fa-check)
  C2 --> D1(adicionar_letra fa:fa-check)
  C2 --> D2(remover_letra fa:fa-check)
  C2 --> D3(trocar_letra fa:fa-check)
  B --> C3(filtrar_palavras_reais fa:fa-check)
  B --> C4(filtrar_palavras_repetidas fa:fa-check)
```

## `corretor_ortografico`

```python
def corretor_ortografico(caminho_arquivo):
    """
    caminho_arquivo √© o nome de um arquivo que cont√©m palavras 
    em portugu√™s.

    Pede ao usu√°rio uma palavra e exibe todas as poss√≠veis corre√ß√µes 
    para aquela palavra, uma por linha.
    """
```

. . .

Testes:

- Como a fun√ß√£o n√£o retorna valores precisar√≠amos simular a intera√ß√£o com o usu√°rio para test√°-la.
- A biblioteca `pytest` tem fun√ß√µes avan√ßadas para isso.
- Mas esse n√£o √© o nosso foco aqui, ent√£o vamos testar manualmente.

# Experimentando Sugest√µes de Corre√ß√£o Ortogr√°fica {background-color="#40666e"}

## 

Vamos ent√£o experimentar nosso corretor ortogr√°fico.

- Que palavras seria interessante usar?

. . .

Algumas sugest√µes interessantes s√£o:

- suceso, susesso, beje, lage, an√°lize, asia, ancioso, previl√©gio, impecilho, brusa, beneficiente, retr√≥gado, sombrancelha.
- [Essa p√°gina](https://www.dicio.com.br/erros-de-ortografia/) traz outros erros comuns de ortografia em portugu√™s que 
  voc√™ poderia querer testar.

# Conclus√µes {background-color="#40666e"}

## Miss√£o Cumprida üëè

Completamos nosso primeiro _design top-down_ de um problema do mundo real.

- Fizemos um gerador de sugest√µes de corre√ß√£o que faz o que v√°rios desses sistemas fazem.

. . .

O problema se tornou consideravelmente mais f√°cil de implementar,

- por que primeiro n√≥s dividimos o problema em subproblemas.

##

Muitos especialistas em Computa√ß√£o consideram que **decomposi√ß√£o de problemas** √©
[a]{.alert} **habilidade** mais cr√≠tica necess√°ria para se escrever bons softwares.

. . .

Essa habilidade continua cr√≠tica mesmo usando Assistentes de IA como o Copilot e o ChatGPT.

- Pois eles trazem respostas muito melhores para problemas menores, claros e bem definidos.

##

Como mencionamos no in√≠cio, decomposi√ß√£o de problemas √© mais arte que ci√™ncia.

- E, portanto, exige pr√°tica para fazer isso bem.

. . .

Ao longo da disciplina, aplicaremos a decomposi√ß√£o de problemas em outros exemplos.

- O que te ajudar√° a ganhar mais experi√™ncia com essa habilidade t√£o importante.
