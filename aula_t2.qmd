---
title: Projetando Fun√ß√µes
subtitle: PASIA - Aula T.2
---

##  

O conte√∫do dessa aula √© baseado no cap√≠tulo 3 do livro abaixo.

![](imagens/livro_potter_zingaro.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

##

Pela pesquisa de perfil da turma vi que alguns alunos conhecem bem Python e outros n√£o.

- √â importante ent√£o apresentar a linguagem nas primeiras aulas.
- Mas, junto com a apresenta√ß√£o da linguagem, vou apresentar tamb√©m boas pr√°ticas e dicas de uso do Copilot.

. . .

Espero ent√£o que a aula seja √∫til para todos :)

# Introdu√ß√£o {background-color="#40666e"}

##  

Um dos desafios para programadores iniciantes usarem o Copilot

- √© saber o que √© uma tarefa razo√°vel para que ele consiga gerar uma boa solu√ß√£o.

. . .

Como j√° mencionamos antes, passar uma tarefa muito grande para o Assistente de IA

- pode fazer com que ele falhe
- e falhe de uma forma que seja muito dif√≠cil de corrigir.


##

Na verdade essa quest√£o de complexidade n√£o √© um problema s√≥ para o Copilot, mas para n√≥s mesmos.

- Engenheiros de Software que tentam resolver problemas muito complexos sem quebr√°-los em partes menores tamb√©m falham.

. . .

Existem diversas formas de tratar, no c√≥digo, a decomosi√ß√£o de um problema em partes.

- A mais simples delas √© a atrav√©s de fun√ß√µes.

##

Uma fun√ß√£o √© um trecho de c√≥digo que resolve uma tarefa espec√≠ficia

- E que n√£o √© t√£o complexo a ponto de ficar dif√≠cil de implementar e testar.

##

Claro que voc√™s j√° sabem o que s√£o fun√ß√µes e como elas podem ser implementadas.

- Mas ser√° que voc√™s sabem quais s√£o os crit√©rios para projetar boas fun√ß√µes?
- Ser√° pensam nisso na hora de programar, ou simplesmente saem programando?
- Al√©m disso, no contexto do uso de IA, quais seriam as melhores pr√°ticas para projetar fun√ß√µes?

# Fun√ß√µes {background-color="#40666e"}

## 

Uma fun√ß√£o √© uma pequena tarefa que pode ser usada para resolver tarefas maiores.

- Essas tarefas maiores, por sua vez, podem ser usadas para resolver tarefas maiores ainda.

##

Para exemplificar, encontre as palavras abaixo no quebra-cabe√ßa.

![](imagens/fig3-1_word_puzzle.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

## 

Qual foi o racioc√≠nio que voc√™ usou para encontrar as palavras?

- Procurar todas as palavras de uma vez √© uma tarefa muito grande e complicada.

. . .

Voc√™ poderia, por exemplo, escolher uma palavra para encontrar primeiro.

- E, para encontrar uma √∫nica palavra, poder√≠amos procurar a primeira letra.
  - E ent√£o procurar a palavra buscando para a direita, esquerda, para cima ou para baixo.

##

Repare que estamos decompondo o problema de resolver o ca√ßa-palavras

- em tarefas menores, que, se resolvidas, nos ajudam a resolver o problema como um todo.

. . .

√â essa a estrat√©gia que precisamos seguir na hora de programar.

##

Uma fun√ß√£o pode ser vista como um contrato.

- Se existir uma fun√ß√£o `maior` e for dito que ela recebe dois n√∫meros e retorna o maior deles,
- n√≥s podemos acreditar que se a fun√ß√£o for chamada com os n√∫meros 2 e 5, ela retornar√° 5.
  - N√≥s n√£o precisamos saber como a fun√ß√£o funciona para utiliz√°-la.
- Da mesma forma que n√£o precisamos entender de mec√¢nica de carros para frear um carro.
  - N√≥s acionamos o pedal e sabemos que a velocidade do carro vai diminuir.

##

Na aula passada usamos o Copilot para gerar c√≥digo a partir de um coment√°rio.

- Podemos fazer o mesmo para criar fun√ß√µes.

. . .

Vamos fazer um exemplo:

::: {.halfincfontsize}
```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
```
:::

##

::: {.halfincfontsize}
```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```
:::

Esse √© um poss√≠vel resultado gerado pelo Copilot.

##

```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```
- Note que assinatura de uma fun√ß√£o em python come√ßa com a palavra-chave `def`.
  - √â isso que diz para o Python que o que vem a seguir √© uma fun√ß√£o.
- Depois vem o nome da fun√ß√£o (`maior_numero`, nesse caso).
  - Dica: se parecer dif√≠cil escolher um nome para a fun√ß√£o, pode ser um sinal de que ela est√° fazendo muitas coisas.

##

```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```

- Em seguida, temos os par√¢metros da fun√ß√£o, que s√£o as entradas que ela recebe.
- Por fim, temos o corpo da fun√ß√£o, que √© onde a l√≥gica √© implementada.
  - Uma fun√ß√£o pode retornar valores ou n√£o. 
  - Quando ela retorna usamos a palavra-chave `return`.

##

```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```

Veja que, diferente de linguagens fortemente tipadas, em Python n√£o precisamos especificar os tipos

  - nem dos par√¢metros e nem do retorno da fun√ß√£o.

# Fun√ß√µes (dicas avan√ßadas) {background-color="#40666e"}

##

Dica para programadores avan√ßados:

- Apesar de Python n√£o ser fortemente tipado
  - √© uma boa pr√°tica usar [anota√ß√µes de tipo]{.alert} (_type hints_) para melhorar a legibilidade do c√≥digo.
- Isso ajuda muito na implementa√ß√£o de sistemas maiores.
- Mas afinal, o que √© isso?


## 

Vamos gerar novamente a fun√ß√£o `maior_numero`, mas agora com _type hints_.

::: {.halfincfontsize}
```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
# use anota√ß√£o de tipos
```
:::

::: {.halfincfontsize}
```python {.fragment start=6}
def maior_numero(a: int, b: int) -> int:
  if a > b:
    return a
  else:
    return b    
```
:::

## 

As anota√ß√µes de tipo servem como documenta√ß√£o e podem ser utilizadas por ferramentas de an√°lise sint√°tica.

- Ou seja, s√£o √∫teis para dizer para outros programadores o que exatamente a fun√ß√£o espera e o que retorna.
- E, principalmente, para que as IDEs, como o VS Code, apontem poss√≠veis erros antes mesmo de rodar o c√≥digo.
  - Isso melhora a qualidade do c√≥digo e facilita a manuten√ß√£o.

. . .

Experimente, por exemplo, chamar a fun√ß√£o no VS Code passando uma string.

## 

Mas √© importante deixar claro que os _type hints_ n√£o alteram o comportamento do c√≥digo.

- Como Python n√£o √© uma linguagem compilada, o c√≥digo vai ser executado
  - e os _type hints_ s√£o ignorados em tempo de execu√ß√£o.
- Ou seja, se a fun√ß√£o for chamada passando um par√¢metro de tipo errado
  - isso n√£o causar√° um erro imediatamente, mas pode levar a comportamentos inesperados.
  - Na verdade quando d√° erro √© at√© melhor, o problema maior √© quando passa batido.


# Criando fun√ß√µes com Copilot {background-color="#40666e"}

## 

N√≥s hav√≠amos passado para o Copilot a tarefa de criar a fun√ß√£o completa.

- Mas outra forma de usar o Copilot √© n√≥s mesmos definirmos a assinatura da fun√ß√£o
- E pedirmos ao Copilot apenas para implementar o corpo da fun√ß√£o.
  - Isso geralmente leva a resultados melhores.

##

N√≥s podemos fazer isso usando [docstrings]{.alert}.

- Docstrings s√£o strings de documenta√ß√£o que podem ser usadas para descrever o que uma fun√ß√£o faz.
- Elas s√£o definidas logo abaixo da assinatura da fun√ß√£o e s√£o delimitadas por tr√™s aspas duplas.

. . .

::: {.callout-tip collapse=\"true\"}
√â uma boa pr√°tica escrever docstrings para suas fun√ß√µes.
:::


##

N√≥s poder√≠amos ent√£o gerar a fun√ß√£o `maior_numero` de forma diferente

- Escrevendo n√≥s mesmos o cabe√ßalho e a docstring da fun√ß√£o.
- E deixando o Copilot gerar o corpo da fun√ß√£o.
  - O que torna a gera√ß√£o do c√≥digo mais f√°cil para o Copilot.

##

Vamos ent√£o refazer a fun√ß√£o, mas agora n√≥s definimos o cabe√ßalho e docstring da fun√ß√£o.

::: {.halfincfontsize}
```python
def maior_numero(num1, num2):
  """
  num1 e num2 s√£o dois n√∫meros.

  Retorna o maior dos dois n√∫meros.
  """
```
:::

##

O Copilot pode ent√£o gerar o corpo da fun√ß√£o.

::: {.halfincfontsize}
```python
def maior_numero(num1, num2):
  """
  num1 e num2 s√£o dois n√∫meros.

  Retorna o maior dos dois n√∫meros.
  """
  if num1 > num2:
    return num1
  else:
    return num2
```
:::

##

Para terminar, vamos pedir ao Copilot para chamar a fun√ß√£o que criamos.

::: {.halfincfontsize}
```python
# chame a funcao maior_numero com os valores 3 e 5
# armazene o resultado em uma vari√°vel chamada 
# resultado e ent√£o exiba o resultado
```
:::

::: {.halfincfontsize}
```python {.fragment start=4}
resultado = maior_numero(3, 5)
print(resultado)
```
:::

##

O ciclo de projeto de fun√ß√µes com Copilot.

 1. Defina o comportamento desejado para a fun√ß√£o
 2. Escreva um prompt que descreva a fun√ß√£o
 3. Deixe o Copilot gerar o c√≥digo
 4. Avalie o c√≥digo para conferir se ele parece razo√°vel
 5. Teste o c√≥digo para conferir se ele est√° correto
  - Se estiver correto, a fun√ß√£o est√° pronta.
  - Se n√£o estiver, volte ao passo 2.

# Exemplos de boas fun√ß√µes com Copilot {background-color="#40666e"}

## Investimentos em Bolsa do Ti√£o

Ti√£o √© um investidor em uma a√ß√£o chamada PASIA.

- Ele comprou 10 a√ß√µes por R$ 15.
- Agora cada a√ß√£o vale R$ 17.
- Ele quer saber quanto lucro teria se vendesse as a√ß√µes agora.

##

Essa seria uma boa fun√ß√£o para calcular o lucro do Ti√£o?

. . .

::: {.halfincfontsize}
```python
def calcular_lucro():
  return (17 - 15) * 10
```
:::

. . .

N√£o, essa fun√ß√£o n√£o √© boa. 

- Por que?

##

Quando criamos uma fun√ß√£o devemos cri√°-la da forma **mais geral poss√≠vel**.

- Com isso, **a fun√ß√£o pode ser reutilizada** em diferentes contextos.
- Repare que, no caso do Ti√£o, ele n√£o quer saber o lucro apenas de uma compra espec√≠fica
  - mas sim de qualquer compra que ele fa√ßa.

. . .

Mesmo que voc√™ ache que isso parece muito simples.

- √â muito comum que programadores experientes repitam esse erro em contextos mais complexos.

##

Como deveria ser a assinatura da fun√ß√£o, de forma que ela seja mais √∫til?

- Quais par√¢metros deveria receber?
  - a quantidade de a√ß√µes compradas  
  - o valor que as a√ß√µes foram compradas  
  - e o pre√ßo de venda das a√ß√µes.

. . .

Poder√≠amos ent√£o definir a assinatura assim:

::: {.fontsize125}
```python
def calcular_lucro(qtd_acoes, valor_compra, valor_venda)
```
:::

##

:::{.nonincremental}
Seguindo a estrat√©gia que vimos antes, 

- vamos criar uma docstring para explicar ao Copilot o que a a√ß√£o precisa fazer.
:::

. . .

::: {.callout-tip collapse=\"true\"}
Claro que essa fun√ß√£o √© muito simples e voc√™ poderia pedir ao Copilot para criar
inclusive a assinatura e a docstring.

Mas a ideia aqui √© que voc√™ entenda o processo com uma fun√ß√£o simples, para que
depois possa aplicar para fun√ß√µes mais complexas.
:::

##

::: {.fontsize125}
```python
def calcular_lucro(qtd_acoes, valor_compra, valor_atual):
  """
  qtd_acoes √© a quantidade de a√ß√µes compradas
  valor_compra √© o valor de cada uma dessas a√ß√µes
  valor_atual √© o valor atual dessas a√ß√µes
  """
```
:::

. . .

Podemos agora pedir ao Copilot para gerar o corpo da fun√ß√£o.

##

::: {.fontsize125}
```python
def calcular_lucro(qtd_acoes, valor_compra, valor_atual):
  """
  qtd_acoes √© a quantidade de a√ß√µes compradas
  valor_compra √© o valor de cada uma dessas a√ß√µes
  valor_atual √© o valor atual dessas a√ß√µes
  """
  return (valor_atual - valor_compra) * qtd_acoes
```
:::

## 

::: {.nonincremental}

N√≥s j√° fizemos os tr√™s passos iniciais do ciclo de design de fun√ß√µes.

1. Defina o comportamento desejado para a fun√ß√£o
2. Escreva um prompt que descreva a fun√ß√£o
3. Deixe o Copilot gerar o c√≥digo
4. Avalie o c√≥digo para conferir se ele parece razo√°vel
5. Teste o c√≥digo para conferir se ele est√° correto

:::

##

O pr√≥ximo passo √© [avaliar se o c√≥digo parece razo√°vel]{.alert}.

::: {.fontsize125}
```python
  return (valor_atual - valor_compra) * qtd_acoes
```
:::

. . .

Em uma fun√ß√£o simples, assim esse passo √© f√°cil :)

## 

O passo seguinte √© [testar o c√≥digo]{.alert}.

- E aqui vai uma dica interessante de uso do VS Code para testar c√≥digos Python.

. . .

Voc√™ pode selecionar o c√≥digo da fun√ß√£o no VS Code.

- E apertar <kbd>Shift</kbd> + <kbd>Enter</kbd>
- Ao fazer isso, o trecho de c√≥digo selecionado ser√° executado em um terminal Python.
- E voc√™ poder√° ent√£o fazer chamadas de teste a essa fun√ß√£o no terminal Python.

## 

::: {.nonincremental}
Um primeiro teste √≥bvio que poder√≠amos fazer 

- √© calcular o lucro da compra espec√≠fica de a√ß√µes do Ti√£o.
:::

. . .

::: {.fontsize125}
```python {code-line-numbers="false"}
>>>  calcular_lucro(10, 15, 17)
```
:::

::: {.fontsize125}
```python {.fragment code-line-numbers="false"}
20
```
:::

. . .

Est√° certo?

- Sim, como ele teve 2 reais de lucro em cada a√ß√£o e s√£o 10 a√ß√µes, o total √© 20.

. . .

Precisamos agora pensar em mais [casos de testes]{.alert}.

##

Testar se as a√ß√µes tivessem subido para R$ 18 em vez de R$ 17 seria um bom teste?

- N√£o, porque seria um teste de um caso na **mesma categoria** do teste anterior.
- Precisamos pensar em situa√ß√µes diferentes.

. . .

Por exemplo:

- Uma situa√ß√£o que desse preju√≠zo.
- Ou que as a√ß√µes permanecessem no mesmo pre√ßo.

##

Podemos inverter o pre√ßo de compra e o atual para testar o preju√≠zo.

::: {.fontsize125}

```python {code-line-numbers="false"}
>>>  calcular_lucro(10, 17, 15)
```
```python {.fragment code-line-numbers="false"}
-20
```
:::

. . .

E testar o caso do pre√ßo da a√ß√£o ser mantido

::: {.fontsize125}
```python {code-line-numbers="false"}
>>>  calcular_lucro(10, 15, 15)
```
```python {.fragment code-line-numbers="false"}
0
```
:::

##

Mas como saber quantas categorias testar?

- Como ter certeza se dois testes n√£o s√£o da mesma categoria?
- Ou se eles cobrem todas categorias poss√≠veis?

. . .

Testes s√£o uma combina√ß√£o de **ci√™ncia üß™** e **arte üé®**

- √â necess√°rio pr√°tica e experi√™ncia para definir bem casos de testes.
- E vamos ter aula espec√≠fica sobre isso mais adiante na disciplina.

## A senha do Ti√£o

Ti√£o est√° se inscrevendo em uma nova rede social chamada _ProgrammersKingdom_.

- Ele quer ter certeza que a senha que ele vai usar √© forte o suficiente.

. . .

Vamos come√ßar com uma defini√ß√£o bem simples do que √© uma senha forte.

- E depois vamos melhorar a fun√ß√£o.
- No meio do caminho vamos nos acostumando com a sintaxe do Python.

##

A princ√≠pio, vamos considerar que uma senha √© forte se ela n√£o for `'1234'` ou `'senha'`.

- Vamos ent√£o definir o cabe√ßalho e a docstring de uma fun√ß√£o que recebe uma
  poss√≠vel senha e retorna se ela √© forte ou n√£o.

. . .

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha'

    Retorna True se a senha for forte e False em caso contr√°rio
    """    
```
:::

##

Suponha que seja esse o c√≥digo gerado.

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha'

    Retorna True se a senha for forte e False em caso contr√°rio
    """    
    if senha == "1234" or senha == "senha":
        return False
    return True
```
:::

. . .

Seguindo pr√≥ximo passo do **ciclo de design de fun√ß√µes**, avaliamos se o c√≥digo parece razo√°vel.

- O que acha?

##

Vamos agora testar a fun√ß√£o usando <kbd>Shift</kbd> + <kbd>Enter</kbd> no VS Code.

::: {.fontsize125}

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("1234")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("senha")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("admin")
```
```python {.fragment code-line-numbers="false"}
True
```

:::

. . . 

`'admin'` claramente n√£o √© uma senha forte üôÇ

##

Vamos melhorar a defini√ß√£o da nossa fun√ß√£o.

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha' ou 'admin'

    Retorna True se a senha for forte e False em caso contr√°rio
    """    
```
```python {.fragment}  
    if senha in ['1234', 'senha', 'admin']:
        return False
    return True

```
:::

##

```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha' ou 'admin'

    Retorna True se a senha for forte e False em caso contr√°rio
    """
    if senha in ['1234', 'senha', 'admin']:
        return False
    return True

```

Repare que, nesse caso, o Copilot gerou um c√≥digo que usa uma [lista]{.alert}.

- Podemos declarar listas em Python entre colchetes e com valores separados por v√≠rgulas.
- E o operador `in` indica se um elemento pertence √† lista.

. . .

O c√≥digo parece razo√°vel? Hora de testar!

##

Mas nossa fun√ß√£o ainda aceita `'Ti√£o'` como senha, o que √© claramente ruim.

- Vamos ent√£o deixar a defini√ß√£o de senha forte, mais forte üí™.

##

```python
def eh_senha_forte(senha):
    """
    Uma senha forte tem pelo menos uma letra mai√∫scula,
    uma letra min√∫scula, um n√∫mero e um caractere especial.

    Retorna True se a senha for forte e False em caso contr√°rio
    """  
```
```python {.fragment start=8}
    tem_maiuscula = any(c.isupper() for c in senha)
    tem_minuscula = any(c.islower() for c in senha)
    tem_numero = any(c.isdigit() for c in senha)
    tem_especial = any(not c.isalnum() for c in senha)
    return tem_maiuscula and tem_minuscula and tem_numero and tem_especial
```

. . .

O c√≥digo gerado pelo Copilot parece bem claro sobre o que est√° fazendo no geral.

- Mas h√° constru√ß√µes de Python nos detalhes que podem ser melhor exploradas.

## 

Vamos pedir ao Copilot para explicar o trecho `c.isupper() for c in senha`.

- Para isso, aperte <kbd>Ctrl</kbd> + <kbd>I</kbd> e digite `explique essa constru√ß√£o do python`.

##

Essa √© uma poss√≠vel resposta do Copilot.

<div style="overflow:auto; max-height:400px; text-align:center;">
  <img src="imagens/copilot_explicacao_senhaforte.png" alt="Explica√ß√£o do Copilot sobre o trecho c.isupper() for c in senha." style="width:auto; max-width:100%;">
</div>

. . .

Esse √© um bom exemplo de como o Copilot pode nos ajudar a entender um c√≥digo j√° implementado.


