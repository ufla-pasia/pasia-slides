---
title: Projetando Fun√ß√µes
subtitle: PASIA - Aula T.2
---

##  

O conte√∫do dessa aula √© baseado no cap√≠tulo 3 do livro abaixo.

![](imagens/livro_potter_zingaro.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

##

Pela pesquisa de perfil da turma vi que alguns alunos conhecem bem Python e outros n√£o.

- √â importante ent√£o apresentar a linguagem nas primeiras aulas.
- Mas, junto com a apresenta√ß√£o da linguagem, vou apresentar tamb√©m boas pr√°ticas e dicas de uso do Copilot.
  - que podem ser interessantes tamb√©m para que tem mais experi√™ncia com Python.
- Espero ent√£o que a aula seja √∫til para todos :)

. . .

::: {.callout-caution}
## Lembrete

Lembre-se que **Assistentes de IA s√£o n√£o determin√≠sticos**. 
Portanto, ao experimentar os exemplos dessa, aula voc√™ pode obter resultados diferentes.
:::

# Introdu√ß√£o {background-color="#40666e"}

##  

Um dos desafios para programadores iniciantes usarem o Copilot

- √© saber o que √© uma tarefa razo√°vel para que ele consiga gerar uma boa solu√ß√£o.

. . .

Como j√° mencionamos antes, passar uma tarefa muito grande para o Assistente de IA

- pode fazer com que ele falhe
- e falhe de uma forma que seja muito dif√≠cil de corrigir.


##

Na verdade essa quest√£o de complexidade n√£o √© um problema s√≥ para o Copilot, mas para n√≥s mesmos.

- Engenheiros de Software que tentam resolver problemas muito complexos sem quebr√°-los em partes menores tamb√©m falham.

. . .

Existem diversas formas de tratar, no c√≥digo, a decomosi√ß√£o de um problema em partes.

- A mais simples delas √© a atrav√©s de fun√ß√µes.

##

Uma fun√ß√£o √© um trecho de c√≥digo que resolve uma tarefa espec√≠ficia

- E que n√£o √© t√£o complexo a ponto de ficar dif√≠cil de implementar e testar.

##

Claro que voc√™s j√° sabem o que s√£o fun√ß√µes e como elas podem ser implementadas.

- Mas ser√° que voc√™s sabem quais s√£o os crit√©rios para projetar boas fun√ß√µes?
- Ser√° pensam nisso na hora de programar, ou simplesmente saem programando?
- Al√©m disso, no contexto do uso de IA, quais seriam as melhores pr√°ticas para projetar fun√ß√µes?

# Fun√ß√µes {background-color="#40666e"}

## 

Uma fun√ß√£o √© uma pequena tarefa que pode ser usada para resolver tarefas maiores.

- Essas tarefas maiores, por sua vez, podem ser usadas para resolver tarefas maiores ainda.

##

Para exemplificar, encontre as palavras abaixo no quebra-cabe√ßa.

![](imagens/fig3-1_word_puzzle.png){fig-align="center" fig-alt="Capa do livro de Potter e Zingaro." style="max-height: 50vh; width: auto;"}

## 

Qual foi o racioc√≠nio que voc√™ usou para encontrar as palavras?

- Procurar todas as palavras de uma vez √© uma tarefa muito grande e complicada.

. . .

Voc√™ poderia, por exemplo, escolher uma palavra para encontrar primeiro.

- E, para encontrar uma √∫nica palavra, poder√≠amos procurar a primeira letra.
  - E ent√£o procurar a palavra buscando para a direita, esquerda, para cima ou para baixo.

##

Repare que estamos decompondo o problema de resolver o ca√ßa-palavras

- em tarefas menores, que, se resolvidas, nos ajudam a resolver o problema como um todo.

. . .

√â essa a estrat√©gia que precisamos seguir na hora de programar.

##

Uma fun√ß√£o pode ser vista como um contrato.

- Se existir uma fun√ß√£o `maior` e for dito que ela recebe dois n√∫meros e retorna o maior deles,
- n√≥s podemos acreditar que se a fun√ß√£o for chamada com os n√∫meros 2 e 5, ela retornar√° 5.
  - N√≥s n√£o precisamos saber como a fun√ß√£o funciona para utiliz√°-la.
- Da mesma forma que n√£o precisamos entender de mec√¢nica de carros para frear um carro.
  - N√≥s acionamos o pedal e sabemos que a velocidade do carro vai diminuir.

##

Na aula passada usamos o Copilot para gerar c√≥digo a partir de um coment√°rio.

- Podemos fazer o mesmo para criar fun√ß√µes.

. . .

Vamos fazer um exemplo:

::: {.halfincfontsize}
```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
```
:::

##

::: {.halfincfontsize}
```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```
:::

Esse √© um poss√≠vel resultado gerado pelo Copilot.

##

```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```
- Note que assinatura de uma fun√ß√£o em python come√ßa com a palavra-chave `def`.
  - √â isso que diz para o Python que o que vem a seguir √© uma fun√ß√£o.
- Depois vem o nome da fun√ß√£o (`maior_numero`, nesse caso).
  - Dica: se parecer dif√≠cil escolher um nome para a fun√ß√£o, pode ser um sinal de que ela est√° fazendo muitas coisas.

##

```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```

- Em seguida, temos os par√¢metros da fun√ß√£o, que s√£o as entradas que ela recebe.
- Por fim, temos o corpo da fun√ß√£o, que √© onde a l√≥gica √© implementada.
  - Uma fun√ß√£o pode retornar valores ou n√£o. 
  - Quando ela retorna usamos a palavra-chave `return`.

##

```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
def maior_numero(a, b):
    if a > b:
        return a
    else:
        return b
```

Veja que, diferente de linguagens fortemente tipadas, em Python n√£o precisamos especificar os tipos

  - nem dos par√¢metros e nem do retorno da fun√ß√£o.

# Fun√ß√µes (dicas avan√ßadas) {background-color="#40666e"}

##

Dica para programadores avan√ßados:

- Apesar de Python n√£o ser fortemente tipado
  - √© uma boa pr√°tica usar [anota√ß√µes de tipo]{.alert} (_type hints_) para melhorar a legibilidade do c√≥digo.
- Isso ajuda muito na implementa√ß√£o de sistemas maiores.
- Mas afinal, o que √© isso?


## 

Vamos gerar novamente a fun√ß√£o `maior_numero`, mas agora com _type hints_.

::: {.halfincfontsize}
```python
# escreva uma fun√ß√£o que retorna o  
# maior de dois n√∫meros
# a entrada s√£o dois n√∫meros
# e a sa√≠da √© o maior entre eles
# use anota√ß√£o de tipos
```
:::

::: {.halfincfontsize}
```python {.fragment start=6}
def maior_numero(a: int, b: int) -> int:
  if a > b:
    return a
  else:
    return b    
```
:::

## 

As anota√ß√µes de tipo servem como documenta√ß√£o e podem ser utilizadas por ferramentas de an√°lise sint√°tica.

- Ou seja, s√£o √∫teis para dizer para outros programadores o que exatamente a fun√ß√£o espera e o que retorna.
- E, principalmente, para que as IDEs, como o VS Code, apontem poss√≠veis erros antes mesmo de rodar o c√≥digo.
  - Isso melhora a qualidade do c√≥digo e facilita a manuten√ß√£o.

. . .

Experimente, por exemplo, chamar a fun√ß√£o no VS Code passando uma string.

## 

Mas √© importante deixar claro que os _type hints_ n√£o alteram o comportamento do c√≥digo.

- Como Python n√£o √© uma linguagem compilada, o c√≥digo vai ser executado
  - e os _type hints_ s√£o ignorados em tempo de execu√ß√£o.
- Ou seja, se a fun√ß√£o for chamada passando um par√¢metro de tipo errado
  - isso n√£o causar√° um erro imediatamente, mas pode levar a comportamentos inesperados.
  - Na verdade quando d√° erro √© at√© melhor, o problema maior √© quando passa batido.


# Criando fun√ß√µes com Copilot {background-color="#40666e"}

## 

N√≥s hav√≠amos passado para o Copilot a tarefa de criar a fun√ß√£o completa.

- Mas outra forma de usar o Copilot √© n√≥s mesmos definirmos a assinatura da fun√ß√£o
- E pedirmos ao Copilot apenas para implementar o corpo da fun√ß√£o.
  - Isso geralmente leva a resultados melhores.

##

N√≥s podemos fazer isso usando [docstrings]{.alert}.

- Docstrings s√£o strings de documenta√ß√£o que podem ser usadas para descrever o que uma fun√ß√£o faz.
- Elas s√£o definidas logo abaixo da assinatura da fun√ß√£o e s√£o delimitadas por tr√™s aspas duplas.

. . .

::: {.callout-tip"}
√â uma boa pr√°tica escrever docstrings para suas fun√ß√µes.
:::


##

N√≥s poder√≠amos ent√£o gerar a fun√ß√£o `maior_numero` de forma diferente

- Escrevendo n√≥s mesmos o cabe√ßalho e a docstring da fun√ß√£o.
- E deixando o Copilot gerar o corpo da fun√ß√£o.
  - O que torna a gera√ß√£o do c√≥digo mais f√°cil para o Copilot.

##

Vamos ent√£o refazer a fun√ß√£o, mas agora n√≥s definimos o cabe√ßalho e docstring da fun√ß√£o.

::: {.halfincfontsize}
```python
def maior_numero(num1, num2):
  """
  num1 e num2 s√£o dois n√∫meros.

  Retorna o maior dos dois n√∫meros.
  """
```
:::

##

O Copilot pode ent√£o gerar o corpo da fun√ß√£o.

::: {.halfincfontsize}
```python
def maior_numero(num1, num2):
  """
  num1 e num2 s√£o dois n√∫meros.

  Retorna o maior dos dois n√∫meros.
  """
  if num1 > num2:
    return num1
  else:
    return num2
```
:::

##

Para terminar, vamos pedir ao Copilot para chamar a fun√ß√£o que criamos.

::: {.halfincfontsize}
```python
# chame a funcao maior_numero com os valores 3 e 5
# armazene o resultado em uma vari√°vel chamada 
# resultado e ent√£o exiba o resultado
```
:::

::: {.halfincfontsize}
```python {.fragment start=4}
resultado = maior_numero(3, 5)
print(resultado)
```
:::

##

O ciclo de projeto de fun√ß√µes com Copilot.

 1. Defina o comportamento desejado para a fun√ß√£o
 2. Escreva um prompt que descreva a fun√ß√£o
 3. Deixe o Copilot gerar o c√≥digo
 4. Avalie o c√≥digo para conferir se ele parece razo√°vel
 5. Teste o c√≥digo para conferir se ele est√° correto
  - Se estiver correto, a fun√ß√£o est√° pronta.
  - Se n√£o estiver, volte ao passo 2.

# Exemplos de boas fun√ß√µes com Copilot {background-color="#40666e"}

## Investimentos em Bolsa do Ti√£o

Ti√£o √© um investidor em uma a√ß√£o chamada PASIA.

- Ele comprou 10 a√ß√µes por R$ 15.
- Agora cada a√ß√£o vale R$ 17.
- Ele quer saber quanto lucro teria se vendesse as a√ß√µes agora.

##

Essa seria uma boa fun√ß√£o para calcular o lucro do Ti√£o?

. . .

::: {.halfincfontsize}
```python
def calcular_lucro():
  return (17 - 15) * 10
```
:::

. . .

N√£o, essa fun√ß√£o n√£o √© boa. 

- Por que?

##

Quando criamos uma fun√ß√£o devemos cri√°-la da forma **mais geral poss√≠vel**.

- Com isso, **a fun√ß√£o pode ser reutilizada** em diferentes contextos.
- Repare que, no caso do Ti√£o, ele n√£o quer saber o lucro apenas de uma compra espec√≠fica
  - mas sim de qualquer compra que ele fa√ßa.

. . .

Mesmo que voc√™ ache que isso parece muito simples.

- √â muito comum que programadores experientes repitam esse erro em contextos mais complexos.

##

Como deveria ser a assinatura da fun√ß√£o, de forma que ela seja mais √∫til?

- Quais par√¢metros deveria receber?
  - a quantidade de a√ß√µes compradas  
  - o valor que as a√ß√µes foram compradas  
  - e o pre√ßo de venda das a√ß√µes.

. . .

Poder√≠amos ent√£o definir a assinatura assim:

::: {.fontsize125}
```python
def calcular_lucro(qtd_acoes, valor_compra, valor_venda)
```
:::

##

:::{.nonincremental}
Seguindo a estrat√©gia que vimos antes, 

- vamos criar uma docstring para explicar ao Copilot o que a a√ß√£o precisa fazer.
:::

. . .

::: {.callout-tip}
Claro que essa fun√ß√£o √© muito simples e voc√™ poderia pedir ao Copilot para criar
inclusive a assinatura e a docstring.

Mas a ideia aqui √© que voc√™ entenda o processo com uma fun√ß√£o simples, para que
depois possa aplicar para fun√ß√µes mais complexas.
:::

##

::: {.fontsize125}
```python
def calcular_lucro(qtd_acoes, valor_compra, valor_atual):
  """
  qtd_acoes √© a quantidade de a√ß√µes compradas
  valor_compra √© o valor de cada uma dessas a√ß√µes
  valor_atual √© o valor atual dessas a√ß√µes
  """
```
:::

. . .

Podemos agora pedir ao Copilot para gerar o corpo da fun√ß√£o.

##

::: {.fontsize125}
```python
def calcular_lucro(qtd_acoes, valor_compra, valor_atual):
  """
  qtd_acoes √© a quantidade de a√ß√µes compradas
  valor_compra √© o valor de cada uma dessas a√ß√µes
  valor_atual √© o valor atual dessas a√ß√µes
  """
  return (valor_atual - valor_compra) * qtd_acoes
```
:::

## 

::: {.nonincremental}

N√≥s j√° fizemos os tr√™s passos iniciais do ciclo de design de fun√ß√µes.

1. Defina o comportamento desejado para a fun√ß√£o
2. Escreva um prompt que descreva a fun√ß√£o
3. Deixe o Copilot gerar o c√≥digo
4. Avalie o c√≥digo para conferir se ele parece razo√°vel
5. Teste o c√≥digo para conferir se ele est√° correto

:::

##

O pr√≥ximo passo √© [avaliar se o c√≥digo parece razo√°vel]{.alert}.

::: {.fontsize125}
```python
  return (valor_atual - valor_compra) * qtd_acoes
```
:::

. . .

Em uma fun√ß√£o simples, assim esse passo √© f√°cil :)

## 

O passo seguinte √© [testar o c√≥digo]{.alert}.

- E aqui vai uma dica interessante de uso do VS Code para testar c√≥digos Python.

. . .

Voc√™ pode selecionar o c√≥digo da fun√ß√£o no VS Code.

- E apertar <kbd>Shift</kbd> + <kbd>Enter</kbd>
- Ao fazer isso, o trecho de c√≥digo selecionado ser√° executado em um terminal Python.
- E voc√™ poder√° ent√£o fazer chamadas de teste a essa fun√ß√£o no terminal Python.

## 

::: {.nonincremental}
Um primeiro teste √≥bvio que poder√≠amos fazer 

- √© calcular o lucro da compra espec√≠fica de a√ß√µes do Ti√£o.
:::

. . .

::: {.fontsize125}
```python {code-line-numbers="false"}
>>>  calcular_lucro(10, 15, 17)
```
:::

::: {.fontsize125}
```python {.fragment code-line-numbers="false"}
20
```
:::

. . .

Est√° certo?

- Sim, como ele teve 2 reais de lucro em cada a√ß√£o e s√£o 10 a√ß√µes, o total √© 20.

. . .

Precisamos agora pensar em mais [casos de testes]{.alert}.

##

Testar se as a√ß√µes tivessem subido para R$ 18 em vez de R$ 17 seria um bom teste?

- N√£o, porque seria um teste de um caso na **mesma categoria** do teste anterior.
- Precisamos pensar em situa√ß√µes diferentes.

. . .

Por exemplo:

- Uma situa√ß√£o que desse preju√≠zo.
- Ou que as a√ß√µes permanecessem no mesmo pre√ßo.

##

Podemos inverter o pre√ßo de compra e o atual para testar o preju√≠zo.

::: {.fontsize125}

```python {code-line-numbers="false"}
>>>  calcular_lucro(10, 17, 15)
```
```python {.fragment code-line-numbers="false"}
-20
```
:::

. . .

E testar o caso do pre√ßo da a√ß√£o ser mantido

::: {.fontsize125}
```python {code-line-numbers="false"}
>>>  calcular_lucro(10, 15, 15)
```
```python {.fragment code-line-numbers="false"}
0
```
:::

##

Mas como saber quantas categorias testar?

- Como ter certeza se dois testes n√£o s√£o da mesma categoria?
- Ou se eles cobrem todas categorias poss√≠veis?

. . .

Testes s√£o uma combina√ß√£o de **ci√™ncia üß™** e **arte üé®**

- √â necess√°rio pr√°tica e experi√™ncia para definir bem casos de testes.
- E vamos ter aula espec√≠fica sobre isso mais adiante na disciplina.

## A senha do Ti√£o

Ti√£o est√° se inscrevendo em uma nova rede social chamada _ProgrammersKingdom_.

- Ele quer ter certeza que a senha que ele vai usar √© forte o suficiente.

. . .

Vamos come√ßar com uma defini√ß√£o bem simples do que √© uma senha forte.

- E depois vamos melhorar a fun√ß√£o.
- No meio do caminho vamos nos acostumando com a sintaxe do Python.

##

A princ√≠pio, vamos considerar que uma senha √© forte se ela n√£o for `'1234'` ou `'senha'`.

- Vamos ent√£o definir o cabe√ßalho e a docstring de uma fun√ß√£o que recebe uma
  poss√≠vel senha e retorna se ela √© forte ou n√£o.

. . .

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha'

    Retorna True se a senha for forte e False em caso contr√°rio
    """    
```
:::

##

Suponha que seja esse o c√≥digo gerado.

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha'

    Retorna True se a senha for forte e False em caso contr√°rio
    """    
    if senha == "1234" or senha == "senha":
        return False
    return True
```
:::

. . .

Seguindo pr√≥ximo passo do **ciclo de design de fun√ß√µes**, avaliamos se o c√≥digo parece razo√°vel.

- O que acha?

##

Vamos agora testar a fun√ß√£o usando <kbd>Shift</kbd> + <kbd>Enter</kbd> no VS Code.

::: {.fontsize125}

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("1234")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("senha")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("admin")
```
```python {.fragment code-line-numbers="false"}
True
```

:::

. . . 

`'admin'` claramente n√£o √© uma senha forte üôÇ

##

Vamos melhorar a defini√ß√£o da nossa fun√ß√£o.

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha' ou 'admin'

    Retorna True se a senha for forte e False em caso contr√°rio
    """    
```
```python {.fragment}  
    if senha in ['1234', 'senha', 'admin']:
        return False
    return True

```
:::

##

```python
def eh_senha_forte(senha):
    """
    Uma senha √© forte se n√£o for '1234' ou 'senha' ou 'admin'

    Retorna True se a senha for forte e False em caso contr√°rio
    """
    if senha in ['1234', 'senha', 'admin']:
        return False
    return True

```

Repare que, nesse caso, o Copilot gerou um c√≥digo que usa uma [lista]{.alert}.

- Podemos declarar listas em Python entre colchetes e com valores separados por v√≠rgulas.
- E o operador `in` indica se um elemento pertence √† lista.

. . .

O c√≥digo parece razo√°vel? Hora de testar!

##

Mas nossa fun√ß√£o ainda aceita `'Ti√£o'` como senha, o que √© claramente ruim.

- Vamos ent√£o deixar a defini√ß√£o de senha forte, mais forte üí™.

##

```python
def eh_senha_forte(senha):
    """
    Uma senha forte tem pelo menos uma letra mai√∫scula,
    uma letra min√∫scula, um n√∫mero e um caractere especial.

    Retorna True se a senha for forte e False em caso contr√°rio
    """  
```
```python {.fragment start=8}
    tem_maiuscula = any(c.isupper() for c in senha)
    tem_minuscula = any(c.islower() for c in senha)
    tem_numero = any(c.isdigit() for c in senha)
    tem_especial = any(not c.isalnum() for c in senha)
    return tem_maiuscula and tem_minuscula and tem_numero and tem_especial
```

. . .

O c√≥digo gerado pelo Copilot parece bem claro sobre o que est√° fazendo no geral.

- Mas h√° constru√ß√µes de Python nos detalhes que podem ser melhor exploradas.

## 

Vamos pedir ao Copilot para explicar o trecho `c.isupper() for c in senha`.

- Para isso, aperte <kbd>Ctrl</kbd> + <kbd>I</kbd> e digite `explique essa constru√ß√£o do python`.

##

Essa √© uma poss√≠vel resposta do Copilot.

<div style="overflow:auto; max-height:400px; text-align:center;">
  <img src="imagens/copilot_explicacao_senhaforte.png" alt="Explica√ß√£o do Copilot sobre o trecho c.isupper() for c in senha." style="width:auto; max-width:100%;">
</div>

. . .

Esse √© um bom exemplo de como o Copilot pode nos ajudar a entender um c√≥digo j√° implementado.

## 

Agora que o c√≥digo parece razo√°vel, vamos passar para a fase de testes.

::: {.fontsize125}

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o4*")
```
```python {.fragment code-line-numbers="false"}
True
```

:::

. . .

Parece tudo certo, n√©? Mas vamos testar mais um caso.

::: {.fontsize125}
```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o da Silva")
```
```python {.fragment code-line-numbers="false"}
True
```
:::

. . . 

Essa n√£o era uma senha forte, pois n√£o parece conter caracteres especiais.

## 

O que ser√° que aconteceu?

- Vamos analisar a linha que trata caracteres especiais.

. . .

::: {.fontsize125}
```python {.fragment start=8}
    tem_especial = any(not c.isalnum() for c in senha)
```
:::

. . .

Podemos pedir ao copilot para explicar o funcionamento da fun√ß√£o `isalnum`.

##

Essa √© uma poss√≠vel resposta do Copilot.

<div style="overflow:auto; max-height:400px; text-align:center;">
  <img src="imagens/copilot_explicacao_isalnum.png" alt="Explica√ß√£o do Copilot sobre o trecho a fun√ß√£o isalnum()" style="width:auto; max-width:100%;">
</div>

. . .

Veja que o caractere espa√ßo n√£o √© alfanum√©rico, ou seja, n√£o √© uma letra ou um n√∫mero.

##

Podemos pedir ao Copilot para corrigir.

- Ou fazer uma engenharia de prompt.
  - O que no caso, significa mudar a maneira como documentamos a fun√ß√£o.

. . .

Vamos experimentar substituir _caractere especial_ por _caractere de pontua√ß√£o_ na docstring da fun√ß√£o.

##

::: {.fontsize125}
```python
def eh_senha_forte(senha):
    """
    Uma senha forte tem pelo menos uma letra mai√∫scula,
    uma letra min√∫scula, um n√∫mero e um caractere de pontua√ß√£o.

    Retorna True se a senha for forte e False em caso contr√°rio
    """  
```
:::

##

```python
def eh_senha_forte(senha):
    """
    Uma senha forte tem pelo menos uma letra mai√∫scula,
    uma letra min√∫scula, um n√∫mero e um caractere de pontua√ß√£o.

    Retorna True se a senha for forte e False em caso contr√°rio
    """  
    import string

    if len(senha) < 8:
        return False

    tem_maiuscula = any(c.isupper() for c in senha)
    tem_minuscula = any(c.islower() for c in senha)
    tem_numero = any(c.isdigit() for c in senha)
    tem_pontuacao = any(c in string.punctuation for c in senha)

    return tem_maiuscula and tem_minuscula and tem_numero and tem_pontuacao
```

. . .

Esse foi o c√≥digo gerado pelo Copilot.

- Ao analisar se o c√≥digo parece razo√°vel h√° dois pontos que vale a pena destacar.

## 

A primeira √© que o c√≥digo usa a fun√ß√£o `string.punctuation` que parece que vai fazer o que precisamos.

- Mas para ela funcionar, foi necess√°rio importar um m√≥dulo do Python: `import string`.

. . .

Python possui diversos m√≥dulos que podem ser importados para ajudar a realizar tarefas espec√≠ficas.

- A linguagem j√° vem com muitos deles.
- Mas o grande potencial da linguagem √© a quantidade de bibliotecas de terceiros que podem ser instaladas e utilizadas.

##

Repare que o c√≥digo foi gerado fazendo a importa√ß√£o do m√≥dulo dentro da pr√≥pria fun√ß√£o.

- O que n√£o √© uma boa pr√°tica de programa√ß√£o.
- Porque deixa as depend√™ncias de c√≥digo menos leg√≠veis para outros programadores.

. . .

O ideal √© levar o import para o in√≠cio do arquivo.

- E, portanto, de fora da fun√ß√£o.

##

```python
import string

def eh_senha_forte(senha):
    """
    Uma senha forte tem pelo menos uma letra mai√∫scula,
    uma letra min√∫scula, um n√∫mero e um caractere de pontua√ß√£o.

    Retorna True se a senha for forte e False em caso contr√°rio
    """  

    if len(senha) < 8:
        return False

    tem_maiuscula = any(c.isupper() for c in senha)
    tem_minuscula = any(c.islower() for c in senha)
    tem_numero = any(c.isdigit() for c in senha)
    tem_pontuacao = any(c in string.punctuation for c in senha)

    return tem_maiuscula and tem_minuscula and tem_numero and tem_pontuacao
```

##

Apenas tome cuidado na hora de testar a fun√ß√£o usando <kbd>Shift</kbd> + <kbd>Enter</kbd> para executar a c√©lula.

- Pois, se n√£o selecionar tamb√©m a linha que cont√©m o import, o c√≥digo n√£o vai funcionar.

. . .

::: {.fontsize125}
```python {code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o3da!Silva")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 12, in eh_senha_forte
  File "<stdin>", line 12, in <genexpr>
NameError: name 'string' is not defined. Did you forget to import 'string'?
```
:::

##

::: {.smaller}

Obs.: no teste feito pelos autores do livro, o import n√£o foi gerado nem dentro da fun√ß√£o.

- Se isso acontecer com voc√™, voc√™ pode inserir manualmente ou pedir o Copilot para corrigir.
:::

##

Outra obseva√ß√£o sobre o c√≥digo gerado pelo Copilot √© que ele criou uma regra que n√£o hav√≠amos solicitado.

. . .

::: {.fontsize125}
```python {code-line-numbers="false"}
    if len(senha) < 8:
        return False
```
:::

. . .

Ele acrescentou uma verifica√ß√£o que obriga que a senha tenha pelo menos 8 caracteres.

- A fun√ß√£o `len` retorna o tamanho de uma string (ou de uma lista, por exemplo).

##

Mesmo que consideremos que pode ter sido uma boa sugest√£o para esse caso.

- √â importante que estejamos atentos para esse fato:
  - Assistentes de IA podem **inventar regras de neg√≥cio** que n√£o foram solicitadas.
- O que refor√ßa a import√¢ncia da avalia√ß√£o e teste de c√≥digo.

. . .

Para o nosso exemplo, vamos remover essas linhas.

- √â hora ent√£o de testar o c√≥digo.

##

::: {.fontsize125}

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o da Silva")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o3da Silva")
```
```python {.fragment code-line-numbers="false"}
False
```

```python {.fragment code-line-numbers="false"}
>>> eh_senha_forte("Ti√£o3da!Silva")
```
```python {.fragment code-line-numbers="false"}
True
```

:::

. . .

Parece tudo OK agora ‚úÖ

## 

Espero que esses exemplos tenham mostrado a import√¢ncia de testes de c√≥digo.

- Programadores iniciantes muitas vezes n√£o testam seu c√≥digo.
- Eles confiam que o c√≥digo est√° correto pois, analisando o c√≥digo, ele parece fazer sentido.

. . . 

Uma diferen√ßa bem comum entre juninhos e progamadores experientes √©:

- Juninhos sempre assumem que seu c√≥digo est√° correto.
- Enquanto experientes sempre assumem que est√° errado;
  - at√© que tenham testado e provado o contr√°rio.

##

Um dos motivos que iniciantes falham em testar c√≥digo

- √© porque parece meio desanimador descobrir que seu c√≥digo est√° errado.

. . .

Mas, na verdade, quanto antes descobrirmos que uma fun√ß√£o est√° errada melhor.

- Por que d√° muito mais trabalho quando j√° desenvolvemos muitas fun√ß√µes.
- E temos que descobrir porque o sistema n√£o funciona.

. . .

‚ö†Ô∏è Me chamou a aten√ß√£o que, na Pesquisa de Perfil da Turma, poucos de voc√™s usam Copilot para gerar testes!

##

Para finalizar o trabalho com senhas fortes

- vamos criar uma fun√ß√£o que pede ao usu√°rio uma senha
- e, se ela n√£o forte, pede a senha novamente at√© que seja uma senha forte.
- Que √© mais ou menos o que os sites fazem quando criamos uma senha.

. . .

Qual poderia ser a assinatura dessa fun√ß√£o?

##

A fun√ß√£o n√£o precisa de par√¢metros, pois n√£o depende de nenhuma informa√ß√£o externa.

::: {.fontsize125}
```python 
def obter_senha_forte():
  """
  Fica pedindo uma senha para o usu√°rio at√©
  que ele digite uma senha forte.

  Se a senha n√£o for forte, avisa que ela n√£o √©.
  Se for, retorna a senha forte
  """
```
:::

##

::: {.fontsize125}
```python 
def obter_senha_forte():
  """
  Fica pedindo uma senha para o usu√°rio at√©
  que ele digite uma senha forte.

  Se a senha n√£o for forte, avisa que ela n√£o √©.
  Se for, retorna a senha forte
  """
  while True:
      senha = input("Digite uma senha forte: ")
      if eh_senha_forte(senha):
          return senha
      print("A senha n√£o √© forte. Tente novamente.")
```
:::

. . .

Veja que o c√≥digo gerado pelo Copilot usa a fun√ß√£o `eh_senha_forte` que hav√≠amos criado anteriormente.

- O c√≥digo parece razo√°vel?

##

Para testar no VS Code, temos agora que lembrar de selecionar as duas fun√ß√µes.

. . .

::: {.fontsize125}
```python  {code-line-numbers="false"} 
>>> obter_senha_forte()
Digite uma senha forte: ti√£o !!@*#@
A senha n√£o √© forte. Tente novamente.
Digite uma senha forte: ti√£o!!@*#@
A senha n√£o √© forte. Tente novamente.
Digite uma senha forte: Ti√£o1!@*#@
'Ti√£o1!@*#@'
```
:::

- Repare que a √∫ltima linha √© o retorno da fun√ß√£o `obter_senha_forte()`.


# Benef√≠cios das fun√ß√µes {background-color="#40666e"}

##

Al√©m das fun√ß√µes serem essenciais na **decomposi√ß√£o de problemas**,

- elas tamb√©m trazem outros benef√≠cios.


## [Esfor√ßo cognitivo]{.alert}

. . .

::: {.callout-tip}
**Esfor√ßo cognitivo** tem rela√ß√£o com a quantidade de informa√ß√£o que seu c√©rebro consegue processar ao mesmo tempo e ainda ser efetivo.
:::

. . .

Se algu√©m te disser 4 palavras aleat√≥rias e pedir para voc√™ repetir, provavelmente voc√™ conseguir√°.

- Mas se a pessoa disser 20 palavras, provavelmente voc√™ ter√° dificuldades.
- A mesma dificuldade acontece quando temos que pensar em detalhes de uma situa√ß√£o muito complexa.

## [Esfor√ßo cognitivo]{.alert}

Programadores t√™m o mesmo problema.

- Se tentarem resolver um problema complexo tudo de uma vez, t√™m dificuldade de criar um c√≥digo correto.

. . .

Fun√ß√µes ajudam os programadores a evitarem fazer tudo de uma vez.

## [Evitar repeti√ß√£o]{.alert}

. . .

Programadores, e pessoas em geral, n√£o gostam muito de resolver o mesmo problema repetidamente.

- Se voc√™ criar uma fun√ß√£o que calcula a √°rea de um c√≠rculo, por exemplo,
  - e precisar desse c√°lculo em lugares diferentes de um sistema,
  - voc√™ pode chamar a mesma fun√ß√£o nos dois lugares.

. . . 

::: {.callout-tip}
**Reutiliza√ß√£o de c√≥digo**, que √© o contr√°rio da replica√ß√£o, √© uma caracter√≠stica de um c√≥digo bem projetado.
:::

## [Melhoria dos testes]{.alert}

. . .

√â muito mais complicado testar um c√≥digo que faz muitas coisas ao mesmo tempo.

. . .

Quando criamos fun√ß√µes para tarefas espec√≠ficas, podemos test√°-las individualmente.

- Essa √© uma t√©cnica chamada [teste unit√°rio]{.alert}.
- Utilizamos diferentes casos de teste com diferentes par√¢metros de entrada.
- Se todos eles produzirem uma sa√≠da correta, provavelmente nossa fun√ß√£o n√£o causar√° problema no sistema como um todo.

## [Melhoria dos testes]{.alert}

::: {.callout-tip}
**Testes unit√°rios** s√£o altamente recomendados em softwares bem projetados.
:::

## [Melhoria da confiabilidade]{.alert}

. . .

Engenheiros de software experientes cometem erros, e sabemos que o Copilot tamb√©m.

. . .

Se voc√™ for um programador incr√≠vel, e cada linha de c√≥digo que voc√™ escreve tiver 95% de chances de estar certa,

- quantas linhas de c√≥digo voc√™ acha que conseguiria escrever antes que pelo menos uma linha de c√≥digo fosse provavelmente incorreta?
  - A resposta s√£o 14 linhas de c√≥digo!

. . .

Obs.: veja a explica√ß√£o estat√≠stica do ChatGPT sobre as 14 linhas [aqui](https://chatgpt.com/share/68a0d06e-a1e4-800e-8aaa-8644f1edf204). üòÉ


## [Melhoria da confiabilidade]{.alert}

Note que 95% √© um n√≠vel bem alto, mas, mesmo assim, √© poss√≠vel que erros aconte√ßam em poucas linhas.

- Por isso, dividir um problema em fun√ß√µes com at√© 12 (ou, no m√°ximo, 20 linhas)
- diminui a probabilidade de que exista um erro no c√≥digo.

. . .

Sem contar que quando um c√≥digo tem muitos erros que interagem entre si,

- a probabilidade se gerem gerados novos erros ainda maiores s√≥ aumenta.

## [Melhoria da confiabilidade]{.alert}

Todo programador experiente j√° passou horas üò´ depurando um c√≥digo que tinha m√∫ltiplos erros.

- Que poderiam ter sido evitadas com testes mais frequentes em trechos menores e c√≥digo.

## [Melhoria da legibilidade de c√≥digo]{.alert}

. . .

Mesmo usando Copilot, quando pensamos em software desenvolvido por v√°rias pessoas

- √© importante que seja f√°cil para a equipe entender o c√≥digo existente,
- independente se ele foi criado pelo Copilot ou por outros programadores.

## [Melhoria da legibilidade de c√≥digo]{.alert}

Isso torna mais f√°cil tarefas como:

- encontrar bugs;
- determinar onde come√ßar a alterar o c√≥digo para acrescentar uma nova funcionalidade;
- entender, em alto n√≠vel, se seria f√°cil ou n√£o fazer alguma altera√ß√£o no sistema que estejamos prospectando.

## [Melhoria da legibilidade de c√≥digo]{.alert}

::: {.nonincremental}
Ter as tarefas do sistema divididas em fun√ß√µes

- nos ajuda a entender o que cada parte do c√≥digo faz
- e a ter uma melhor percep√ß√£o sobre como as coisas funcionam no todo.
:::

. . .

Tamb√©m nos ajuda a dividir o trabalho e as responsabilidades de forma a garantir que o c√≥digo est√° correto.

# Caracter√≠sticas de boas fun√ß√µes {background-color="#40666e"}

##

N√£o h√° uma regra absoluta para definir o que √© uma boa fun√ß√£o.

- Mas h√° recomenda√ß√µes e intui√ß√µes que podemos compartilhar.
- Mesmo com elas, saiba que identificar boas fun√ß√µes √© uma habilidade que requer tempo e pr√°tica.

. . .

Antes de entrar nas recomenda√ß√µes, voc√™ ver√° que usaremos aqui o termo "fun√ß√µes folha" (_leaf functions_).

- Esse termo se referem a fun√ß√µes que n√£o chamam nenhuma outra fun√ß√£o do nosso pr√≥prio sistema.
- A ideia vem de que em uma √°rvore, a partir da raiz, as folhas s√£o as "pontas".

## [Uma tarefa clara a realizar]{.alert}

. . .

Uma fun√ß√£o folha pode ser algo como:

- Calcular o volume de uma esfera.
- Encontrar o maior n√∫mero em uma lista.
- Verificar se uma lista tem um valor espec√≠fico.

. . .

Fun√ß√µes que n√£o s√£o folha podem ter objetivos mais amplos, como:

- Atualizar os gr√°ficos do jogo.
- Mas ainda assim devem ter um objetivo espec√≠fico,
  e devem chamar outras fun√ß√µes para atingir esse objetivo.

## [Comportamento claramente definido]{.alert}

. . .

A tarefa _"encontrar o maior n√∫mero em uma lista"_ √© claramente definida.

- Se algu√©m te der uma lista de n√∫meros e te pedir o maior n√∫mero, voc√™ sabe exatamente o que fazer.

. . .

J√° a tarefa _"encontre a melhor palavra em uma lista"_ √© mal definida.

- Falta informa√ß√£o: o que significa palavra "melhor"?
- √â a palavra mais longa, a que tem menos vogais, a que tem `J`?

## [Comportamento claramente definido]{.alert}

A quest√£o √© que tarefas **subjetivas** n√£o s√£o boas para computadores.

. . .

√â comum conseguimos deixar claro o comportamento da fun√ß√£o s√≥ pelo seu nomes.

- Mas muitas vezes isso n√£o √© poss√≠vel, e usamos a docstring para dar mais detalhes sobre a tarefa.

. . . 


::: {.callout-tip}
Se precisar escrever mais do que algumas linhas em uma docstring de uma fun√ß√£o folha, pode ser um sinal
de que a tarefa √© muito grande para uma √∫nica fun√ß√£o.
:::

## [Poucas linhas de c√≥digo]{.alert}

. . .

Muitas empresas de software tem guias de estilo de programa√ß√£o que sugerem um limite no n√∫mero de linhas das fun√ß√µes.

- Esse limite geralmente varia de 12 a 20 linhas.

. . .

Na verdade o n√∫mero de linhas √© um _proxy_ para a complexidade do c√≥digo.

- E acaba sendo um _proxy_ bem razo√°vel.

. . .

::: {.callout-tip}
Se o Copilot gerar uma fun√ß√£o para voc√™ com 50 linhas de c√≥digo, √© recomend√°vel pedir que ele quebre a tarefa em fun√ß√µes menores.
:::

## [Uso geral em vez de uso espec√≠fico]{.alert}

. . .

Criar uma fun√ß√£o que retorna todos os n√∫meros de uma lista maiores que 5

- pode ser √∫til para uma necessidade espec√≠fica.
- Mas a fun√ß√£o seria muito mais √∫til se o limite fosse um par√¢metro.

. . .

Seguimos a mesma ideia ao calcular o lucro das a√ß√µes do Ti√£o.

. . .

::: {.callout-tip}
Vale a pena reescrever uma fun√ß√£o se percebermos que ela pode ter um uso mais geral.
:::

## [Entrada e sa√≠da claras]{.alert}

. . .

√â importante que uma fun√ß√£o tenha par√¢metros e valores de retorno bem definidos.

- Pode ser que precisemos de uma fun√ß√£o que receba muitos par√¢metros,
  - ou que retorne v√°rios valores.
- Mas √© importante sempre questionar se eles s√£o realmente necess√°rios ou se n√£o teria outro jeito de resolver a tarefa.

. . .

::: {.callout-tip}
Se voc√™ est√° criando uma fun√ß√£o que √†s vezes retorna uma lista, √†s vezes um valor √∫nico e 
√†s vezes n√£o retorna nada, √© um sinal de que ela provavelmente n√£o √© uma boa fun√ß√£o.
:::

## 

::: {.nonincremental}
Em resumo, esse ent√£o √© o **guia para criarmos boas fun√ß√µes**.

1. Uma tarefa clara a realizar
2. Comportamento claramente definido
3. Poucas linhas de c√≥digo
4. Uso geral em vez de uso espec√≠fico
5. Entrada e sa√≠da claras
:::

## Exemplos de **boas** fun√ß√µes folha

- _Calcular o volume de uma esfera_ 
  - Dado o raio da esfera calcula seu volume.
- _Encontrar o maior n√∫mero em uma lista_
  - Dada uma lista, retorna seu maior valor.
- _Verificar se a lista cont√©m um valor espec√≠fico_ 
  - Dada uma lista e um valor, retornar True se ela tem o valor e False em caso contr√°rio.

## Exemplos de **boas** fun√ß√µes folha

- _Exibir o estado de um jogo de Xadrez_
  - Dada uma lista 2D representando o tabuleiro do jogo, exibir o tabuleiro na tela em formato texto.
- _Inserir um valor em uma lista_
  - Dada uma lista, um novo valor e uma posi√ß√£o na lista, retornar uma nova lista que √© a lista original com o novo valor inserido na posi√ß√£o especificada.

## Fun√ß√µes folha **ruins**

Vamos agora ver alguns exemplos de fun√ß√µes folha ruins e porque elas s√£o ruins.

. . .

_Pedir informa√ß√µes fiscais de um usu√°rio e calcular seu imposto de renda_

- Calcular imposto de renda envolve v√°rios c√°lculos que deveriam ser implementados em fun√ß√µes separadas.

## Fun√ß√µes folha **ruins**

_Remover o maior valor de uma lista_

- Pode n√£o parecer ruim a princ√≠pio, mas veja que estamos fazendo duas coisas.
  - Precisamos encontrar o maior valor na lista.
  - E precisamos remover um valor da lista.
- Assim, seria mais reutiliz√°vel ter uma fun√ß√£o folha para cada subtarefa.
  - Obs.: pode ser √∫til criar uma fun√ß√£o n√£o folha que chama as outras duas se isso for usado v√°rias vezes em um sistema.

## Fun√ß√µes folha **ruins**

_Dado um conjunto de dados estat√≠sticos de partidas de futebol, retornar os nomes dos zagueiros que correram mais de 8 km_

- H√° muita informa√ß√£o espec√≠fica nesse caso.
- Claramente a dist√¢ncia percorrida poderia ser um par√¢metro.
- Mas, se pensarmos bem, inclusive a posi√ß√£o dos jogadores poderia ser um par√¢metro.
- Melhor ainda seria se a pr√≥pria estat√≠stica fosse um par√¢metro.
  - Poder√≠amos querer consultar o n√∫mero de gols feitos ou de faltas recebidas, por exemplo.

## Fun√ß√µes folha **ruins**

_Determinar o melhor filme de todos os tempos_

- O problema dessa fun√ß√£o √© que ela √© muito vaga.
  - O que define o que √© um bom filme?
  - Quais filmes deveriam ser considerados?
- Seria mais claro se a fun√ß√£o recebesse uma lista de filmes com suas respectivas avalia√ß√µes e um n√∫mero limite de avalia√ß√µes.
  - E retornasse os filmes melhor avaliados que tivesse, pelo menos, o n√∫mero de avalia√ß√µes passado como limite.

## Fun√ß√µes folha **ruins**

_Jogar Call of Duty_

- Precisa explicar? ü§ì
 
# Dica: escolhendo sugest√£o do Copilot  {background-color="#40666e"}

##

Quando pedimos ao Copilot para gerar um c√≥digo, podemos avaliar outras poss√≠veis sugest√µes dele.

. . .

Para exemplificar isso, suponha que vamos criar um programa para jogar `Scrabble`.

- √â um jogo de tabuleiro baseado em palavras-cruzadas.
- Dois jogadores devem ir completando palavras em um tabuleiro com pe√ßas de letras.
   - E, quando consegue formar uma palavra, o jogador ganha pontos dependendo das letras da palavra.

##

Vamos trabalhar aqui apenas com a fun√ß√£o que calcula os pontos de uma palavra.

- O cabe√ßalho e docstring abaixo mostram como √© o c√°lculo na vers√£o do jogo em portugu√™s.

. . .

```python 
def numero_de_pontos(palavra):
    """
    Cada letra na palavra vale os seguintes pontos:
    a, e, i, o, u, m, s, r, t: 1 ponto
    d, l, c, p: 2 pontos
    n, b, √ß: 3 pontos
    f, g, h, v: 4 pontos
    j: 5 pontos
    q: 6 pontos
    x, z: 8 pontos

    palavra √© uma palavra formada por letras caracteres min√∫sculos
    Retorna a soma dos pontos de cada letra da palavra
    """
```

## 

Uma poss√≠vel resposta do Copilot para o corpo da fun√ß√£o √©:

```python 
    pontos = 0
    for letra in palavra:
        if letra in "aeioumsrt":
            pontos += 1
        elif letra in "dlcp":
            pontos += 2
        elif letra in "nb√ß":
            pontos += 3
        elif letra in "fghv":
            pontos += 4
        elif letra == "j":
            pontos += 5
        elif letra == "q":
            pontos += 6
        elif letra in "xz":
            pontos += 8
    return pontos
```

## 

O c√≥digo parece razo√°vel, e nosso pr√≥ximo passo seria testar a fun√ß√£o.

- Mas o ponto que quero mostrar aqui √© como escolher as sugest√µes do Copilot.

## 

Quando o Copilot sugere o c√≥digo, ele aparece esmaecido e em it√°lico.

- Antes de apertarmos <kbd>TAB</kbd> para aceitar o c√≥digo, 
- podemos avaliar outras sugest√µes que o Copilot oferece.
  - Isso pode ser feito passando o mouse sobre o c√≥digo e escolhendo no painel que aparece acima do c√≥digo.
  - Ou pelo atalho <kbd>Alt</kbd> + <kbd>]</kbd> para ver a pr√≥xima sugest√£o ou <kbd>Alt</kbd> + <kbd>[</kbd> para ver a anterior.

##

Uma segunda sugest√£o feita pelo c√≥digo para o corpo da fun√ß√£o foi:

```python 
    pontos = {
        'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'm': 1, 's': 1, 'r': 1, 't': 1,
        'd': 2, 'l': 2, 'c': 2, 'p': 2,
        'n': 3, 'b': 3, '√ß': 3,
        'f': 4, 'g': 4, 'h': 4, 'v': 4,
        'j': 5,
        'q': 6,
        'x': 8, 'z': 8
    }
    total = 0
    for letra in palavra:
        total += pontos.get(letra, 0)  # Adiciona o valor da letra ou 0 se n√£o estiver no dicion√°rio
    return total
```

##

Essa segunda sugest√£o usa um [dicion√°rio]{.alert} para guardar o valor de cada letra.

- Um dicion√°rio do Python √© uma estrutura similar a um `HashMap` do Java.

. . .

No c√≥digo o dicion√°rio `pontos` usa as letras como chaves e os pontos correspondentes como valores.

- Assim, ao percorrer a palavra uma letra de cada vez.
  - podemos consultar o dicion√°rio para buscar quanto vale a letra.

## 

::: {.nonincremental}
Em uma terceira sugest√£o, o Copilot fez a soma dos pontos em uma √∫nica linha, trocando o trecho

::: {.fontsize125}
```python 
    total = 0
    for letra in palavra:
        total += pontos.get(letra, 0)  # Adiciona o valor da letra ou 0 se n√£o estiver no dicion√°rio
    return total
```
:::

por

::: {.fontsize125}
```python 
    return sum(pontos.get(letra, 0) for letra in palavra)
```
:::

:::

- Esse tipo de constru√ß√£o usando [list comprehension]{.alert} √© muito comum em Python.

##

::: {.callout-tip}
Voc√™ pode fazer com o que o painel de escolha das sugest√µes do Copilot fique sempre vis√≠vel, 
para n√£o precisar passar o mouse sobre o c√≥digo para acess√°-lo.

Para isso, quando ele aparecer uma vez, acesse os bot√£o de tr√™s pontos ao final do painel e 
escolha a op√ß√£o _Always show toolbar_.
:::

##

Para fechar o exemplo, suponha que o Ti√£o est√° jogando Scrabble

- e tem tr√™s palavras que poderiam ser encaixadas agora: _zape_, _pazes_ e _pizza_.
- ele gostaria de saber qual palavra d√° mais pontos.

. . .

O que acha do cabe√ßalho abaixo para uma fun√ß√£o que retorne a melhor dessas tr√™s palavras?

::: {.fontsize125}
```python
def melhor_palavra(palavra1, palavra2, palavra3):
```
:::

##

::: {.fontsize125}
```python
def melhor_palavra(palavra1, palavra2, palavra3):
```
:::

De acordo com o **guia para criarmos boas fun√ß√µes** essa n√£o √© uma boa fun√ß√£o, por que?

- Ela poderia ser mais geral, funcionando para qualquer quantidade de palavras.
- Poder√≠amos, por exemplo, receber uma lista de palavras como par√¢metro.

. . .

Vamos ent√£o melhorar a defini√ß√£o da fun√ß√£o.

##

::: {.fontsize125}
```python
def melhor_palavra(palavras):
    """
    palavras √© uma lista de palavras.

    Retorna a palavra com a maior pontua√ß√£o.
    """
```
```python {.fragment start=7}
    if not palavras:
        return None  # Retorna None se a lista estiver vazia

    melhor = palavras[0]
    max_pontos = numero_de_pontos(melhor)

    for palavra in palavras[1:]:
        pontos = numero_de_pontos(palavra)
        if pontos > max_pontos:
            melhor = palavra
            max_pontos = pontos

    return melhor
```
:::

##

Escolhendo entre as sugest√µes do Copilot, essa foi outra op√ß√£o:

::: {.fontsize125}
```python
def melhor_palavra(palavras):
    """
    palavras √© uma lista de palavras.

    Retorna a palavra com a maior pontua√ß√£o.
    """
    return max(palavras, key=numero_de_pontos)
```
:::

. . .

Qual das duas op√ß√µes voc√™ prefere?

##

Talvez seja prematuro escolher sem fazer testes.

. . .

Veja esse teste feito com a segunda op√ß√£o:

::: {.fontsize125}
```python {.fragment code-line-numbers="false"}
>>> melhor_palavra([])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in melhor_palavra
ValueError: max() iterable argument is empty
```
:::

. . .

Esse erro n√£o ocorreria na primeira op√ß√£o.

##

A dica portanto √©:

- Para qualquer que seja a sugest√£o escolhida √©: **sempre testar!**

. . .

A segunda op√ß√£o poderia ser alterada para a acrescentar o mesmo `if` da primeira op√ß√£o.

- Nesse caso, qual voc√™ escolheria?
- Sugest√£o: depende do seu objetivo.
  - A primeira op√ß√£o √© mais leg√≠vel.
  - A segunda √© mais compacta.